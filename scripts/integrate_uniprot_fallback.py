"""
Integrate UniProt fallback mapping results into the Phase 1 forward mapping pipeline.

This script performs the following steps:
1. Reads the original phase1_forward_mapping_intermediate.tsv file
2. Reads the UniProt fallback mapping results (generated by the UniProtIDMappingClient)
3. Updates the mapping information for entries that were successfully mapped via UniProt
4. Generates a new, enriched output file with all mapping results
"""

import pandas as pd
import json
import os
from pathlib import Path
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("logs/integrate_uniprot_fallback.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Define paths
PHASE1_INTERMEDIATE_FILE = "/home/ubuntu/output/phase1_forward_mapping_intermediate.tsv"
UNIPROT_FALLBACK_RESULTS_FILE = "/home/ubuntu/output/uniprot_fallback_results.tsv"  # To be produced by Cascade
ARIVALE_METADATA_PATH = "/procedure/data/local_data/ARIVALE_SNAPSHOTS/proteomics_metadata.tsv"
OUTPUT_DIR = "/home/ubuntu/output"
FINAL_OUTPUT_FILE = os.path.join(OUTPUT_DIR, "phase1_forward_mapping_complete.tsv")

def load_arivale_metadata():
    """Load Arivale proteomics metadata."""
    logger.info(f"Loading Arivale metadata from {ARIVALE_METADATA_PATH}")
    
    # Find header row, skipping comments
    header_line = 0
    with open(ARIVALE_METADATA_PATH, "r", encoding="utf-8") as f:
        for i, line in enumerate(f):
            if not line.strip().startswith("#"):
                header_line = i
                break
    
    # Load the data
    arivale_df = pd.read_csv(
        ARIVALE_METADATA_PATH, 
        sep="\t", 
        skiprows=header_line
    )
    
    # Add columns with our naming convention for output
    arivale_df['arivale_protein_id'] = arivale_df['name']
    arivale_df['arivale_uniprot_ac'] = arivale_df['uniprot']
    arivale_df['arivale_gene_symbol'] = arivale_df['gene_name']
    arivale_df['arivale_protein_name'] = arivale_df['gene_description']
    
    logger.info(f"Loaded {len(arivale_df)} Arivale protein entries")
    return arivale_df

def integrate_uniprot_results(phase1_df, uniprot_results_df, arivale_df):
    """
    Integrate UniProt fallback mapping results into the phase1 dataframe.
    
    Args:
        phase1_df: DataFrame containing the original phase1 mapping results
        uniprot_results_df: DataFrame containing the UniProt fallback mapping results
        arivale_df: DataFrame containing Arivale metadata
        
    Returns:
        Updated DataFrame with integrated mapping results
    """
    logger.info("Integrating UniProt fallback mapping results")
    
    # Create a copy of the original dataframe
    updated_df = phase1_df.copy()
    
    # Create an index of the phase1 dataframe based on the unique identifier
    # Assuming 'source_ukbb_assay_raw' is a unique identifier
    phase1_index = {row['source_ukbb_assay_raw']: i for i, row in updated_df.iterrows()}
    
    # Create Arivale index for lookups (name -> row)
    arivale_index = {row['name']: row for _, row in arivale_df.iterrows()}
    
    # Counter for successful mappings
    mapped_count = 0
    
    # Iterate through UniProt fallback results
    for _, row in uniprot_results_df.iterrows():
        ukbb_assay = row['ukbb_assay']
        derived_uniprot = row.get('derived_uniprot_ac')
        original_gene_name = row.get('ukbb_gene_name')
        arivale_id = row.get('mapped_arivale_id')
        mapping_confidence = row.get('confidence_score', 0.7)  # Default to 0.7 for fallback mapping
        mapping_details = row.get('mapping_details', {})
        
        # Skip if no derived UniProt or no mapped Arivale ID
        if pd.isna(derived_uniprot) or pd.isna(arivale_id):
            continue
            
        # Get the index in the original dataframe
        if ukbb_assay in phase1_index:
            idx = phase1_index[ukbb_assay]
            
            # Update the mapping information
            updated_df.at[idx, 'mapping_step_1_target_arivale_protein_id'] = arivale_id
            
            # Add Arivale metadata if available
            if arivale_id in arivale_index:
                arivale_data = arivale_index[arivale_id]
                updated_df.at[idx, 'mapping_step_1_target_arivale_uniprot_ac'] = arivale_data['uniprot']
                updated_df.at[idx, 'mapping_step_1_target_arivale_gene_symbol'] = arivale_data['gene_name']
                updated_df.at[idx, 'mapping_step_1_target_arivale_protein_name'] = arivale_data['gene_description']
            
            # Update mapping metadata
            updated_df.at[idx, 'mapping_method'] = "UniProt Fallback: UKBB Gene Name -> UniProt AC -> Arivale Protein ID"
            updated_df.at[idx, 'mapping_path_details_json'] = json.dumps({
                "step1": f"Derived UniProt AC {derived_uniprot} from gene name {original_gene_name} via UniProt ID Mapping API",
                "step2": f"Mapped derived UniProt AC to Arivale Protein ID {arivale_id}",
                "details": mapping_details
            })
            updated_df.at[idx, 'confidence_score'] = mapping_confidence
            updated_df.at[idx, 'hop_count'] = 2
            updated_df.at[idx, 'notes'] = "Successfully mapped via gene name -> UniProt AC -> Arivale ID using UniProt fallback"
            
            mapped_count += 1
    
    logger.info(f"Successfully integrated {mapped_count} mappings from UniProt fallback results")
    return updated_df

def main():
    # Ensure output directory exists
    Path(OUTPUT_DIR).mkdir(parents=True, exist_ok=True)
    Path("logs").mkdir(exist_ok=True)
    
    # Load phase1 intermediate results
    logger.info(f"Loading phase1 intermediate results from {PHASE1_INTERMEDIATE_FILE}")
    phase1_df = pd.read_csv(PHASE1_INTERMEDIATE_FILE, sep='\t')
    logger.info(f"Loaded {len(phase1_df)} entries from phase1 intermediate file")
    
    try:
        # Load UniProt fallback results if available
        logger.info(f"Attempting to load UniProt fallback results from {UNIPROT_FALLBACK_RESULTS_FILE}")
        uniprot_results_df = pd.read_csv(UNIPROT_FALLBACK_RESULTS_FILE, sep='\t')
        logger.info(f"Loaded {len(uniprot_results_df)} entries from UniProt fallback results")
        
        # Load Arivale metadata
        arivale_df = load_arivale_metadata()
        
        # Integrate UniProt fallback results
        updated_df = integrate_uniprot_results(phase1_df, uniprot_results_df, arivale_df)
        
        # Save the updated results
        updated_df.to_csv(FINAL_OUTPUT_FILE, sep='\t', index=False)
        logger.info(f"Saved updated mapping results to {FINAL_OUTPUT_FILE}")
        
        # Calculate mapping statistics
        total_entries = len(updated_df)
        direct_mapped = len(updated_df[updated_df['mapping_method'] == 'Direct Primary: UKBB UniProt -> Arivale Protein ID via Arivale Metadata'])
        indirect_mapped = len(updated_df[updated_df['mapping_method'] == 'Indirect: UKBB Gene Name -> UniProt AC -> Arivale Protein ID'])
        uniprot_fallback_mapped = len(updated_df[updated_df['mapping_method'] == 'UniProt Fallback: UKBB Gene Name -> UniProt AC -> Arivale Protein ID'])
        total_mapped = direct_mapped + indirect_mapped + uniprot_fallback_mapped
        mapping_percentage = round((total_mapped / total_entries) * 100, 2)
        
        logger.info(f"Mapping Summary:")
        logger.info(f"  Total UKBB Entries: {total_entries}")
        logger.info(f"  Direct Mapped: {direct_mapped} ({round((direct_mapped / total_entries) * 100, 2)}%)")
        logger.info(f"  Indirect Mapped: {indirect_mapped} ({round((indirect_mapped / total_entries) * 100, 2)}%)")
        logger.info(f"  UniProt Fallback Mapped: {uniprot_fallback_mapped} ({round((uniprot_fallback_mapped / total_entries) * 100, 2)}%)")
        logger.info(f"  Total Mapped: {total_mapped} ({mapping_percentage}%)")
        logger.info(f"  Unmapped: {total_entries - total_mapped} ({round(100 - mapping_percentage, 2)}%)")
        
    except FileNotFoundError:
        logger.warning(f"UniProt fallback results file not found at {UNIPROT_FALLBACK_RESULTS_FILE}")
        logger.info("Creating placeholder for UniProt fallback schema")
        
        # Create a placeholder schema for the UniProt fallback results
        schema_df = pd.DataFrame({
            'ukbb_assay': ['GENE1', 'GENE2'],
            'ukbb_gene_name': ['GENE1', 'GENE2'],
            'derived_uniprot_ac': ['P12345', 'Q67890'],
            'mapped_arivale_id': ['ONC2_P12345', 'NEU1_Q67890'],
            'confidence_score': [0.8, 0.75],
            'mapping_details': [
                json.dumps({"method": "UniProt ID Mapping API", "query_type": "gene_name"}),
                json.dumps({"method": "UniProt ID Mapping API", "query_type": "gene_name"})
            ]
        })
        
        # Save the schema to a file for reference
        schema_file = os.path.join(OUTPUT_DIR, "uniprot_fallback_schema.tsv")
        schema_df.to_csv(schema_file, sep='\t', index=False)
        logger.info(f"Saved UniProt fallback schema template to {schema_file}")
        logger.info("Please provide the actual UniProt fallback results file when available")

if __name__ == "__main__":
    main()