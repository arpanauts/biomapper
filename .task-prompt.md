# Task: Resolve RefMetClient Failures

## Context:
Numerous tests in `tests/mapping/clients/test_refmet_client.py` are failing with `AssertionError`. These failures suggest issues with the `RefMetClient`'s ability to correctly parse responses from the RefMet service, handle various data scenarios (empty responses, malformed data, API errors), transform data, or manage its internal state during these operations.

## Objective:
Debug and fix the `RefMetClient` to ensure it robustly handles API interactions, correctly processes data, and behaves as expected under various conditions tested.

## Affected Tests & Errors:
All failures are `AssertionError`s in `tests/mapping/clients/test_refmet_client.py`:

- `test_successful_search`
- `test_empty_response`
- `test_malformed_response`
- `test_name_cleaning`
- `test_pandas_error_handling`
- `test_request_exception`
- `test_empty_dataframe`
- `test_retry_mechanism`
- `test_http_error`
- `test_search_compounds_error`
- `test_search_by_name[glucose-Input name\tRefMet_ID\tStandardized name\tFormula\tExact mass\tINCHI_KEY\tPubChem_CID\tChEBI_ID\tHMDB_ID\tKEGG_ID\nglucose\tRM0135901\tGlucose\tC6H12O6\t180.0634\tWQZGKKKJIJFFOK-GASJEMHNSA-N\t5793\t4167\tHMDB0000122\tC00031\n-expected_result0]`
- `test_search_by_name_request_error`
- `test_search_by_name_complex_terms`

## Tasks:
1.  **Systematically Review Each Failing Test:** For each test listed above:
    *   Understand what specific scenario or functionality the test is targeting.
    *   Examine the `RefMetClient` code relevant to that test.
    *   Identify why the assertion is failing (e.g., incorrect data parsing, improper error handling, flawed data transformation logic).
2.  **Focus Areas for `RefMetClient` Debugging:**
    *   **API Response Parsing:** How does the client handle JSON or other formats from RefMet? Are all expected fields correctly extracted?
    *   **Data Cleaning/Standardization:** Is the `test_name_cleaning` failure indicative of broader issues in how client data is processed?
    *   **Error Handling:** How does the client manage HTTP errors, request exceptions, or unexpected API responses (empty, malformed)?
    *   **Pandas Integration:** If Pandas is used, are DataFrames created and manipulated correctly? How are Pandas-specific errors handled?
    *   **Retry Logic:** Is the retry mechanism functioning as intended?
    *   **Edge Cases:** Pay attention to tests covering empty or malformed responses, as these often reveal robustness issues.
3.  **Implement Fixes:** Correct the identified issues in `RefMetClient`.

## Expected Outcome:
All tests in `tests/mapping/clients/test_refmet_client.py` should pass, demonstrating that `RefMetClient` is reliable and handles various scenarios correctly.
# Task 2: Create `StrategyExecutionService`
# Task: Resolve MVP0 Pipeline Errors

## Context:
Tests for the MVP0 pipeline components, specifically `PipelineOrchestrator` and `QdrantSearch`, are failing with `AssertionError`, `AttributeError`, and `pydantic_core._pydantic_core.ValidationError`. These errors point to issues in the orchestration logic, data flow, Pydantic model validation for search results, and interaction with the Qdrant client.

## Objective:
Debug and fix the errors in `PipelineOrchestrator` and `QdrantSearch` to ensure the MVP0 pipeline components function correctly, data is validated, and interactions with services like Qdrant are robust.

## Affected Tests & Errors:

**`tests/mvp0_pipeline/test_pipeline_orchestrator.py`**
- `TestPipelineOrchestrator::test_run_single_mapping_no_qdrant_hits` - `AssertionError: assert None == []`
- `TestPipelineOrchestrator::test_run_pipeline_batch` - `assert 1 == 0`
- `TestPipelineOrchestrator::test_create_orchestrator_from_env` - `AttributeError: <module 'biomapper.mvp0_pipeline.pipeline_orchestrator' ...>`
- `TestPipelineIntegration::test_data_flow_between_components` - `AssertionError: assert <PipelineStat...NT_ERROR_LLM'> == <PipelineStat...SS: 'SUCCESS'>`

**`tests/mvp0_pipeline/test_qdrant_search.py`**
- `TestQdrantSearch::test_search_successful_with_scores` - `pydantic_core._pydantic_core.ValidationError: 1 validation error for MappingOutput`
- `TestQdrantSearch::test_search_with_top_k_limit` - `pydantic_core._pydantic_core.ValidationError: 1 validation error for MappingOutput`
- `TestQdrantSearch::test_search_empty_input` - `AssertionError: Expected 'map_identifiers' to not have been called. Called 1 times.`
- `TestQdrantSearch::test_search_no_results` - `pydantic_core._pydantic_core.ValidationError: 1 validation error for MappingOutput`
- `TestQdrantSearch::test_search_with_scores_mismatch` - `pydantic_core._pydantic_core.ValidationError: 1 validation error for MappingOutput`
- `TestQdrantSearch::test_search_invalid_pubchem_id` - `pydantic_core._pydantic_core.ValidationError: 1 validation error for MappingOutput`
- `TestQdrantSearch::test_search_with_default_client` - `AttributeError: <module 'biomapper.mvp0_pipeline.qdrant_search' ...>`

## Tasks:

1.  **`PipelineOrchestrator` (`test_pipeline_orchestrator.py`):**
    *   **AssertionErrors (`test_run_single_mapping_no_qdrant_hits`, `test_run_pipeline_batch`, `test_data_flow_between_components`):**
        *   Review the orchestrator's logic for running mappings, batch processing, and managing pipeline state/status. Ensure expected return values and state transitions are correct.
    *   **AttributeError (`test_create_orchestrator_from_env`):**
        *   Investigate how the orchestrator is created from environment variables. The error suggests a module-level attribute is missing or named incorrectly.

2.  **`QdrantSearch` (`test_qdrant_search.py`):**
    *   **Pydantic ValidationErrors (multiple tests):**
        *   Review the `MappingOutput` Pydantic model (or any other relevant models).
        *   Inspect the data being returned from Qdrant searches that's failing validation. Ensure the data structure matches the model or update the model if necessary.
    *   **AssertionError (`test_search_empty_input`):**
        *   Verify the logic for handling empty input lists. The `map_identifiers` method should likely not be called if there's no input.
    *   **AttributeError (`test_search_with_default_client`):**
        *   Check how the default Qdrant client is instantiated or accessed within `QdrantSearch`. The error indicates a missing attribute on the `qdrant_search` module itself.

## Expected Outcome:
All listed tests for the MVP0 pipeline components should pass, demonstrating correct orchestration, data validation, and Qdrant client interaction.
# Task: Resolve ArangoDB and SPOKE Integration Errors

## Context:
Tests related to ArangoDB (`tests/mapping/arango/test_arango_store.py`) and SPOKE (`tests/spoke/test_graph_analyzer.py`) are failing. These errors include Pydantic validation errors, assertion failures in data retrieval, and attribute errors when accessing graph properties. This indicates potential issues in data modeling, query logic, or interaction with these graph databases/stores.

## Objective:
Debug and fix the issues in the ArangoDB store integration and SPOKE graph analysis components to ensure correct data validation, retrieval, and graph structure interpretation.

## Affected Tests & Errors:

**`tests/mapping/arango/test_arango_store.py`**
- `test_get_node` - `pydantic_core._pydantic_core.ValidationError: 1 validation error for ArangoNode`
- `test_get_node_by_property` - `pydantic_core._pydantic_core.ValidationError: 3 validation errors for ArangoNode`
- `test_get_neighbors` - `assert 0 > 0`
- `test_find_paths` - `assert 0 > 0`
- `test_get_types` - `AssertionError: assert 'Compound' in set()`

**`tests/spoke/test_graph_analyzer.py`**
- `test_discover_node_types_spoke_style` - `AttributeError: 'NoneType' object has no attribute 'collections'`
- `test_discover_relationship_types` - `AttributeError: 'NoneType' object has no attribute 'collections'`

## Tasks:

1.  **ArangoDB Store (`test_arango_store.py`):**
    *   **Pydantic Validation Errors (`test_get_node`, `test_get_node_by_property`):**
        *   Review the `ArangoNode` Pydantic model.
        *   Inspect the data being returned from ArangoDB that's failing validation. Ensure the data structure matches the model or update the model if it's incorrect/outdated.
    *   **Assertion Failures (`test_get_neighbors`, `test_find_paths`):**
        *   Examine the queries used to fetch neighbors and find paths. Ensure they are correctly formulated for the ArangoDB instance and test data.
        *   Verify that the test data in ArangoDB is set up to produce the expected results (e.g., >0 neighbors/paths).
    *   **Type Discovery (`test_get_types`):**
        *   Investigate how node types are retrieved or inferred. Ensure the logic correctly identifies 'Compound' nodes from the test data.

2.  **SPOKE Graph Analyzer (`test_graph_analyzer.py`):**
    *   **AttributeErrors (`test_discover_node_types_spoke_style`, `test_discover_relationship_types`):**
        *   The error `'NoneType' object has no attribute 'collections'` suggests that an object expected to be an ArangoDB database instance (or similar object providing access to collections) is `None`.
        *   Trace how the database/graph connection is established and passed to the graph analyzer functions. Ensure it's being initialized and provided correctly in the test setup or the analyzer's instantiation.

## Expected Outcome:
All listed tests for ArangoDB and SPOKE integration should pass, indicating correct Pydantic model validation, data retrieval from ArangoDB, and proper interaction with the SPOKE graph structure.
# Task 4: Create `DatabaseSetupService`
# Task: Resolve MetricsTracker Initialization Errors

## Context:
A significant number of tests are failing with `TypeError: MetricsTracker.__init__() got an unexpected keyword argument 'enable_metrics'`. This suggests a recent change in the `MetricsTracker` class's constructor or how it's being instantiated across the codebase.

## Objective:
Identify the cause of the `TypeError` related to `MetricsTracker` and correct all instances where it's being called or defined incorrectly.

## Affected Tests:
The following tests are failing with this specific error. Investigate the `MetricsTracker` instantiation in these test setups or the code they exercise:

- `tests/test_yaml_strategy_provenance.py::TestYAMLStrategyProvenanceTracking::test_trace_mapping_chain_simple`
- `tests/core/test_bidirectional_mapping_optimization.py::TestBidirectionalMappingOptimization::test_path_caching`
- `tests/core/test_bidirectional_mapping_optimization.py::TestBidirectionalMappingOptimization::test_concurrent_batch_processing`
- `tests/core/test_bidirectional_mapping_optimization.py::TestBidirectionalMappingOptimization::test_metrics_tracking`
- `tests/core/test_bidirectional_mapping_optimization.py::TestIntegrationOptimizedBidirectionalMapping::test_end_to_end_mapping`
- `tests/integration/test_yaml_strategy_ukbb_hpa.py::test_full_yaml_strategy_workflow`
- `tests/mapping/test_reverse_mapping.py::test_reverse_mapping`
- `tests/unit/core/test_mapping_executor_robust_features.py::TestCheckpointing::test_checkpoint_directory_creation`
- `tests/core/test_mapping_executor_metadata.py::test_metadata_in_cache_results`
- `tests/core/test_metadata_population.py::test_cache_results_populates_metadata_fields`
- `tests/core/test_metadata_population.py::test_confidence_score_calculation`
- `tests/core/test_metadata_population.py::test_mapping_path_details_contents`
- `tests/core/test_metadata_population.py::test_cache_results_handles_errors`
- `tests/integration/test_historical_id_mapping.py::TestHistoricalIDMapping::test_mapping_with_historical_resolution`
- `tests/integration/test_historical_id_mapping.py::TestHistoricalIDMapping::test_path_selection_order`
- `tests/integration/test_historical_id_mapping.py::TestHistoricalIDMapping::test_cache_usage`
- `tests/integration/test_historical_id_mapping.py::TestHistoricalIDMapping::test_error_handling`
- `tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_basic_linear_strategy`
- `tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_strategy_with_execute_mapping_path`
- `tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_strategy_with_filter_action`
- `tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_mixed_action_strategy`
- `tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_strategy_not_found`
- `tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_empty_initial_identifiers`
- `tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_step_failure_handling`
- `tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_ontology_type_tracking`
- `tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_filter_with_conversion_path`
- `tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_strategy_with_conditional_branching`
- `tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_parallel_action_execution`
- `tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_all_optional_strategy`
- `tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_mixed_required_optional_strategy`
- `tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_optional_fail_first_strategy`
- `tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_optional_fail_last_strategy`
- `tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_multiple_optional_failures_strategy`
- `tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_required_fail_after_optional_strategy`
- `tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_all_optional_fail_strategy`
- `tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_required_step_explicit_true`
- `tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_mapping_result_bundle_tracking`
- `tests/integration/test_yaml_strategy_ukbb_hpa.py::TestUKBBToHPAYAMLStrategy::test_strategy_loaded_in_database`
- `tests/integration/test_yaml_strategy_ukbb_hpa.py::TestUKBBToHPAYAMLStrategy::test_execute_yaml_strategy_basic`
- `tests/integration/test_yaml_strategy_ukbb_hpa.py::TestUKBBToHPAYAMLStrategy::test_execute_yaml_strategy_with_invalid_strategy`
- `tests/integration/test_yaml_strategy_ukbb_hpa.py::TestUKBBToHPAYAMLStrategy::test_execute_yaml_strategy_with_progress_callback`
- `tests/integration/test_yaml_strategy_ukbb_hpa.py::TestUKBBToHPAYAMLStrategy::test_action_handlers_placeholder_behavior`

## Tasks:
1.  Review the `MetricsTracker` class definition, specifically its `__init__` method.
2.  Identify if the `enable_metrics` parameter was recently added, removed, or renamed.
3.  Update all instantiation points of `MetricsTracker` (both in application code and test code) to match the correct constructor signature.
4.  Ensure that the logic related to `enable_metrics` (if it's a valid parameter) is handled correctly within `MetricsTracker`.

## Expected Outcome:
All listed tests should pass, and the `TypeError` related to `MetricsTracker` initialization should be resolved globally.
# Task 3: Refactor `MappingExecutor` to a Lean Facade

## Objective
Extract the high-level logic for executing YAML-defined mapping strategies from `MappingExecutor` into a dedicated `StrategyExecutionService`. This service will be the primary entry point for running complex, multi-step mapping workflows.

## Rationale
Strategy execution is a distinct and complex workflow that involves orchestration, robust execution (retries, checkpointing), and progress tracking. Separating this into its own service clarifies its role, decouples it from simpler path execution, and makes `MappingExecutor` a cleaner facade.

## New Component Location
- Create a new file: `biomapper/core/services/strategy_execution_service.py`
- Define the class: `StrategyExecutionService`

## Core Responsibilities of `StrategyExecutionService`
- Load and validate a mapping strategy by name.
- Orchestrate the execution of the strategy's steps using the `StrategyOrchestrator`.
- Coordinate robust execution, including checkpointing and retries, using the `RobustExecutionCoordinator`.
- Manage progress reporting for the entire strategy execution.

## Methods to Move/Refactor from `MappingExecutor`

The logic from the following `MappingExecutor` methods should be moved to `StrategyExecutionService`:

1.  `execute_strategy_by_name`: This will become the main public method of the new service.
2.  `execute_strategy`: This method contains the core orchestration logic and will be moved and likely made a private helper within the new service, called by the new `execute_strategy_by_name`.

## `StrategyExecutionService` `__init__`
The constructor should accept the components it depends on, which will be injected by `MappingExecutor`:

- `logger`
- `config_loader: ConfigLoader`
- `robust_execution_coordinator: RobustExecutionCoordinator`
- `session_manager: SessionManager`
- `identifier_loader: IdentifierLoader`
- `progress_reporter: ProgressReporter`

## Refactoring Steps
1.  **Create the File and Class:** Create `biomapper/core/services/strategy_execution_service.py` and define the `StrategyExecutionService` class.
2.  **Define `__init__`:** Implement the constructor to accept its dependencies.
3.  **Move and Adapt Methods:**
    - Move the entire `execute_strategy_by_name` and `execute_strategy` methods from `MappingExecutor` to `StrategyExecutionService`.
    - Refactor the methods to work in the new class. Update `self.` references to access dependencies passed into the service's constructor.
    - The main public method should be `async def execute(...)` or similar, which takes the `strategy_name`, `input_identifiers`, etc.
4.  **Update `MappingExecutor`:**
    - In `MappingExecutor`, remove the `execute_strategy_by_name` and `execute_strategy` methods.
    - Instantiate `StrategyExecutionService` in `MappingExecutor.__init__` and store it as `self.strategy_execution_service`.
    - Add a new public method to `MappingExecutor` named `execute_strategy` which simply delegates the call to `self.strategy_execution_service.execute(...)`.
Extract the database schema initialization logic from `MappingExecutor` into a new, single-purpose `DatabaseSetupService`. This service will be responsible for creating database tables, ensuring a clean separation between application runtime and database management/setup tasks.

## Rationale
Database schema creation is a setup concern, not a runtime execution concern. Mixing it into `MappingExecutor` complicates the class and violates the Single Responsibility Principle. A dedicated service makes the setup process explicit and reusable, and it can be invoked independently of the main application logic if needed (e.g., in deployment scripts or standalone setup tools).

## New Component Location
- Create a new file: `biomapper/core/services/database_setup_service.py`
- Define the class: `DatabaseSetupService`

## Core Responsibilities of `DatabaseSetupService`
- Connect to a database using a provided engine.
- Check if the required tables already exist.
- Create all tables defined in a given SQLAlchemy `Base` metadata object if they do not exist.

## Methods to Move/Refactor from `MappingExecutor`

The following method should be moved from `MappingExecutor` to `DatabaseSetupService`:

1.  `_init_db_tables`: This method contains the entire logic for checking for and creating tables. It will become the primary method of the new service.

## `DatabaseSetupService` `__init__`
The constructor can be simple, primarily accepting a logger:
- `logger`

## Refactoring Steps
1.  **Create the File and Class:** Create `biomapper/core/services/database_setup_service.py` and define the `DatabaseSetupService` class.
2.  **Move `_init_db_tables`:**
    - Move the `_init_db_tables` method from `MappingExecutor` to `DatabaseSetupService`.
    - Rename it to something more public, like `async def initialize_tables(self, engine, base_metadata)`. Make it a public method of the service.
3.  **Update `MappingExecutor.create`:**
    - In the `MappingExecutor.create` class method, instantiate the new `DatabaseSetupService`.
    - Instead of calling `await executor._init_db_tables(...)` for both the metamapper and cache databases, you will now call:
      ```python
      db_setup_service = DatabaseSetupService(logger=executor.logger)
      await db_setup_service.initialize_tables(executor.async_metamapper_engine, MetamapperBase.metadata)
      await db_setup_service.initialize_tables(executor.async_cache_engine, CacheBase.metadata)
      ```
    - (Note: You'll need to ensure `MetamapperBase` is imported or accessible).
4.  **Remove from `MappingExecutor`:** Delete the `_init_db_tables` method from the `MappingExecutor` class.
With the core logic now extracted into `MappingPathExecutionService` and `StrategyExecutionService`, refactor the `MappingExecutor` class to serve as a lean, clean facade. Its primary responsibilities will be initialization of components and delegation of tasks to the appropriate services.

## Rationale
This final step in the deconstruction completes the separation of concerns. A lean `MappingExecutor` is easier to understand, as its public API clearly shows the main capabilities of the system (e.g., `map`, `execute_strategy`) without exposing the complex implementation details, which now reside in the specialized services.

## Refactoring Steps

1.  **Review `MappingExecutor.__init__`:**
    - The initializer should now be primarily responsible for instantiating all the engine components and services:
        - `SessionManager`, `ClientManager`, `CacheManager`, etc.
        - The new `MappingPathExecutionService` and `StrategyExecutionService`.
    - Pass the necessary dependencies into the constructors of the new services.
    - Remove any attributes from `self` that are no longer directly used by `MappingExecutor` itself (e.g., if a component is only used by one of the new services, it might not need to be an attribute of `MappingExecutor`).

2.  **Simplify the Public API:**
    - The main public methods of `MappingExecutor` should be high-level entry points. Review and refine:
        - `execute_mapping`: This method should now use `self.path_finder` to find a path and then delegate the execution to `self.path_execution_service`.
        - `execute_strategy`: This method should be a simple pass-through to `self.strategy_execution_service`.
        - `map`: This should be the primary, user-friendly method. It might internally decide whether to call `execute_mapping` or `execute_strategy` based on its arguments.

3.  **Remove Redundant/Pass-Through Methods:**
    - `MappingExecutor` currently has several private methods that are simple pass-through calls to `PathFinder` (e.g., `_find_mapping_paths`, `_find_best_path`) or `MetadataQueryService`.
    - These should be removed from `MappingExecutor`. Components or services that need this functionality should be given a direct dependency on `PathFinder` or `MetadataQueryService` instead of going through `MappingExecutor`.

4.  **Update `MappingExecutor.create` Factory:**
    - Ensure the asynchronous factory method `create` correctly initializes the simplified `MappingExecutor` and all its dependent services.
    - The call to `_init_db_tables` should be replaced by a call to the new `DatabaseSetupService` (from Prompt 4).

## Acceptance Criteria
- The new `StrategyExecutionService` is created and contains the complete logic for executing a YAML-defined mapping strategy.
- `MappingExecutor` no longer contains strategy execution logic; it delegates calls to the new service.
- All existing integration tests for strategy execution are updated to call the new `MappingExecutor.execute_strategy` method and continue to pass, verifying the refactoring was successful.
- New unit tests for `StrategyExecutionService` should be created to test its logic in isolation.
- The new `DatabaseSetupService` is created and contains the logic for initializing database schemas.
- The `_init_db_tables` method is completely removed from `MappingExecutor`.
- The `MappingExecutor.create` factory method successfully uses the new `DatabaseSetupService` to set up the databases upon instantiation.
- The application continues to start up correctly, and tests that rely on database setup still pass, confirming that the tables are being created as expected.
- `MappingExecutor` is significantly shorter and simpler. Its `__init__` method is focused on dependency injection.
- The public API of `MappingExecutor` is clean and delegates all heavy lifting to the appropriate services (`MappingPathExecutionService`, `StrategyExecutionService`).
- Redundant private helper and pass-through methods have been removed.
- All dependent components are correctly initialized and wired together.
- High-level integration tests continue to pass, demonstrating that the facade correctly orchestrates the underlying services.
