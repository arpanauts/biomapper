# Task: Create Unit Tests for `MappingResultBundle`

## Objective
To validate the correctness of our primary result-tracking object, create unit tests for the `MappingResultBundle` class.

## Location for Tests
Create a new test file: `tests/core/models/test_result_bundle.py`

## Test Cases

1.  **Test Initialization**: Instantiate a `MappingResultBundle` and assert that all its initial properties (e.g., `strategy_name`, `initial_identifiers`, `execution_status`, `start_time`) are set correctly.
2.  **Test `add_step_result` for Success**: Add a successful step result. Assert that:
    *   The `step_results` and `provenance` lists are updated.
    *   The `completed_steps` count is incremented.
    *   `current_identifiers` and `current_ontology_type` are updated correctly.
3.  **Test `add_step_result` for Failure**: Add a failed step result. Assert that the `failed_steps` count is incremented.
4.  **Test `finalize` on Success**: Call `finalize()` with a 'completed' status. Assert that `execution_status` and `end_time` are set correctly.
5.  **Test `finalize` on Failure**: Call `finalize()` with a 'failed' status and an error message. Assert that `execution_status` and `error` are set correctly.
6.  **Test `to_dict` Method**: Call `to_dict()` on a finalized result bundle and assert that the resulting dictionary contains the correct keys and values, including a calculated `duration_seconds`.

## Acceptance Criteria
*   A new test file `tests/core/models/test_result_bundle.py` is created.
*   The tests cover all public methods of the `MappingResultBundle` class.
*   All tests pass successfully.
# Task: Centralize Database Session Management in a `SessionManager`

## Objective
To improve database connection management and adhere to the single responsibility principle, extract all SQLAlchemy session creation logic from `MappingExecutor` into a dedicated `SessionManager` class.

## Current Implementation
The `MappingExecutor` currently contains several methods for creating and managing database sessions, such as `_get_session`, `_get_async_session`, and the sessionmaker setup in the `__init__` method. This mixes database concerns with orchestration logic.

## Refactoring Steps

1.  **Create the `SessionManager` Class:**
    *   Create a new file: `biomapper/core/engine_components/session_manager.py`.
    *   Define a `SessionManager` class.
    *   The `__init__` method should take the database URLs (`metamapper_db_url`, `mapping_cache_db_url`) and `echo_sql` flag.
    *   Move all engine creation (`create_engine`, `create_async_engine`) and sessionmaker configuration logic from `MappingExecutor.__init__` into the `SessionManager.__init__`.
    *   Move the `_get_session` and `_get_async_session` methods from `MappingExecutor` into the `SessionManager`, making them public methods (`get_session`, `get_async_session`).

2.  **Update `MappingExecutor`:**
    *   In `biomapper/core/mapping_executor.py`, remove the `_get_session` and `_get_async_session` methods.
    *   In `MappingExecutor.__init__`, remove all the engine and sessionmaker setup logic.
    *   Instantiate the `SessionManager` in `MappingExecutor.__init__`:
        ```python
        self.session_manager = SessionManager(
            metamapper_db_url=self.metamapper_db_url,
            mapping_cache_db_url=self.mapping_cache_db_url,
            echo_sql=echo_sql
        )
        ```
    *   Update all calls from `self._get_session()` to `self.session_manager.get_session()` and `self._get_async_session()` to `self.session_manager.get_async_session()`.
    *   Add the necessary import: `from .engine_components.session_manager import SessionManager`.
# Task: Refactor Progress Reporting into a Dedicated `ProgressReporter` Component

## Objective
To further modularize the `MappingExecutor`, extract the progress reporting logic into a dedicated `ProgressReporter` class. This will improve separation of concerns by isolating the mechanism for reporting progress from the core mapping orchestration logic.

## Current Implementation
The `MappingExecutor` currently has a private method `_report_progress` that handles sending progress updates. This logic is tightly coupled with the executor's implementation.

## Refactoring Steps

1.  **Create the `ProgressReporter` Class:**
    *   Create a new file: `biomapper/core/engine_components/progress_reporter.py`.
    *   Inside this file, define a `ProgressReporter` class.
    *   The class should have an `__init__` method that accepts an optional `progress_callback` function.
    *   Create a public method `report(self, progress_data: dict)` that will contain the logic from the current `_report_progress` method.

2.  **Update `MappingExecutor`:**
    *   In `biomapper/core/mapping_executor.py`, remove the `_report_progress` method.
    *   In the `MappingExecutor.__init__` method, instantiate the new `ProgressReporter`:
        ```python
        self.progress_reporter = ProgressReporter(progress_callback=self.progress_callback)
        ```
    *   Update all calls from `self._report_progress(...)` to `self.progress_reporter.report(...)` throughout the `MappingExecutor` class.
    *   Add the necessary import: `from .engine_components.progress_reporter import ProgressReporter`.
# Task: Create a Dedicated `IdentifierLoader` for Endpoint Data

## Objective
To better separate concerns, extract the logic for loading identifiers from data endpoints into a new, dedicated `IdentifierLoader` class. This will decouple the `MappingExecutor` from the specifics of data loading.

## Current Implementation
The `MappingExecutor` has a public method `load_endpoint_identifiers` that contains logic to connect to a database, query an endpoint table, and return a list of identifiers. 

## Refactoring Steps

1.  **Create the `IdentifierLoader` Class:**
    *   Create a new file: `biomapper/core/engine_components/identifier_loader.py`.
    *   Define an `IdentifierLoader` class.
    *   The `__init__` method should accept a `session_manager` instance to handle database connections.
    *   Move the `load_endpoint_identifiers` method from `MappingExecutor` into the `IdentifierLoader` class. The method signature should be similar.

2.  **Update `MappingExecutor`:**
    *   In `biomapper/core/mapping_executor.py`, remove the `load_endpoint_identifiers` method.
    *   In `MappingExecutor.__init__`, instantiate the `IdentifierLoader`:
        ```python
        # Assuming self.session_manager is already created
        self.identifier_loader = IdentifierLoader(session_manager=self.session_manager)
        ```
    *   Create a new public method `load_endpoint_identifiers` on `MappingExecutor` that simply acts as a pass-through to the `IdentifierLoader` instance:
        ```python
        def load_endpoint_identifiers(self, endpoint_name: str, identifier_column: Optional[str] = None) -> List[str]:
            return self.identifier_loader.load_endpoint_identifiers(endpoint_name, identifier_column)
        ```
    *   Add the necessary import: `from .engine_components.identifier_loader import IdentifierLoader`.
# Task: Extract Strategy Configuration Loading into a `ConfigLoader` Component

## Objective
To improve the modularity of the `MappingExecutor`, extract the logic for loading and parsing mapping strategy YAML files into a dedicated `ConfigLoader` class. This will centralize configuration management and simplify the executor.

## Current Implementation
The `MappingExecutor` currently has a method `get_strategy` that reads a YAML file, parses it, and returns the strategy configuration. This logic is directly embedded within the executor.

## Refactoring Steps

1.  **Create the `ConfigLoader` Class:**
    *   Create a new file: `biomapper/core/engine_components/config_loader.py`.
    *   Define a `ConfigLoader` class in this file.
    *   Move the logic from `MappingExecutor.get_strategy` into a new method within `ConfigLoader`, for example, `load_strategy(self, strategy_name: str, strategies_config_path: str) -> dict`.
    *   The `ConfigLoader` should handle file reading, YAML parsing, and basic validation.

2.  **Update `MappingExecutor`:**
    *   In `biomapper/core/mapping_executor.py`, remove the `get_strategy` method.
    *   In the `MappingExecutor.__init__` method, create an instance of the new `ConfigLoader`:
        ```python
        self.config_loader = ConfigLoader()
        ```
    *   In the `execute_strategy` method, replace the call to `self.get_strategy(...)` with `self.config_loader.load_strategy(...)`.
    *   Add the required import: `from .engine_components.config_loader import ConfigLoader`.

## Acceptance Criteria
*   A `SessionManager` class is implemented in `biomapper/core/engine_components/session_manager.py`.
*   All database session and engine creation logic is removed from `MappingExecutor`.
*   `MappingExecutor` uses an instance of `SessionManager` to obtain database sessions.
*   The application's database interactions function as before.
## Acceptance Criteria
*   The `ProgressReporter` class is implemented in `biomapper/core/engine_components/progress_reporter.py`.
*   The `_report_progress` method is removed from `MappingExecutor`.
*   `MappingExecutor` uses an instance of `ProgressReporter` for all progress reporting.
*   The application's functionality remains unchanged.
## Acceptance Criteria
*   An `IdentifierLoader` class is implemented in `biomapper/core/engine_components/identifier_loader.py`.
*   The core logic of `load_endpoint_identifiers` is moved out of `MappingExecutor`.
*   `MappingExecutor` delegates the call to its `IdentifierLoader` instance.
*   The ability to load identifiers from an endpoint remains fully functional.
## Acceptance Criteria
*   The `ConfigLoader` class is implemented in `biomapper/core/engine_components/config_loader.py`.
*   The `get_strategy` method is removed from `MappingExecutor`.
*   `MappingExecutor` uses an instance of `ConfigLoader` to load strategy configurations.
*   The application's functionality remains unchanged.
