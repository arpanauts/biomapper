# Task: Refactor `MappingExecutor` by Extracting Handler Methods into a `MappingHandlerService`
# Task 1: Refactor Core MappingExecutor Unit Tests
# Task 5: Review and Refactor PathFinder Service Tests
# Task 2: Refactor Bidirectional Mapping Optimization Tests

## 1. Objective

Continue the deep refactoring of the oversized `MappingExecutor` class by extracting its large, private `_handle_*` methods into a new, dedicated `MappingHandlerService`. The primary goal is to achieve a significant reduction in `MappingExecutor`'s line count (targeting a ~400-line reduction) and move it closer to being a pure facade that delegates all complex logic to specialized services.
Refactor the core unit tests for `MappingExecutor` that are currently failing or skipped due to the recent service-oriented architecture refactoring. The goal is to decouple these tests from the `MappingExecutor`'s internal implementation and instead test the new, focused service classes (`StrategyExecutionService`, `PathFinder`, `ConfigLoader`, etc.) directly or test `MappingExecutor` as a high-level orchestrator using dependency injection.
Review and refactor the unit tests for the `PathFinder` service, located in `/home/ubuntu/Software-Engineer-AI-Agent-Atlas/biomapper/tests/core/engine_components/test_path_finder.py`. The goal is to ensure the tests are robust, maintainable, and focused on the service's public contract, not its internal implementation details.
Refactor the tests within `/home/ubuntu/Software-Engineer-AI-Agent-Atlas/biomapper/tests/core/test_bidirectional_mapping_optimization.py`. These tests are currently skipped or failing because they are tightly coupled to the previous implementation of `MappingExecutor` and its internal methods.

## 2. Context and Background

The previous refactoring effort successfully extracted the main `execute_*` methods into separate services (`IterativeExecutionService`, `DbStrategyExecutionService`, `YamlStrategyExecutionService`). However, this only resulted in a 12% size reduction, falling short of the 50% target. Feedback analysis revealed that the bulk of the remaining logic resides in three large handler methods used by the YAML strategy executor:

-   `_handle_convert_identifiers_local` (~130 lines)
-   `_handle_execute_mapping_path` (~126 lines)
-   `_handle_filter_identifiers_by_target_presence` (~124 lines)

This task will address this by moving these methods into their own service, which will drastically simplify `MappingExecutor` and improve code modularity.
The `MappingExecutor` was recently refactored from a large, monolithic class into a lean orchestrator that delegates tasks to specialized service classes. This has broken numerous unit tests that were tightly coupled to its old internal methods (e.g., `_run_path_steps`, `_get_path_from_cache`). This task is to update these tests to reflect the new architecture, ensuring our test suite is robust and maintainable.
The previous test-fixing effort noted that `test_path_caching` was failing in other files because path caching is now an internal responsibility of the `PathFinder` service. This highlights the need to ensure that `PathFinder` itself has strong tests for this behavior. This task is a proactive measure to review the existing tests for `PathFinder` and improve them according to best practices.
The `test_bidirectional_mapping_optimization.py` file contains critical tests for complex logic, including path caching, concurrent processing, and metrics tracking. The recent refactoring of `MappingExecutor` into a service-oriented architecture has broken these tests. The feedback from the previous test-fixing task specifically called out `test_path_caching`, `test_concurrent_batch_processing`, and `test_metrics_tracking` as needing a complete rewrite.

## 3. Prerequisites

- The agent must be familiar with the ongoing service-oriented refactoring of the Biomapper project.
- The primary file to be modified is `/home/ubuntu/Software-Engineer-AI-Agent-Atlas/biomapper/biomapper/core/mapping_executor.py`.
- The agent must understand the new service-oriented architecture and the roles of classes like `StrategyExecutionService`, `PathFinder`, `IdentifierLoader`, and `ConfigLoader`.
- A clear understanding of the `PathFinder` service's role: to discover and cache paths between ontology types in the mapping graph.
- Strong knowledge of testing principles, especially testing behavior vs. implementation.
- The agent must have a deep understanding of the bidirectional mapping strategy and how it's orchestrated by the new services.
- Familiarity with `PathFinder` (for caching), `StrategyExecutionService` (for orchestration), and `MetricsService` (if applicable, or where metrics logic now resides) is essential.

## 4. Task Breakdown

1.  **Create `MappingHandlerService`**:
    - In the `biomapper/core/services/` directory, create a new file named `mapping_handler_service.py`.
    - Inside this file, define a new class `MappingHandlerService`.
    - The constructor (`__init__`) for this service must accept all necessary dependencies. Based on the logic within the handler methods, these will likely include:
        - `logger`
        - `client_manager`
        - `path_finder`
        - `async_metamapper_session`
        - `metadata_query_service`
        - `placeholder_resolver`

2.  **Migrate Handler Method Logic**:
    - Locate the methods `_handle_convert_identifiers_local`, `_handle_execute_mapping_path`, and `_handle_filter_identifiers_by_target_presence` in `mapping_executor.py`.
    - **Cut** the entire method bodies from `mapping_executor.py` and **paste** them into the new `MappingHandlerService` class.
    - Rename the methods to be public (e.g., `_handle_convert_identifiers_local` becomes `handle_convert_identifiers_local`).
    - Refactor the method bodies to use the dependencies injected into the service's `__init__` (e.g., `self.client_manager`) instead of assuming they exist on the `MappingExecutor` instance.
    - Adjust the method signatures to accept any parameters that were previously accessed via `self` in `MappingExecutor` but are not part of the service's dependencies. The `execution_context` dictionary is a critical parameter that will need to be passed into these methods.

3.  **Refactor `MappingExecutor`**:
    - In `MappingExecutor.__init__`, instantiate the new `MappingHandlerService`, injecting all its required dependencies.
        ```python
        self.mapping_handler_service = MappingHandlerService(
            logger=self.logger,
            client_manager=self.client_manager,
            # ... other dependencies
        )
        ```
    - Replace the original `_handle_*` method bodies in `MappingExecutor` with a single line that delegates the call to the new service. For example:
        ```python
        async def _handle_execute_mapping_path(self, step: Dict[str, Any], execution_context: Dict[str, Any]) -> Dict[str, Any]:
            return await self.mapping_handler_service.handle_execute_mapping_path(
                step=step, execution_context=execution_context
            )
        ```

4.  **Update `__init__.py`**:
    - Add `MappingHandlerService` to the `__all__` list in `biomapper/core/services/__init__.py` to ensure it is correctly exported.

5.  **Fix Failing Tests**:
    - The previous feedback noted test failures due to a missing `_find_direct_paths` method. This is a pre-existing issue that must be resolved.
    - Investigate the test suite (e.g., `tests/unit/core/test_mapping_executor.py`) to identify which tests are failing.
    - Determine the correct replacement for the `_find_direct_paths` call. The logic may now reside in `PathFinder` or `DirectMappingService`. Update the test to use the correct service and method.
For each of the files below, perform the following steps:

1.  **Analyze Existing Tests:** Identify why each test is failing. Most failures will be due to `AttributeError` for methods that no longer exist.
2.  **Determine the New Target:** Decide what the test *should* be testing in the new architecture. Is it testing logic now in `PathFinder`? Or `StrategyExecutionService`? Or is it a high-level integration test of `MappingExecutor`?
3.  **Rewrite the Test:**
    - If testing a service, write a new test file for that service (if one doesn't exist) or add to an existing one. Use mocking (`unittest.mock`) to isolate the service from its dependencies (e.g., database sessions, other services).
    - If testing `MappingExecutor`'s orchestration logic, mock the service-level dependencies that are passed into its constructor and assert that the correct service methods are called with the expected parameters.
4.  **Delete Old Test:** Once the logic is covered by a new, robust test, delete the old, failing test.

### Target Files:

- `/home/ubuntu/Software-Engineer-AI-Agent-Atlas/biomapper/tests/core/test_mapping_executor.py`
- `/home/ubuntu/Software-Engineer-AI-Agent-Atlas/biomapper/tests/core/test_mapping_executor_metadata.py`
- `/home/ubuntu/Software-Engineer-AI-Agent-Atlas/biomapper/tests/unit/core/test_mapping_executor_robust_features.py`
- `/home/ubuntu/Software-Engineer-AI-Agent-Atlas/biomapper/tests/unit/core/test_mapping_executor_utilities.py`
1.  **Review Existing Tests:** Read through all tests in `/home/ubuntu/Software-Engineer-AI-Agent-Atlas/biomapper/tests/core/engine_components/test_path_finder.py`.

2.  **Identify Tightly-Coupled Tests:** Look for tests that:
    - Mock internal, private methods of `PathFinder`.
    - Make assumptions about the internal data structures used for caching.
    - Are difficult to read or understand.

3.  **Refactor for Behavioral Testing:**
    - **Path Caching:** Ensure there is a clear behavioral test for caching. This test should *not* inspect the cache object directly. Instead, it should:
        a. Mock the database session dependency.
        b. Call `path_finder.find_path(...)` once.
        c. Assert that the database was called.
        d. Call `path_finder.find_path(...)` a second time with the *exact same parameters*.
        e. Assert that the database was **not** called the second time.
        f. Call `path_finder.find_path(...)` a third time with *different* parameters.
        g. Assert that the database **was** called the third time.
    - **Path Finding Logic:** Ensure tests cover various scenarios: direct paths, multi-step paths, no paths found, etc. These tests should focus on the input (source/target types) and the output (the returned path or lack thereof).

4.  **Improve Readability and Maintainability:**
    - Use clear and descriptive test names.
    - Add comments where the test logic is complex.
    - Refactor any convoluted test setups to be simpler.
1.  **Analyze `test_path_caching`:**
    - This test likely checked the internal cache of `MappingExecutor`. Path caching is now handled by `PathFinder`.
    - **Action:** Rewrite this test to target the `PathFinder` service directly. Mock its database dependency and verify that calling `find_path` multiple times with the same parameters results in a cache hit (i.e., the database is only queried once).

2.  **Analyze `test_concurrent_batch_processing`:**
    - This test likely used the old `_run_path_steps` method. Concurrent logic is now managed within services.
    - **Action:** Rewrite this test to target the relevant service (likely `StrategyExecutionService` or a batch processing service it uses). The test should verify that when given a large list of identifiers, the service correctly processes them in concurrent batches.

3.  **Analyze `test_metrics_tracking`:**
    - This test checked internal metrics counters in `MappingExecutor`.
    - **Action:** Determine where metrics logic now resides. It might be in a dedicated `MetricsService` or within the `execution_context` passed between strategy actions. Rewrite the test to verify that metrics (e.g., 'mapped_count', 'unmapped_count') are correctly tracked and reported after a mapping run.

4.  **Review and Refactor Other Tests:** Go through any other tests in the file and apply the same principles: identify the new location of the logic and rewrite the test to target the correct service, using mocking and dependency injection.

## 5. Implementation Requirements

- **Code Standards:** All new and modified code must be fully type-hinted and follow async/await patterns. Maintain the existing code style.
- **Dependencies:** Ensure all dependencies are correctly injected. Pay close attention to avoiding circular imports, which have been an issue in past refactorings.

## 6. Error Recovery Instructions

- **`AttributeError`:** If the new service methods fail because they are trying to access an attribute that wasn't passed in (e.g., `self.path_finder`), update the `MappingHandlerService` constructor and the instantiation in `MappingExecutor` to pass the required dependency.
- **Circular Imports:** If you encounter `ImportError: cannot import name ...`, use local, in-method imports as a last resort. The ideal solution is to refactor dependencies to break the cycle.
- **Code Standards:** Follow existing code style, use `pytest` conventions, and leverage `unittest.mock` for mocking. All new tests must be asynchronous (`async def`).
- **Dependency Injection:** Heavily rely on dependency injection to make tests clean and isolated.
- **Target File:** `/home/ubuntu/Software-Engineer-AI-Agent-Atlas/biomapper/tests/core/engine_components/test_path_finder.py`
- **Code Standards:** Use `pytest` and `unittest.mock`. All tests must be `async def`.
- **Principle:** Test the what, not the how. The tests should validate the public contract of `PathFinder` so that its internal implementation can be changed in the future without breaking the tests.

## 7. Validation and Success Criteria

- **Primary Validation:** The refactoring is successful when the entire test suite passes without errors.
- **Execution Command:** Run `poetry run pytest` from the project root (`/home/ubuntu/Software-Engineer-AI-Agent-Atlas/biomapper/`).
- **Code Metrics:** The `mapping_executor.py` file should be reduced in size by approximately 400 lines.
- **New Artifacts:** The new `mapping_handler_service.py` file should be created and contain the extracted logic.

## 8. Feedback and Reporting

- Provide the `diff` of the changes made to `mapping_executor.py`.
- Provide the full content of the new `mapping_handler_service.py` file.
- Provide the `diff` for any test files you modified.
- Confirm that you ran the validation command and that all tests passed successfully.
## 6. Validation and Success Criteria
## 6. Validation and Success Criteria

- **Success:** All tests in the modified files pass when run with `poetry run pytest [file_path]`.
- **Coverage:** The logical intent of the original tests is preserved in the new tests.
- **No Skipped Tests:** Do not use `pytest.mark.skip`. Either fix the test or delete it if it's no longer relevant.
- **Success:** All tests in the file pass and are demonstrably testing the public behavior of the service.
- **Improved Tests:** The caching test, in particular, is refactored to follow the behavioral pattern described above.
- **Target File:** `/home/ubuntu/Software-Engineer-AI-Agent-Atlas/biomapper/tests/core/test_bidirectional_mapping_optimization.py`
- **Code Standards:** Use `pytest` and `unittest.mock`. All tests must be `async def`.
- **Focus on Public APIs:** Tests should interact with the public methods of the service classes, not their internal, private methods.

## 7. Feedback and Reporting

- Provide a list of the old test files that were modified/deleted.
- Provide a list of the new test files that were created/modified.
- Confirm that all tests pass by providing the output of `pytest` for the relevant files.
## 6. Validation and Success Criteria

- **Success:** All tests in `/home/ubuntu/Software-Engineer-AI-Agent-Atlas/biomapper/tests/core/test_bidirectional_mapping_optimization.py` pass.
- **No Skipped Tests:** All `pytest.mark.skip` markers are removed from the file.
- **Clarity:** The new tests are clean, readable, and clearly state what behavior they are verifying.

## 7. Feedback and Reporting
## 7. Feedback and Reporting

- Provide the `diff` of the changes made to the test file.
- Specifically highlight the new behavioral test for path caching.
- Provide the `pytest` output for the file to confirm all tests pass.
- Provide the `diff` of the changes made to the target test file.
- Confirm that all tests in the file now pass by providing the `pytest` output.
