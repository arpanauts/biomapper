# Task: Create Unit Tests for `IdentifierLoader`
# Task: Create Unit Tests for `ConfigLoader`

## Objective
To validate the logic for loading identifiers from various data sources, create comprehensive unit tests for the `IdentifierLoader` component.
To ensure the reliability of the strategy configuration loading mechanism, create a suite of unit tests for the `ConfigLoader` component.

## Location for Tests
Create a new test file: `tests/core/engine_components/test_identifier_loader.py`
Create a new test file: `tests/core/engine_components/test_config_loader.py`

## Test Strategy
- Use `pytest` and `unittest.mock` with `AsyncMock` for async methods.
- Mock the `metamapper_session_factory` to return a mock `AsyncSession`.
- The mock `AsyncSession` should return mock SQLAlchemy models (`Endpoint`, `EndpointPropertyConfig`, `PropertyExtractionConfig`) when its `execute` method is called.
- Mock filesystem interactions (`os.path.exists`) and data loading (`pandas.read_csv`).
- Use `pytest` and `unittest.mock` for testing.
- Mock filesystem interactions (`open`, `os.path.exists`) to simulate the presence, absence, and content of YAML configuration files without needing real files.

## Test Cases

### `get_ontology_column`
1.  **Test Successful Lookup:** Mock the full chain of database objects and assert that the correct column name is returned from the mock `extraction_pattern`.
2.  **Test Endpoint Not Found:** Mock the session to return `None` for the `Endpoint` query. Assert a `ConfigurationError` is raised.
3.  **Test Property Config Not Found:** Mock the session to return `None` for the `EndpointPropertyConfig` query. Assert a `ConfigurationError` is raised.

### `load_endpoint_identifiers`
1.  **Test Successful Load (as List):** Mock a successful database and file lookup. Assert that a list of unique identifiers is returned.
2.  **Test Successful Load (as DataFrame):** Call with `return_dataframe=True` and assert that the mock DataFrame is returned.
3.  **Test File Not Found:** Mock `os.path.exists` to return `False`. Assert `FileNotFoundError` is raised.
4.  **Test Column Not Found:** Mock a DataFrame that is missing the required identifier column. Assert `KeyError` is raised.
5.  **Test Placeholder Resolution:** Verify that `resolve_placeholders` is called with the file path from the mock `Endpoint` configuration.

## Acceptance Criteria
- A new test file `tests/core/engine_components/test_identifier_loader.py` is created.
- The tests use async mocks to validate the asynchronous database logic.
- The tests cover all public methods and their primary success and failure modes.
- All tests pass successfully.
1.  **Test Successful Loading (.yaml):**
    - Mock a valid `strategy.yaml` file.
    - Call `load_strategy` and assert that the returned dictionary matches the mock file's content.

2.  **Test Successful Loading (.yml fallback):**
    - Mock `os.path.exists` to return `False` for `strategy.yaml` but `True` for `strategy.yml`.
    - Assert that `load_strategy` successfully loads from the `.yml` file.

3.  **Test Strategy Not Found:**
    - Mock `os.path.exists` to return `False` for both `.yaml` and `.yml` files.
    - Assert that `load_strategy` raises a `ConfigurationError`.

4.  **Test Malformed YAML:**
    - Mock the content of a YAML file to be invalid (e.g., incorrect indentation).
    - Assert that `load_strategy` catches the `yaml.YAMLError` and raises a `ConfigurationError`.

5.  **Test Invalid Config Format:**
    - Mock a YAML file whose root element is not a dictionary (e.g., a list).
    - Assert that `load_strategy` raises a `ConfigurationError`.

6.  **Test Name Injection:**
    - Mock a valid strategy config that is missing the top-level `name` key.
    - Call `load_strategy` and assert that the strategy name is correctly added to the resulting dictionary.

## Acceptance Criteria
- A new test file `tests/core/engine_components/test_config_loader.py` is created.
- The tests cover all public methods of the `ConfigLoader` class and its primary error conditions.
- All tests pass successfully.
