# Prompt: Create Unit Tests for the `MappingExecutor` Facade

## Goal
Create unit tests for the new, lean `MappingExecutor` facade. The tests should not test any underlying business logic, but instead verify that each public method of the facade correctly delegates its call to the appropriate mocked coordinator or service.

## Context
The `MappingExecutor` class (to be created in `biomapper/core/mapping_executor.py`) is being refactored into a pure facade. Its only job is to forward calls. This task is to create the tests that enforce this pattern and ensure the wiring is correct.

## Requirements

1.  **Create Test File:**
    -   Create a new file at `tests/unit/core/test_mapping_executor.py`.

2.  **Test Structure:**
    -   Use `pytest` and `unittest.mock`.
    -   In your test setup, create mock objects for each of the coordinators and services that the `MappingExecutor` will take in its constructor (`LifecycleCoordinator`, `MappingCoordinatorService`, `StrategyCoordinatorService`, etc.).
    -   Instantiate the `MappingExecutor` with these mocks.

3.  **Test Scenarios (one test per method):**
    -   For each public method in `MappingExecutor` (e.g., `execute_mapping`, `save_checkpoint`, `async_dispose`):
        -   Create a dedicated test function (e.g., `test_execute_mapping_delegates_correctly`).
        -   Call the method on the `MappingExecutor` instance with sample arguments.
        -   Assert that the corresponding method on the correct mock coordinator/service was called exactly once.
        -   Assert that it was called with the same arguments that were passed to the facade method.

    -   **Example for `execute_mapping`:**
        ```python
        def test_execute_mapping_delegates_to_mapping_coordinator(self):
            # Arrange
            source_name = "test_source"
            # ... other args

            # Act
            self.executor.execute_mapping(source_endpoint_name=source_name, ...)

            # Assert
            self.mock_mapping_coordinator.execute_mapping.assert_called_once_with(
                source_endpoint_name=source_name, ...
            )
        ```

4.  **Coverage:**
    -   Ensure every public, delegating method in the `MappingExecutor` facade has a corresponding test to verify its delegation.

## Files to Modify
-   **Create:** `tests/unit/core/test_mapping_executor.py`

## Success Criteria
-   The new test file is created.
-   Tests are written for all public methods of the `MappingExecutor` facade.
-   Each test successfully verifies that the method call is delegated to the correct underlying service with the correct parameters.
-   All tests pass when run with `pytest`.
# Prompt: Implement the `MappingExecutor` as a Pure Facade

## Goal
Create the `biomapper/core/mapping_executor.py` file, defining the `MappingExecutor` class as a pure facade. This class should delegate all its operational logic to specialized coordinator services, and its constructor should be extremely lean.

## Context
The `InitializationService` is responsible for creating all low-level components, and the `MappingExecutorBuilder` is responsible for assembling them into high-level coordinators. This task is to create the final piece: a `MappingExecutor` that simply acts as a clean entry point, receiving the pre-built coordinators from the builder.

The old `mapping_executor.py` has been deleted, so you are creating this file from scratch.

## Requirements

1.  **Create the File:**
    -   Create a new file at `biomapper/core/mapping_executor.py`.

2.  **Define the `MappingExecutor` Class:**
    -   The class should inherit from `CompositeIdentifierMixin` for backward compatibility.

3.  **Implement the `__init__` Constructor:**
    -   The constructor must be lightweight.
    -   It should accept the following pre-initialized components as arguments:
        -   `lifecycle_coordinator: LifecycleCoordinator`
        -   `mapping_coordinator: MappingCoordinatorService`
        -   `strategy_coordinator: StrategyCoordinatorService`
        -   `session_manager: SessionManager`
        -   `metadata_query_service: MetadataQueryService`
    -   Store these components as instance attributes (e.g., `self.lifecycle_coordinator = lifecycle_coordinator`).

4.  **Implement Public Methods as Delegations:**
    -   All public methods should be one-line delegations to the appropriate coordinator.
    -   **Lifecycle Methods:**
        -   `async_dispose()`: Delegate to `self.lifecycle_coordinator.dispose_resources()`.
        -   `save_checkpoint(...)`: Delegate to `self.lifecycle_coordinator.save_checkpoint(...)`.
        -   `load_checkpoint(...)`: Delegate to `self.lifecycle_coordinator.load_checkpoint(...)`.
        -   `start_session(...)`: Delegate to `self.lifecycle_coordinator.start_session(...)`.
        -   `end_session(...)`: Delegate to `self.lifecycle_coordinator.end_session(...)`.
    -   **Mapping Execution Methods:**
        -   `execute_mapping(...)`: Delegate to `self.mapping_coordinator.execute_mapping(...)`.
        -   `_execute_path(...)`: Delegate to `self.mapping_coordinator.execute_path(...)`.
    -   **Strategy Execution Methods:**
        -   `execute_strategy(...)`: Delegate to `self.strategy_coordinator.execute_strategy(...)`.
        -   `execute_yaml_strategy(...)`: Delegate to `self.strategy_coordinator.execute_yaml_strategy(...)`.
        -   `execute_robust_yaml_strategy(...)`: Delegate to `self.strategy_coordinator.execute_robust_yaml_strategy(...)`.
    -   **Utility Methods:**
        -   `get_strategy(...)`: Delegate to `self.metadata_query_service.get_strategy(...)`.
        -   `get_cache_session()`: Delegate to `self.session_manager.get_async_cache_session()`.

5.  **Add Necessary Imports:**
    -   Include all necessary imports for type hints and referenced classes.

## Files to Modify
-   **Create:** `biomapper/core/mapping_executor.py`

## Success Criteria
-   The new `mapping_executor.py` file is created.
-   The `MappingExecutor` class is defined with a lean constructor as specified.
-   All public methods are implemented as simple delegations to the correct coordinator or service.
-   The code is clean, well-documented with type hints, and passes linting checks.
# Prompt: Create Unit Tests for `InitializationService`

## Goal
Create a comprehensive suite of unit tests for the new `InitializationService` located at `biomapper/core/engine_components/initialization_service.py`. This service is critical as it's responsible for creating all low-level components, and it currently has no test coverage.

## Context
The `InitializationService` was recently rebuilt from scratch to be the single source of truth for component creation. Its primary method, `create_components`, takes a configuration dictionary and instantiates over a dozen services and managers. Your task is to validate that this process works correctly under various configurations.

## Requirements

1.  **Create Test File:**
    -   Create a new file at `tests/unit/core/engine_components/test_initialization_service.py`.

2.  **Test Structure:**
    -   Use `pytest` and the `unittest.mock` library.
    -   Create a test class, e.g., `TestInitializationService`.
    -   Use a `setup_method` or fixtures to instantiate `InitializationService` for each test.

3.  **Test Scenarios:**
    -   **Test Default Creation:**
        -   Call `create_components` with an empty config dictionary (`{}`).
        -   Assert that the returned `components` dictionary is not None and contains all expected keys (e.g., 'session_manager', 'checkpoint_service', etc.).
        -   Assert that each component in the dictionary is an instance of its expected class.
    -   **Test Custom Configuration:**
        -   Create a sample `config` dictionary with custom values (e.g., a specific `metamapper_db_url`, `checkpoint_enabled=True`).
        -   Use `unittest.mock.patch` to mock the constructors of the underlying services (e.g., `SessionManager`, `CheckpointService`).
        -   Call `create_components` with your custom config.
        -   Assert that the mocked constructors were called with the correct arguments from your config.
    -   **Test Component Dependencies:**
        -   Verify that components are created with the correct dependencies. For example, assert that `CacheManager` is initialized with the `SessionManager` instance created in the same run.

4.  **Coverage:**
    -   Aim for high test coverage of the `create_components` method and the various `_create_*` helper methods within `InitializationService`.
    -   Ensure every component creation path is tested.

## Files to Modify
-   **Create:** `tests/unit/core/engine_components/test_initialization_service.py`

## Success Criteria
-   The new test file is created and populated with comprehensive unit tests.
-   The tests validate both default and custom configuration scenarios.
-   The tests verify the correct instantiation and wiring of components.
-   All tests pass when run with `pytest`.
# Prompt: Consolidate and Complete Tests for Lifecycle Components

## Goal
Ensure the entire refactored lifecycle management subsystem has robust and complete test coverage. This involves reviewing existing tests for the decomposed services and creating new tests for the `LifecycleCoordinator`.

## Context
The old `LifecycleManager` was decomposed into three distinct services (`ExecutionSessionService`, `CheckpointService`, `ResourceDisposalService`) and a new `LifecycleCoordinator` facade that delegates to them. Feedback from a previous run indicated that some tests were created for the services, but the coordinator itself is untested, and the existing tests may be incomplete. This task is to solidify the testing for this entire critical subsystem.

## Requirements

1.  **Review and Enhance Existing Service Tests:**
    -   **File:** `tests/unit/core/services/test_checkpoint_service.py`
    -   **File:** `tests/unit/core/services/test_execution_session_service.py`
    -   **File:** `tests/unit/core/services/test_resource_disposal_service.py`
    -   **Action:** Carefully review the tests in these files. Ensure they are comprehensive, covering all public methods, edge cases, and both success and failure scenarios. Add or refactor tests as needed to achieve complete coverage.

2.  **Create Tests for `LifecycleCoordinator`:**
    -   **Create File:** `tests/unit/core/engine_components/test_lifecycle_coordinator.py`.
    -   **Logic:** The `LifecycleCoordinator` is a pure facade. The tests should reflect this.
    -   **Structure:**
        -   Create mock objects for the three underlying services (`ExecutionSessionService`, `CheckpointService`, `ResourceDisposalService`).
        -   Instantiate the `LifecycleCoordinator` with these mocks.
        -   For each public method in the coordinator (e.g., `save_checkpoint`, `dispose_resources`), write a test to verify that it correctly delegates the call to the appropriate mocked service with the correct arguments.

## Files to Modify
-   **Review/Modify:**
    -   `tests/unit/core/services/test_checkpoint_service.py`
    -   `tests/unit/core/services/test_execution_session_service.py`
    -   `tests/unit/core/services/test_resource_disposal_service.py`
-   **Create:**
    -   `tests/unit/core/engine_components/test_lifecycle_coordinator.py`

## Success Criteria
-   The three existing test files for the lifecycle services are reviewed and updated to be fully comprehensive.
-   A new, complete test suite for the `LifecycleCoordinator` is created and verifies all its delegations.
-   The entire lifecycle subsystem (coordinator and services) has robust, reliable, and complete test coverage.
-   All related tests pass when run with `pytest`.
