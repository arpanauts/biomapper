# Prompt: Implement the `MappingExecutor` as a Pure Facade

## Goal
Create the `biomapper/core/mapping_executor.py` file, defining the `MappingExecutor` class as a pure facade. This class should delegate all its operational logic to specialized coordinator services, and its constructor should be extremely lean.

## Context
The `InitializationService` is responsible for creating all low-level components, and the `MappingExecutorBuilder` is responsible for assembling them into high-level coordinators. This task is to create the final piece: a `MappingExecutor` that simply acts as a clean entry point, receiving the pre-built coordinators from the builder.

The old `mapping_executor.py` has been deleted, so you are creating this file from scratch.

## Requirements

1.  **Create the File:**
    -   Create a new file at `biomapper/core/mapping_executor.py`.

2.  **Define the `MappingExecutor` Class:**
    -   The class should inherit from `CompositeIdentifierMixin` for backward compatibility.

3.  **Implement the `__init__` Constructor:**
    -   The constructor must be lightweight.
    -   It should accept the following pre-initialized components as arguments:
        -   `lifecycle_coordinator: LifecycleCoordinator`
        -   `mapping_coordinator: MappingCoordinatorService`
        -   `strategy_coordinator: StrategyCoordinatorService`
        -   `session_manager: SessionManager`
        -   `metadata_query_service: MetadataQueryService`
    -   Store these components as instance attributes (e.g., `self.lifecycle_coordinator = lifecycle_coordinator`).

4.  **Implement Public Methods as Delegations:**
    -   All public methods should be one-line delegations to the appropriate coordinator.
    -   **Lifecycle Methods:**
        -   `async_dispose()`: Delegate to `self.lifecycle_coordinator.dispose_resources()`.
        -   `save_checkpoint(...)`: Delegate to `self.lifecycle_coordinator.save_checkpoint(...)`.
        -   `load_checkpoint(...)`: Delegate to `self.lifecycle_coordinator.load_checkpoint(...)`.
        -   `start_session(...)`: Delegate to `self.lifecycle_coordinator.start_session(...)`.
        -   `end_session(...)`: Delegate to `self.lifecycle_coordinator.end_session(...)`.
    -   **Mapping Execution Methods:**
        -   `execute_mapping(...)`: Delegate to `self.mapping_coordinator.execute_mapping(...)`.
        -   `_execute_path(...)`: Delegate to `self.mapping_coordinator.execute_path(...)`.
    -   **Strategy Execution Methods:**
        -   `execute_strategy(...)`: Delegate to `self.strategy_coordinator.execute_strategy(...)`.
        -   `execute_yaml_strategy(...)`: Delegate to `self.strategy_coordinator.execute_yaml_strategy(...)`.
        -   `execute_robust_yaml_strategy(...)`: Delegate to `self.strategy_coordinator.execute_robust_yaml_strategy(...)`.
    -   **Utility Methods:**
        -   `get_strategy(...)`: Delegate to `self.metadata_query_service.get_strategy(...)`.
        -   `get_cache_session()`: Delegate to `self.session_manager.get_async_cache_session()`.

5.  **Add Necessary Imports:**
    -   Include all necessary imports for type hints and referenced classes.

## Files to Modify
-   **Create:** `biomapper/core/mapping_executor.py`

## Success Criteria
-   The new `mapping_executor.py` file is created.
-   The `MappingExecutor` class is defined with a lean constructor as specified.
-   All public methods are implemented as simple delegations to the correct coordinator or service.
-   The code is clean, well-documented with type hints, and passes linting checks.
# Prompt: Create Unit Tests for `InitializationService`

## Goal
Create a comprehensive suite of unit tests for the new `InitializationService` located at `biomapper/core/engine_components/initialization_service.py`. This service is critical as it's responsible for creating all low-level components, and it currently has no test coverage.

## Context
The `InitializationService` was recently rebuilt from scratch to be the single source of truth for component creation. Its primary method, `create_components`, takes a configuration dictionary and instantiates over a dozen services and managers. Your task is to validate that this process works correctly under various configurations.

## Requirements

1.  **Create Test File:**
    -   Create a new file at `tests/unit/core/engine_components/test_initialization_service.py`.

2.  **Test Structure:**
    -   Use `pytest` and the `unittest.mock` library.
    -   Create a test class, e.g., `TestInitializationService`.
    -   Use a `setup_method` or fixtures to instantiate `InitializationService` for each test.

3.  **Test Scenarios:**
    -   **Test Default Creation:**
        -   Call `create_components` with an empty config dictionary (`{}`).
        -   Assert that the returned `components` dictionary is not None and contains all expected keys (e.g., 'session_manager', 'checkpoint_service', etc.).
        -   Assert that each component in the dictionary is an instance of its expected class.
    -   **Test Custom Configuration:**
        -   Create a sample `config` dictionary with custom values (e.g., a specific `metamapper_db_url`, `checkpoint_enabled=True`).
        -   Use `unittest.mock.patch` to mock the constructors of the underlying services (e.g., `SessionManager`, `CheckpointService`).
        -   Call `create_components` with your custom config.
        -   Assert that the mocked constructors were called with the correct arguments from your config.
    -   **Test Component Dependencies:**
        -   Verify that components are created with the correct dependencies. For example, assert that `CacheManager` is initialized with the `SessionManager` instance created in the same run.

4.  **Coverage:**
    -   Aim for high test coverage of the `create_components` method and the various `_create_*` helper methods within `InitializationService`.
    -   Ensure every component creation path is tested.

## Files to Modify
-   **Create:** `tests/unit/core/engine_components/test_initialization_service.py`

## Success Criteria
-   The new test file is created and populated with comprehensive unit tests.
-   The tests validate both default and custom configuration scenarios.
-   The tests verify the correct instantiation and wiring of components.
-   All tests pass when run with `pytest`.
# Prompt: Consolidate and Complete Tests for Lifecycle Components

## Goal
Ensure the entire refactored lifecycle management subsystem has robust and complete test coverage. This involves reviewing existing tests for the decomposed services and creating new tests for the `LifecycleCoordinator`.

## Context
The old `LifecycleManager` was decomposed into three distinct services (`ExecutionSessionService`, `CheckpointService`, `ResourceDisposalService`) and a new `LifecycleCoordinator` facade that delegates to them. Feedback from a previous run indicated that some tests were created for the services, but the coordinator itself is untested, and the existing tests may be incomplete. This task is to solidify the testing for this entire critical subsystem.

## Requirements

1.  **Review and Enhance Existing Service Tests:**
    -   **File:** `tests/unit/core/services/test_checkpoint_service.py`
    -   **File:** `tests/unit/core/services/test_execution_session_service.py`
    -   **File:** `tests/unit/core/services/test_resource_disposal_service.py`
    -   **Action:** Carefully review the tests in these files. Ensure they are comprehensive, covering all public methods, edge cases, and both success and failure scenarios. Add or refactor tests as needed to achieve complete coverage.

2.  **Create Tests for `LifecycleCoordinator`:**
    -   **Create File:** `tests/unit/core/engine_components/test_lifecycle_coordinator.py`.
    -   **Logic:** The `LifecycleCoordinator` is a pure facade. The tests should reflect this.
    -   **Structure:**
        -   Create mock objects for the three underlying services (`ExecutionSessionService`, `CheckpointService`, `ResourceDisposalService`).
        -   Instantiate the `LifecycleCoordinator` with these mocks.
        -   For each public method in the coordinator (e.g., `save_checkpoint`, `dispose_resources`), write a test to verify that it correctly delegates the call to the appropriate mocked service with the correct arguments.

## Files to Modify
-   **Review/Modify:**
    -   `tests/unit/core/services/test_checkpoint_service.py`
    -   `tests/unit/core/services/test_execution_session_service.py`
    -   `tests/unit/core/services/test_resource_disposal_service.py`
-   **Create:**
    -   `tests/unit/core/engine_components/test_lifecycle_coordinator.py`

## Success Criteria
-   The three existing test files for the lifecycle services are reviewed and updated to be fully comprehensive.
-   A new, complete test suite for the `LifecycleCoordinator` is created and verifies all its delegations.
-   The entire lifecycle subsystem (coordinator and services) has robust, reliable, and complete test coverage.
-   All related tests pass when run with `pytest`.
