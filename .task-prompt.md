# Task: Resolve Strategy Action Test Failures
# Task: Resolve Client & Adapter Errors - Group B (UniProt, KEGG, PubChem, RefMet, Translator, UMLS, UniChem)
# Task: Resolve Client & Adapter Errors - Group A (Arivale, CSV, Arango)
# Task: Resolve `AttributeError: _load_client` in Various Test Suites
# Task: Resolve CLI, Core Configuration, and Session Management Assertion Failures
# Task: Resolve Miscellaneous Test Errors
# Task: Resolve Cache & Metadata Database Issues (SQLite & SQLAlchemy 2.0)
# Task: Resolve Integration & Strategy Orchestration Issues

## Objective
Fix a variety of errors (RuntimeError, TypeError, AttributeError, KeyError) occurring within unit tests for different strategy actions. These actions are fundamental components of the mapping strategy execution engine.

## Affected Files/Modules
- `tests/unit/core/strategy_actions/test_bidirectional_match.py`
- `tests/unit/core/strategy_actions/test_convert_identifiers_local.py`
- `tests/unit/core/strategy_actions/test_execute_mapping_path.py`
- `tests/unit/core/strategy_actions/test_filter_by_target_presence.py`
- `tests/unit/core/strategy_actions/test_resolve_and_match_forward.py`
- `tests/unit/core/strategy_actions/test_visualize_mapping_flow.py`

## Common Error(s)
- `RuntimeError: Action execution failed: object Mock can't be used in 'await' expression`
- `TypeError: the JSON object must be str, bytes or bytearray, not Mock`
- `TypeError: argument of type 'MockMappingResultBundle' is not iterable`
- `AttributeError`: Often related to module-level access or incorrect mocking (e.g., `<module 'biomapper.core.strategy_actions.resolve_and_match_forward' from ...`).
- `KeyError`: Missing keys, often in context or result data (e.g., `'total_input'` in `test_convert_identifiers_local.py`).

## Background/Context
Strategy actions are individual, reusable operations within a larger mapping strategy (e.g., converting identifiers, executing a sub-path, filtering results). The tests for these actions are failing due to issues that could stem from:
- Incorrect mocking or usage of asynchronous operations within the actions or their tests.
- Changes in how actions interact with the `ExecutionContext` or the data types they expect/produce.
- Refactoring within the action modules themselves that haven't been reflected in the tests.
- Problems with data serialization/deserialization (e.g., JSON handling).

## Debugging Guidance/Hypotheses

**For `RuntimeError: ... object Mock can't be used in 'await' expression` (e.g., in `test_bidirectional_match.py`):**
- This is a strong indicator that an `async` method is being called, but its mock is not an `AsyncMock` or a `MagicMock` returning an awaitable. 
- Review the action's `execute` method and any helper async methods. Ensure mocks for these are set up correctly (e.g., `AsyncMock(return_value=...)`).

**For `TypeError: the JSON object must be str, bytes or bytearray, not Mock` (e.g., in `test_convert_identifiers_local.py`, `test_filter_by_target_presence.py`):**
- This suggests that a function expecting a JSON string (e.g., `json.loads()` or a Pydantic model parsing a string) is instead receiving a Mock object.
- Trace where the data comes from. If it's from a mocked component (like a client or another service), ensure the mock's `return_value` is a properly formatted JSON string, not the mock itself or an un-serialized Python dict.

**For `TypeError: argument of type 'MockMappingResultBundle' is not iterable` (e.g., in `test_execute_mapping_path.py`):**
- The code is attempting to iterate over an object (likely a mock of `MappingResultBundle`) that is not iterable. 
- Check if `MappingResultBundle` is supposed to be iterable or if a specific attribute of it (e.g., a list of results) should be iterated. Adjust the test or mock accordingly.
- Ensure the mock for `MappingResultBundle` correctly emulates its iterable properties if needed.

**For `AttributeError` on modules (e.g., in `test_resolve_and_match_forward.py`, `test_visualize_mapping_flow.py`):**
- These can be tricky. It might indicate an issue with how the test is structured, how mocks are applied at the module level, or an import problem within the action module itself.
- Check if the attribute being accessed is genuinely missing or if a mock is interfering unexpectedly.
- Ensure that any functions or classes imported and used within the action are available and correctly mocked if they are external dependencies.

**For `KeyError` (e.g., `'total_input'`):**
- This implies that the action is trying to access a key in the `ExecutionContext` or a results dictionary that hasn't been set or is named differently.
- Verify the data flow: what populates the context, and what keys are guaranteed to be present when the action runs?
- Check the action's logic for accessing these keys and the test setup for providing them.

## Specific Error Examples
1.  `FAILED tests/unit/core/strategy_actions/test_bidirectional_match.py::TestBidirectionalMatchAction::test_basic_matching_many_to_many - RuntimeError: Action execution failed: object Mock can't be used in 'await' expression`
2.  `FAILED tests/unit/core/strategy_actions/test_convert_identifiers_local.py::TestConvertIdentifiersLocalAction::test_successful_conversion - TypeError: the JSON object must be str, bytes or bytearray, not Mock`
3.  `FAILED tests/unit/core/strategy_actions/test_execute_mapping_path.py::TestExecuteMappingPathAction::test_successful_execution - TypeError: argument of type 'MockMappingResultBundle' is not iterable`
4.  `FAILED tests/unit/core/strategy_actions/test_resolve_and_match_forward.py::TestResolveAndMatchForwardAction::test_basic_resolution_and_matching - AttributeError: <module 'biomapper.core.strategy_actions.resolve_and_match_forward' from ...`
5.  `FAILED tests/unit/core/strategy_actions/test_convert_identifiers_local.py::TestConvertIdentifiersLocalAction::test_empty_input_identifiers - KeyError: 'total_input'`
Address a wide range of errors (AttributeError, TypeError, AssertionError, KeyError, NameError, specific client exceptions) in tests for various external biomedical data clients, including UniProt, KEGG, PubChem, RefMet, Translator Name Resolver, UMLS, and UniChem.

## Affected Files/Modules
- `tests/mapping/clients/test_composite_gene_mapping.py` (UniProtNameClient)
- `tests/mapping/clients/uniprot/test_uniprot_mapping.py`
- `tests/mapping/clients/test_uniprot_historical_resolver_client.py`
- `tests/mapping/clients/test_kegg_client.py`
- `tests/mapping/clients/test_pubchem_client.py`
- `tests/mapping/clients/test_refmet_client.py`
- `tests/mapping/clients/test_translator_name_resolver_client.py`
- `tests/mapping/clients/test_umls_client.py`
- `tests/mapping/clients/test_unichem_client.py`

## Common Error(s)
- `AttributeError`: Object missing an expected attribute/method (e.g., `'UniProtNameClient' object has no attribute 'find_uniprot_ids_by_names'`, `'NoneType' object has no attribute 'close'`).
- `TypeError`: Incorrect argument types or usage (e.g., `UniProtIDMappingClient.__init__() got an unexpected keyword argument 'config'`).
- `AssertionError`: Test expectations not met (e.g., specific client errors not raised, return values differ, mock call counts incorrect).
- `KeyError`: Missing keys in dictionaries, often from API responses or test data (e.g., `'params'` in Translator client).
- `NameError`: Undefined variable or name (e.g., `name 'ClientInitializationError' is not defined` in UMLS client tests).
- Specific client exceptions (e.g., `biomapper.mapping.clients.pubchem_client.PubChemError`).

## Background/Context
This group of tests validates clients that interface with various external biomedical APIs. Such tests are prone to failures due to:
- Changes in the external APIs themselves (though mocks should mitigate this, mock contracts might become outdated).
- Internal refactoring of the client classes within Biomapper.
- Desynchronization between test logic/data and the current state of the client code.
- Issues with resource management (e.g., closing client sessions, as suggested by `'NoneType' object has no attribute 'close'`).

## Debugging Guidance/Hypotheses

**General Approach:**
- **One Client at a Time:** Tackle tests for each client systematically.
- **API Documentation (if necessary):** For external API related issues, briefly consulting the relevant API's documentation might clarify expected request/response formats if mocks seem incorrect.
- **Client Code Review:** Examine the `__init__` method, main mapping methods, and any resource management (e.g., `close()`) in the client class being tested.

**Specific Error Types:**
- **`AttributeError` (e.g., `find_uniprot_ids_by_names`, `close`):**
    - Verify method/attribute names in the client class. They might have been renamed or removed.
    - For `close` errors on `NoneType`, it suggests the client object itself might be `None` when `close` is called, possibly due to an earlier initialization failure or incorrect test logic.
- **`TypeError` (e.g., `unexpected keyword argument 'config'`):**
    - Check the client's `__init__` signature. The test might be passing outdated or incorrect arguments.
- **`AssertionError`:**
    - **Error Not Raised:** If a specific exception is expected but not raised, the error handling in the client might have changed, or the condition to trigger the error is not met by the test.
    - **Value Mismatch:** Compare expected vs. actual values. This could be due to changes in client logic, data processing, or mock return values.
    - **Mock Call Counts:** If mock call counts are off (e.g., `Expected '_fetch_uniprot_search_results' to have been called once. Called 2 times.`), trace the logic in the client to see why the mock is called differently than expected.
- **`KeyError` (e.g., `'params'`):**
    - Inspect the data structure (likely a dictionary from a mocked API response or internal processing) where the key is expected. The structure might have changed.
- **`NameError` (e.g., `ClientInitializationError`):**
    - Ensure all necessary exceptions and classes are imported in the test file or the client module itself.
- **Specific Client Exceptions (e.g., `PubChemError`):**
    - This indicates the client is correctly raising its specific error, but the test might not be expecting it or handling it as a failure. If the error *should* be caught and handled by the client or test, verify that logic. If the test is designed to *cause* this error, then the test itself might be failing for other reasons (e.g., an assertion after the expected error).

## Specific Error Examples
1.  `FAILED tests/mapping/clients/test_composite_gene_mapping.py::test_composite_gene_symbols - AttributeError: 'UniProtNameClient' object has no attribute 'find_uniprot_ids_by_names'`
2.  `FAILED tests/mapping/clients/uniprot/test_uniprot_mapping.py::test - TypeError: UniProtIDMappingClient.__init__() got an unexpected keyword argument 'config'`
3.  `FAILED tests/mapping/clients/test_kegg_client.py::TestKEGGClient::test_get_entity_by_id_error - AssertionError: KEGGError not raised`
4.  `FAILED tests/mapping/clients/test_pubchem_client.py::TestPubChemClient::test_search_by_name_no_results - biomapper.mapping.clients.pubchem_client.PubChemError: Search failed: API request failed: 404 Client Error: PUGREST.NotFound for url: ht...`
5.  `FAILED tests/mapping/clients/test_translator_name_resolver_client.py::test_lookup_entity_name - KeyError: 'params'`
6.  `FAILED tests/mapping/clients/test_umls_client.py::test_init - NameError: name 'ClientInitializationError' is not defined`
7.  `FAILED tests/mapping/clients/test_unichem_client.py::test_close - AttributeError: 'NoneType' object has no attribute 'close'`
Address a variety of errors (AttributeError, KeyError, AssertionError, TypeError) in tests for Arivale clients, CSVAdapter, and ArangoDB-related components.

## Affected Files/Modules
- `tests/mapping/clients/test_arivale_lookup_client.py`
- `tests/mapping/clients/test_arivale_reverse_lookup_client.py`
- `tests/mapping/clients/arivale/test_arivale_lookup.py`
- `tests/mapping/test_extractors.py` (specifically `CSVAdapter` related tests)
- `tests/mapping/adapters/test_csv_adapter.py`
- `tests/mapping/arango/test_arango_store.py`
- `tests/mapping/arango/test_base_arango.py`

## Common Error(s)
- `AssertionError`: Mismatched expected vs. actual results (e.g., set comparisons, value checks).
- `AttributeError`: Object does not have an expected attribute or method, often due to API changes or incorrect mocking.
- `KeyError`: Attempting to access a dictionary key that does not exist, often related to test data or API response structure.
- `TypeError`: Operation or function applied to an object of an inappropriate type (e.g., `object MockArango can't be used in 'await' expression`).

## Background/Context
This group of tests covers components responsible for interacting with specific data sources (Arivale, ArangoDB) or data formats (CSV). Failures can arise from:
- Internal refactoring of these client/adapter classes.
- Changes in the expected data format or API of these components.
- Outdated test data or mock configurations that no longer align with current code.
- Issues with asynchronous code, especially when mocking async methods or using async objects in synchronous contexts (or vice-versa).

## Debugging Guidance/Hypotheses

**General Approach:**
- **Isolate Tests:** Focus on one failing test file at a time.
- **Review Component Code:** Briefly look at the client or adapter code being tested to understand its current API and behavior.
- **Check Test Setup:** Examine how test data, mocks, and component instances are created.

**Specific Error Types:**
- **`AssertionError`:**
    - Carefully compare the expected and actual values. Print them out if necessary.
    - Verify that the test logic correctly generates the expected outcome based on the input and component's behavior.
    - For set comparisons, check for differences in elements, not just counts.
- **`AttributeError`:**
    - Check if the method or attribute name has changed in the component's class.
    - If using mocks, ensure the mock is configured with the necessary attributes/methods (e.g., using `spec` or `autospec`).
- **`KeyError`:**
    - Inspect the dictionary being accessed and the key being used.
    - If it's from a mocked API response, ensure the mock returns data with the expected keys.
    - If it's processing input data, ensure the test input data is correctly structured.
- **`TypeError` (e.g., `object MockArango can't be used in 'await' expression`):**
    - This often indicates an issue with mocking asynchronous code. If a method is `async def`, its mock should typically be an `AsyncMock` or a regular `MagicMock` whose `return_value` is an awaitable (e.g., a coroutine or another `AsyncMock`).
    - Ensure that `await` is used correctly with async functions and methods.

**For `tests/mapping/test_extractors.py` (`CSVAdapter`):**
- The errors `AttributeError: 'CSVAdapter' object has no attribute 'extract_ids_from_row'` and `'extract_id_from_cell'` suggest these methods might have been renamed, removed, or their functionality refactored within the `CSVAdapter` class.

**For Arango tests (`test_arango_store.py`, `test_base_arango.py`):**
- `AttributeError: 'ArangoStore' object has no attribute 'is_connected'`: This attribute might have been removed or renamed.
- `assert None is not None` / `assert 0 > 0`: These indicate that queries or operations are not returning expected data. Check mock setups for Arango client interactions or actual DB state if tests hit a real (test) Arango instance.
- `TypeError: object MockArango can't be used in 'await' expression`: Likely an issue with how async Arango client methods are mocked or called.

## Specific Error Examples
1.  `FAILED tests/mapping/clients/test_arivale_lookup_client.py::TestArivaleMetadataLookupClient::test_map_simple_identifiers - AssertionError: assert {'secondary_ids', 'errors', 'input_to_primary', 'primary_ids'} == {'NONEXISTENT', 'P67890', 'P12345'}`
2.  `FAILED tests/mapping/test_extractors.py::test_csv_adapter_extract_ids_from_row - AttributeError: 'CSVAdapter' object has no attribute 'extract_ids_from_row'`
3.  `FAILED tests/mapping/arango/test_arango_store.py::test_get_node - assert None is not None`
4.  `FAILED tests/mapping/arango/test_base_arango.py::test_get_node - TypeError: object MockArango can't be used in 'await' expression`
Resolve all `AttributeError: ... object has no attribute '_load_client'` errors across various test suites. This involves refactoring affected tests to correctly use the new `ClientManager.get_client_instance()` method for client loading and mocking.

## Affected Files/Modules (Primary Focus)
- `tests/test_yaml_strategy_provenance.py`
- `tests/core/test_bidirectional_mapping_optimization.py`
- `tests/integration/test_yaml_strategy_ukbb_hpa.py`
- `tests/mapping/test_reverse_mapping.py`
- `tests/unit/core/test_mapping_executor_robust_features.py`
- `tests/integration/test_historical_id_mapping.py`
- `tests/core/test_mapping_executor_metadata.py`
- `tests/core/test_metadata_population.py`

## Common Error(s)
- `AttributeError: '...' object has no attribute '_load_client'`

## Background/Context
The core mapping component has been refactored, and client loading responsibilities have been moved to the `ClientManager` component. The private `_load_client` method (and its helper `_load_client_class`) no longer exists directly on the main component. Tests that attempt to call or mock this old method will fail.

The correct approach is to interact with the component's `client_manager.get_client_instance(resource)` for obtaining client instances or `client_manager._load_client_class(path_string)` if testing the class loading logic directly (though the latter is an internal method of `ClientManager` itself).

## Debugging Guidance/Hypotheses
- Ensure `patch.object` targets are updated from `component, "_load_client"` to `component.client_manager, "get_client_instance"`.
- If `_load_client_class` was being tested or mocked directly, the target should now be `component.client_manager, "_load_client_class"`.
- The `get_client_instance` method is asynchronous and expects a `MappingResource` object as an argument. Ensure mocks (return values, side effects) are compatible.

## Specific Error Examples
1.  `FAILED tests/test_yaml_strategy_provenance.py::TestYAMLStrategyProvenanceTracking::test_trace_mapping_chain_simple - AttributeError: '...' object has no attribute '_load_client'`
2.  `FAILED tests/core/test_bidirectional_mapping_optimization.py::TestBidirectionalMappingOptimization::test_path_caching - AttributeError: '...' object has no attribute '_load_client'`
Address various `AssertionError`s in tests for the command-line interface (`test_metamapper_db_cli.py`), core configuration loading (`test_config.py`), and session manager (`test_session_manager.py`).

## Affected Files/Modules
- `tests/cli/test_metamapper_db_cli.py`
- `tests/core/test_config.py`
- `tests/core/engine_components/test_session_manager.py`

## Common Error(s)
- Various `AssertionError`s, including:
    - `assert 1 == 0`
    - `AssertionError: assert 'expected_url' == 'actual_url'` (URL mismatches)
    - `AssertionError: Path('path/to/metamapper.db') call not found` (Mock call expectations not met)
    - `assert 'Error message fragment' in 'Full error message'` (Error message content mismatch)

## Background/Context
These tests validate fundamental aspects of the application's setup, command-line tooling, configuration handling, and database session management. Failures in these areas can indicate:
- **Outdated Tests:** Test logic or expected values may not have been updated after recent code changes.
- **Incorrect Mock Expectations:** Mocks might be set up with incorrect return values or call expectations.
- **Genuine Bugs:** There could be actual issues in the components being tested.
- **Incomplete Tests:** `assert 1 == 0` usually signifies a test that was stubbed out but not fully implemented.
Address a diverse collection of remaining test failures across various parts of the Biomapper application, including examples/tutorials, embedder components, MVP pipeline tests, Spoke integration, and other core utilities like ActionLoader and PathFinder.

## Affected Files/Modules
- `examples/tutorials/test_gemini.py`
- `tests/embedder/storage/test_vector_store.py`
- `tests/embedder/test_qdrant_store.py`
- `tests/mapping/test_endpoint_mapping.py`
- `tests/mvp0_pipeline/test_pipeline_orchestrator.py`
- `tests/mvp0_pipeline/test_qdrant_search.py`
- `tests/spoke/test_graph_analyzer.py`
- `tests/unit/core/test_action_loader.py`
- `tests/unit/core/test_path_finder.py`
- `tests/mapping/rag/test_rag_setup.py`

## Common Error(s)
This category is a mix of various error types, including but not limited to:
- `requests.exceptions.MissingSchema`: Invalid URL format.
- `AssertionError`: General test expectation failures.
- `TypeError: Can't instantiate abstract class ...`: Attempting to instantiate an abstract base class that has unimplemented abstract methods.
- `sqlite3.OperationalError: unable to open database file`: Database connectivity issue.
- `AttributeError`: Missing attributes or methods, often due to refactoring or incorrect object state.
- `pydantic_core._pydantic_core.ValidationError`: Pydantic model validation failures.
- `SQLAlchemyError`: Generic database errors during test execution.
- `biomapper.core.exceptions.ConfigurationError`: Errors related to loading or instantiating configured components (e.g., Actions).

## Background/Context
This prompt serves as a catch-all for errors that don't fit neatly into the previously defined categories. They span different layers and functionalities of the application, from example usage and embedding/vector store interactions to specific data source integrations (Spoke) and core framework components (ActionLoader, PathFinder).

Each error will likely require a focused investigation into the specific component and test case.

## Debugging Guidance/Hypotheses

- **`requests.exceptions.MissingSchema` (`test_gemini.py`):**
    - An URL is being used (likely for an API call) that is missing the scheme (e.g., `http://` or `https://`). Check configuration values or how URLs are constructed for the Gemini API client.

- **`TypeError: Can't instantiate abstract class QdrantVectorStore` (`test_qdrant_store.py`):**
    - `QdrantVectorStore` is likely an abstract base class. Tests should instantiate a concrete implementation, or if testing the ABC directly, ensure all abstract methods are mocked/implemented if instantiation is attempted.

- **`sqlite3.OperationalError: unable to open database file` (`test_endpoint_mapping.py`):**
    - The test is trying to connect to a SQLite database file, but the file cannot be opened. Check the database path, file permissions, or if the database file is expected to exist/be created by the test setup.

- **`AttributeError` in `test_pipeline_orchestrator.py`, `test_qdrant_search.py`, `test_graph_analyzer.py`, `test_action_loader.py`:**
    - These are likely due to refactoring where method/attribute names changed, or objects are not in the expected state (e.g., `NoneType` errors like in `test_graph_analyzer.py`). Review recent changes to these components and update tests accordingly.
    - For `test_action_loader.py` errors like `property 'action_registry' of 'ActionLoader' object has no deleter` or `AttributeError: <module ...>`, this points to issues with how actions are registered, loaded, or mocked, possibly related to recent refactoring of action loading or registry mechanisms.

- **`pydantic_core._pydantic_core.ValidationError` (`test_qdrant_search.py`):**
    - Data being passed to a Pydantic model for validation (e.g., `MappingOutput`) does not conform to the model's schema. Inspect the data being validated and the Pydantic model definition.

- **`SQLAlchemyError` (`test_path_finder.py`):**
    - A generic database error occurred. This could be due to incorrect query formation, issues with the test database session, or problems with the underlying data or schema expected by the PathFinder.

- **`AssertionError` (general):**
    - These require case-by-case analysis. Check what the test is asserting and why it's failing. It could be outdated test logic, incorrect mocks, or a bug in the component.

- **`ConfigurationError` (`test_action_loader.py`):**
    - Errors like `Failed to instantiate action ... takes no arguments` or `Unexpected error loading action class` indicate problems with the configuration provided for an action or the action class itself (e.g., `__init__` signature mismatch, module/class not found).

## Debugging Guidance/Hypotheses

**For `assert 1 == 0` (e.g., in `tests/cli/test_metamapper_db_cli.py`):**
- These are placeholder assertions. The tests need to be fully implemented with meaningful checks for the CLI commands' behavior and output.

**For URL Mismatches (e.g., in `tests/core/test_config.py`):**
- **Environment Variables:** Check if environment variables influencing configuration (like database URLs) are correctly set or mocked during the test run.
- **Default Values:** Verify the default values in the configuration logic against what the tests expect.
- **Precedence Order:** If testing configuration precedence (e.g., env var vs. file vs. default), ensure the test setup correctly reflects the scenario being tested and that the precedence logic in the code is correct.

**For Mock Call Not Found (e.g., `Path(...) call not found` in `tests/core/engine_components/test_session_manager.py`):**
- **Mock Target:** Ensure the mock is patching the correct object and attribute.
- **Call Arguments:** Verify that the arguments with which the mocked method is expected to be called match the actual call arguments in the code under test.
- **Mock Setup:** Double-check the mock object's configuration (e.g., `MagicMock`, `AsyncMock`, `return_value`, `side_effect`).

**For Error Message Content Mismatch (e.g., in `tests/core/engine_components/test_session_manager.py`):**
- **Exact Wording:** Error messages can be sensitive to minor changes. Compare the expected substring with the actual error message produced by the code. It might be necessary to update the assertion or make the expected substring more robust (e.g., less specific if appropriate).
- **Exception Type:** Ensure the test is catching and inspecting the correct type of exception.

## Specific Error Examples
1.  `FAILED tests/cli/test_metamapper_db_cli.py::TestResourcesCommands::test_resources_list_empty - assert 1 == 0`
2.  `FAILED tests/core/test_config.py::TestConfig::test_environment_variable_loading - AssertionError: assert 'sqlite+aiosqlite:////home/ubuntu/Software-Engineer-AI-Agent-Atlas/biomapper/data/metamapper.db' == 'sqlite:///te...'`
3.  `FAILED tests/core/engine_components/test_session_manager.py::TestSessionManager::test_ensure_db_directories_sqlite - AssertionError: Path('path/to/metamapper.db') call not found`
4.  `FAILED tests/core/engine_components/test_session_manager.py::TestSessionManager::test_ensure_db_directories_error_handling - assert 'Error ensuring directory for sqlite:///test.db: Test error' in 'call("Error ensuring directory for sqlite:///test.db: type objec...'`
## Specific Error Examples
1.  `FAILED examples/tutorials/test_gemini.py::test_gemini_api - requests.exceptions.MissingSchema: Invalid URL 'None': No scheme supplied. Perhaps you meant https://None?`
2.  `ERROR tests/embedder/test_qdrant_store.py::TestQdrantVectorStoreScores::test_search_returns_similarity_scores - TypeError: Can't instantiate abstract class QdrantVectorStore with abstract methods add_documents, clear, get_similar`
3.  `FAILED tests/mapping/test_endpoint_mapping.py::test_relationship_mapping - sqlite3.OperationalError: unable to open database file`
4.  `FAILED tests/mvp0_pipeline/test_qdrant_search.py::TestQdrantSearch::test_search_successful_with_scores - pydantic_core._pydantic_core.ValidationError: 1 validation error for MappingOutput`
5.  `FAILED tests/spoke/test_graph_analyzer.py::test_discover_node_types_spoke_style - AttributeError: 'NoneType' object has no attribute 'collections'`
6.  `FAILED tests/unit/core/test_action_loader.py::TestActionLoader::test_instantiate_action - biomapper.core.exceptions.ConfigurationError: [CONFIGURATION_ERROR] Failed to instantiate action 'TEST_ACTION': MockAction() takes no ar...`
Fix SQLite operational errors related to missing tables (specifically `entity_mappings`) and address SQLAlchemy 2.0 compatibility issues for raw SQL queries in tests related to caching and metadata.
Address `ModuleNotFoundError` for `scripts.populate_metamapper_db` in integration tests and fix `TypeError`s related to asynchronous context managers in `StrategyOrchestrator` tests.

## Affected Files/Modules
- `tests/cache/test_cached_mapper.py`
- `tests/cache/test_manager.py`
- `tests/core/test_metadata_fields.py`
- `tests/core/test_metadata_impl.py`

## Common Error(s)
- `sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: entity_mappings`
- `sqlalchemy.exc.ArgumentError: Textual SQL expression 'DELETE FROM entity_mappin...' should be explicitly declared as text('DELETE FROM e...')`

## Background/Context
The `entity_mappings` table, crucial for caching, appears to be missing or inaccessible during certain test executions. This could be due to issues with test database setup, schema creation, or session management within the tests.

Additionally, SQLAlchemy 2.0 has enforced stricter handling of raw SQL strings. Queries executed directly (not through the ORM's expression language) must now be explicitly wrapped with `text()` to be recognized as SQL statements.

## Debugging Guidance/Hypotheses

**For `no such table: entity_mappings`:**
- **Test Database Setup:** Verify how the test database is initialized. Is it an in-memory SQLite database (`sqlite:///:memory:`) or a file-based one? Ensure consistency.
- **Schema Creation:** Confirm that `Base.metadata.create_all(engine)` (or its async equivalent) is called correctly before tests that interact with the database are run. This is essential for creating all defined tables.
- **Session Scope:** Check if test sessions are correctly scoped and if schema creation happens within the right context for the test's session to see the tables.
- **Fixtures:** Review pytest fixtures responsible for database setup (e.g., `engine`, `session` fixtures) to ensure they correctly set up and tear down the database environment, including table creation.

**For `ArgumentError: Textual SQL expression ... should be explicitly declared as text(...)`:**
- **Import `text`:** Ensure `from sqlalchemy import text` is present in the relevant files.
- **Wrap SQL Strings:** Locate all raw SQL strings used in functions like `session.execute()` and wrap them with the `text()` construct. For example, `session.execute("DELETE FROM entity_mappings")` should become `session.execute(text("DELETE FROM entity_mappings"))`.

## Specific Error Examples
1.  `FAILED tests/cache/test_cached_mapper.py::CachedMapperTest::test_batch_map_mixed_hits - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: entity_mappings`
2.  `FAILED tests/cache/test_manager.py::CacheManagerTest::test_add_mapping - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: entity_mappings`
3.  `FAILED tests/core/test_metadata_fields.py::test_cache_results_populates_metadata_fields - sqlalchemy.exc.ArgumentError: Textual SQL expression 'DELETE FROM entity_mappin...' should be explicitly declared as text('DELETE FROM e...')`
## Affected Files/Modules
- `tests/integration/test_yaml_strategy_execution.py`
- `tests/core/engine_components/test_strategy_orchestrator.py`

## Common Error(s)
- `ModuleNotFoundError: No module named 'scripts.populate_metamapper_db'`
- `TypeError: 'coroutine' object does not support the asynchronous context manager protocol`

## Background/Context
**ModuleNotFoundError:**
The `scripts` directory, containing `populate_metamapper_db.py`, is not currently configured as a Python package (it lacks `__init__.py` files). This prevents direct import of the script as a module in the integration tests. The script is likely intended to be run as a command-line tool.

**TypeError with Async Context Managers:**
Tests for `StrategyOrchestrator` are failing with `TypeError: 'coroutine' object does not support the asynchronous context manager protocol`. This typically occurs when an `async def` function that is *not* a proper asynchronous context manager is used with `async with`. An asynchronous context manager requires `__aenter__` and `__aexit__` methods, or to be a generator decorated with `@asynccontextmanager` from `contextlib`.

## Debugging Guidance/Hypotheses

**For `ModuleNotFoundError: No module named 'scripts.populate_metamapper_db'`:**
- **Option 1 (Recommended for scripts): Run as Subprocess:** Modify the integration tests to execute `populate_metamapper_db.py` using `subprocess.run()` or `asyncio.create_subprocess_exec`. This aligns with how standalone scripts are typically invoked and tested. Remember that the script auto-discovers configs and takes `--drop-all` (Memory `[631e6476-8513-4727-aa46-494041b7b79b]`).
- **Option 2 (Make `scripts` a package):** Add empty `__init__.py` files to `/home/ubuntu/Software-Engineer-AI-Agent-Atlas/biomapper/scripts/` and `/home/ubuntu/Software-Engineer-AI-Agent-Atlas/biomapper/scripts/setup_and_configuration/`. This would allow imports like `from scripts.setup_and_configuration import populate_metamapper_db`. Ensure the project root is in `sys.path` (Poetry usually handles this).
- **Investigate Test Setup:** See how `tests/integration/test_yaml_strategy_execution.py` attempts to use or invoke the script. The fix will depend on this current approach.

**For `TypeError: 'coroutine' object does not support the asynchronous context manager protocol`:**
- **Review Async Context Managers:** Examine the objects being used with `async with` in `tests/core/engine_components/test_strategy_orchestrator.py`. 
- **Check for `@asynccontextmanager`:** If the object is an async generator function intended for context management, ensure it's decorated with `@asynccontextmanager` from the `contextlib` module and uses `yield` appropriately.
- **Verify `__aenter__` and `__aexit__`:** If it's a class, ensure it correctly implements the `async def __aenter__(self):` and `async def __aexit__(self, exc_type, exc_val, exc_tb):` methods.
- **Mocking:** If mocks are involved, ensure the mock object is configured to behave like a proper async context manager (e.g., its `__aenter__` returns an awaitable, or the mock itself is an `AsyncMock` configured appropriately).

## Specific Error Examples
1.  `ERROR tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_basic_linear_strategy - ModuleNotFoundError: No module named 'scripts.populate_metamapper_db'`
2.  `FAILED tests/core/engine_components/test_strategy_orchestrator.py::TestStrategyOrchestrator::test_successful_strategy_execution - TypeError: 'coroutine' object does not support the asynchronous context manager protocol`
3.  `FAILED tests/core/engine_components/test_strategy_orchestrator.py::TestStrategyOrchestrator::test_strategy_failure_required_step - TypeError: 'coroutine' object does not support the asynchronous context manager protocol`

## Acceptance Criteria
- All unit tests for strategy actions in the listed 'Affected Files/Modules' pass successfully.
- Asynchronous operations within actions are correctly mocked and tested.
- Data type mismatches (especially around JSON and iterables) are resolved.
- Actions correctly interact with the `ExecutionContext` and handle expected data structures.
- `AttributeError`s related to module access or mocking are fixed.
- All tests in the listed 'Affected Files/Modules' for these clients pass successfully.
- Client initialization, method calls, error handling, and resource management are correctly tested and functioning.
- Test assertions, mock configurations, and expected data structures are aligned with the current implementations of the respective client classes.
- All tests in the listed 'Affected Files/Modules' pass successfully.
- `AttributeError`s are resolved by updating tests to use correct API names or by fixing the components.
- `KeyError`s are resolved by correcting test data, mock responses, or data access logic.
- `AssertionError`s are resolved by aligning test expectations with actual component behavior or fixing bugs in components.
- `TypeError`s, especially those related to async operations, are resolved by correct usage and mocking of asynchronous code.
- All tests in the listed 'Affected Files/Modules' that previously failed with the `AttributeError: ... '_load_client'` now pass.
- Component instances in tests correctly utilize `ClientManager` for client-related operations.
- Mocks are updated to reflect the new `ClientManager` API.
- All tests in `tests/cli/test_metamapper_db_cli.py`, `tests/core/test_config.py`, and `tests/core/engine_components/test_session_manager.py` pass.
- Incomplete tests (those with `assert 1 == 0`) are fully implemented with valid assertions.
- Assertions related to configuration values, mock calls, and error messages accurately reflect the current behavior of the tested components.
- Core configuration loading, CLI commands, and session management functionalities are robustly tested and verified.
- All tests listed in the 'Affected Files/Modules' for this miscellaneous category pass successfully.
- Configuration issues (URLs, Pydantic models) are resolved.
- Abstract class instantiation errors are fixed by using concrete implementations or appropriate test strategies.
- Database connectivity and operational errors are addressed.
- AttributeErrors and other specific component failures are resolved through targeted debugging and test/code updates.
- All tests in the listed 'Affected Files/Modules' that previously failed with `OperationalError: no such table: entity_mappings` now pass, indicating the `entity_mappings` table is correctly created and accessible.
- All tests that previously failed with `ArgumentError: Textual SQL expression ... should be explicitly declared as text(...)` now pass, with raw SQL queries correctly adapted for SQLAlchemy 2.0.
- Database interactions within these tests are robust and schema is correctly managed.
- Integration tests in `tests/integration/test_yaml_strategy_execution.py` can successfully invoke or utilize the `populate_metamapper_db.py` script, resolving the `ModuleNotFoundError`.
- All tests in `tests/core/engine_components/test_strategy_orchestrator.py` pass, with `TypeError`s related to async context managers resolved.
- The chosen solution for the `ModuleNotFoundError` is robust and aligns with good testing practices for scripts.
- Asynchronous context managers are correctly implemented and used in the strategy orchestrator tests.
