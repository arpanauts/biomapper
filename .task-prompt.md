# Task: Resolve CLI, Core Configuration, and Session Management Assertion Failures
# Task: Resolve Miscellaneous Test Errors
# Task: Resolve Cache & Metadata Database Issues (SQLite & SQLAlchemy 2.0)
# Task: Resolve Integration & Strategy Orchestration Issues

## Objective
Address various `AssertionError`s in tests for the command-line interface (`test_metamapper_db_cli.py`), core configuration loading (`test_config.py`), and session manager (`test_session_manager.py`).

## Affected Files/Modules
- `tests/cli/test_metamapper_db_cli.py`
- `tests/core/test_config.py`
- `tests/core/engine_components/test_session_manager.py`

## Common Error(s)
- Various `AssertionError`s, including:
    - `assert 1 == 0`
    - `AssertionError: assert 'expected_url' == 'actual_url'` (URL mismatches)
    - `AssertionError: Path('path/to/metamapper.db') call not found` (Mock call expectations not met)
    - `assert 'Error message fragment' in 'Full error message'` (Error message content mismatch)

## Background/Context
These tests validate fundamental aspects of the application's setup, command-line tooling, configuration handling, and database session management. Failures in these areas can indicate:
- **Outdated Tests:** Test logic or expected values may not have been updated after recent code changes.
- **Incorrect Mock Expectations:** Mocks might be set up with incorrect return values or call expectations.
- **Genuine Bugs:** There could be actual issues in the components being tested.
- **Incomplete Tests:** `assert 1 == 0` usually signifies a test that was stubbed out but not fully implemented.
Address a diverse collection of remaining test failures across various parts of the Biomapper application, including examples/tutorials, embedder components, MVP pipeline tests, Spoke integration, and other core utilities like ActionLoader and PathFinder.

## Affected Files/Modules
- `examples/tutorials/test_gemini.py`
- `tests/embedder/storage/test_vector_store.py`
- `tests/embedder/test_qdrant_store.py`
- `tests/mapping/test_endpoint_mapping.py`
- `tests/mvp0_pipeline/test_pipeline_orchestrator.py`
- `tests/mvp0_pipeline/test_qdrant_search.py`
- `tests/spoke/test_graph_analyzer.py`
- `tests/unit/core/test_action_loader.py`
- `tests/unit/core/test_path_finder.py`
- `tests/mapping/rag/test_rag_setup.py`

## Common Error(s)
This category is a mix of various error types, including but not limited to:
- `requests.exceptions.MissingSchema`: Invalid URL format.
- `AssertionError`: General test expectation failures.
- `TypeError: Can't instantiate abstract class ...`: Attempting to instantiate an abstract base class that has unimplemented abstract methods.
- `sqlite3.OperationalError: unable to open database file`: Database connectivity issue.
- `AttributeError`: Missing attributes or methods, often due to refactoring or incorrect object state.
- `pydantic_core._pydantic_core.ValidationError`: Pydantic model validation failures.
- `SQLAlchemyError`: Generic database errors during test execution.
- `biomapper.core.exceptions.ConfigurationError`: Errors related to loading or instantiating configured components (e.g., Actions).

## Background/Context
This prompt serves as a catch-all for errors that don't fit neatly into the previously defined categories. They span different layers and functionalities of the application, from example usage and embedding/vector store interactions to specific data source integrations (Spoke) and core framework components (ActionLoader, PathFinder).

Each error will likely require a focused investigation into the specific component and test case.

## Debugging Guidance/Hypotheses

- **`requests.exceptions.MissingSchema` (`test_gemini.py`):**
    - An URL is being used (likely for an API call) that is missing the scheme (e.g., `http://` or `https://`). Check configuration values or how URLs are constructed for the Gemini API client.

- **`TypeError: Can't instantiate abstract class QdrantVectorStore` (`test_qdrant_store.py`):**
    - `QdrantVectorStore` is likely an abstract base class. Tests should instantiate a concrete implementation, or if testing the ABC directly, ensure all abstract methods are mocked/implemented if instantiation is attempted.

- **`sqlite3.OperationalError: unable to open database file` (`test_endpoint_mapping.py`):**
    - The test is trying to connect to a SQLite database file, but the file cannot be opened. Check the database path, file permissions, or if the database file is expected to exist/be created by the test setup.

- **`AttributeError` in `test_pipeline_orchestrator.py`, `test_qdrant_search.py`, `test_graph_analyzer.py`, `test_action_loader.py`:**
    - These are likely due to refactoring where method/attribute names changed, or objects are not in the expected state (e.g., `NoneType` errors like in `test_graph_analyzer.py`). Review recent changes to these components and update tests accordingly.
    - For `test_action_loader.py` errors like `property 'action_registry' of 'ActionLoader' object has no deleter` or `AttributeError: <module ...>`, this points to issues with how actions are registered, loaded, or mocked, possibly related to recent refactoring of action loading or registry mechanisms.

- **`pydantic_core._pydantic_core.ValidationError` (`test_qdrant_search.py`):**
    - Data being passed to a Pydantic model for validation (e.g., `MappingOutput`) does not conform to the model's schema. Inspect the data being validated and the Pydantic model definition.

- **`SQLAlchemyError` (`test_path_finder.py`):**
    - A generic database error occurred. This could be due to incorrect query formation, issues with the test database session, or problems with the underlying data or schema expected by the PathFinder.

- **`AssertionError` (general):**
    - These require case-by-case analysis. Check what the test is asserting and why it's failing. It could be outdated test logic, incorrect mocks, or a bug in the component.

- **`ConfigurationError` (`test_action_loader.py`):**
    - Errors like `Failed to instantiate action ... takes no arguments` or `Unexpected error loading action class` indicate problems with the configuration provided for an action or the action class itself (e.g., `__init__` signature mismatch, module/class not found).

## Debugging Guidance/Hypotheses

**For `assert 1 == 0` (e.g., in `tests/cli/test_metamapper_db_cli.py`):**
- These are placeholder assertions. The tests need to be fully implemented with meaningful checks for the CLI commands' behavior and output.

**For URL Mismatches (e.g., in `tests/core/test_config.py`):**
- **Environment Variables:** Check if environment variables influencing configuration (like database URLs) are correctly set or mocked during the test run.
- **Default Values:** Verify the default values in the configuration logic against what the tests expect.
- **Precedence Order:** If testing configuration precedence (e.g., env var vs. file vs. default), ensure the test setup correctly reflects the scenario being tested and that the precedence logic in the code is correct.

**For Mock Call Not Found (e.g., `Path(...) call not found` in `tests/core/engine_components/test_session_manager.py`):**
- **Mock Target:** Ensure the mock is patching the correct object and attribute.
- **Call Arguments:** Verify that the arguments with which the mocked method is expected to be called match the actual call arguments in the code under test.
- **Mock Setup:** Double-check the mock object's configuration (e.g., `MagicMock`, `AsyncMock`, `return_value`, `side_effect`).

**For Error Message Content Mismatch (e.g., in `tests/core/engine_components/test_session_manager.py`):**
- **Exact Wording:** Error messages can be sensitive to minor changes. Compare the expected substring with the actual error message produced by the code. It might be necessary to update the assertion or make the expected substring more robust (e.g., less specific if appropriate).
- **Exception Type:** Ensure the test is catching and inspecting the correct type of exception.

## Specific Error Examples
1.  `FAILED tests/cli/test_metamapper_db_cli.py::TestResourcesCommands::test_resources_list_empty - assert 1 == 0`
2.  `FAILED tests/core/test_config.py::TestConfig::test_environment_variable_loading - AssertionError: assert 'sqlite+aiosqlite:////home/ubuntu/Software-Engineer-AI-Agent-Atlas/biomapper/data/metamapper.db' == 'sqlite:///te...'`
3.  `FAILED tests/core/engine_components/test_session_manager.py::TestSessionManager::test_ensure_db_directories_sqlite - AssertionError: Path('path/to/metamapper.db') call not found`
4.  `FAILED tests/core/engine_components/test_session_manager.py::TestSessionManager::test_ensure_db_directories_error_handling - assert 'Error ensuring directory for sqlite:///test.db: Test error' in 'call("Error ensuring directory for sqlite:///test.db: type objec...'`
## Specific Error Examples
1.  `FAILED examples/tutorials/test_gemini.py::test_gemini_api - requests.exceptions.MissingSchema: Invalid URL 'None': No scheme supplied. Perhaps you meant https://None?`
2.  `ERROR tests/embedder/test_qdrant_store.py::TestQdrantVectorStoreScores::test_search_returns_similarity_scores - TypeError: Can't instantiate abstract class QdrantVectorStore with abstract methods add_documents, clear, get_similar`
3.  `FAILED tests/mapping/test_endpoint_mapping.py::test_relationship_mapping - sqlite3.OperationalError: unable to open database file`
4.  `FAILED tests/mvp0_pipeline/test_qdrant_search.py::TestQdrantSearch::test_search_successful_with_scores - pydantic_core._pydantic_core.ValidationError: 1 validation error for MappingOutput`
5.  `FAILED tests/spoke/test_graph_analyzer.py::test_discover_node_types_spoke_style - AttributeError: 'NoneType' object has no attribute 'collections'`
6.  `FAILED tests/unit/core/test_action_loader.py::TestActionLoader::test_instantiate_action - biomapper.core.exceptions.ConfigurationError: [CONFIGURATION_ERROR] Failed to instantiate action 'TEST_ACTION': MockAction() takes no ar...`
Fix SQLite operational errors related to missing tables (specifically `entity_mappings`) and address SQLAlchemy 2.0 compatibility issues for raw SQL queries in tests related to caching and metadata.
Address `ModuleNotFoundError` for `scripts.populate_metamapper_db` in integration tests and fix `TypeError`s related to asynchronous context managers in `StrategyOrchestrator` tests.

## Affected Files/Modules
- `tests/cache/test_cached_mapper.py`
- `tests/cache/test_manager.py`
- `tests/core/test_metadata_fields.py`
- `tests/core/test_metadata_impl.py`

## Common Error(s)
- `sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: entity_mappings`
- `sqlalchemy.exc.ArgumentError: Textual SQL expression 'DELETE FROM entity_mappin...' should be explicitly declared as text('DELETE FROM e...')`

## Background/Context
The `entity_mappings` table, crucial for caching, appears to be missing or inaccessible during certain test executions. This could be due to issues with test database setup, schema creation, or session management within the tests.

Additionally, SQLAlchemy 2.0 has enforced stricter handling of raw SQL strings. Queries executed directly (not through the ORM's expression language) must now be explicitly wrapped with `text()` to be recognized as SQL statements.

## Debugging Guidance/Hypotheses

**For `no such table: entity_mappings`:**
- **Test Database Setup:** Verify how the test database is initialized. Is it an in-memory SQLite database (`sqlite:///:memory:`) or a file-based one? Ensure consistency.
- **Schema Creation:** Confirm that `Base.metadata.create_all(engine)` (or its async equivalent) is called correctly before tests that interact with the database are run. This is essential for creating all defined tables.
- **Session Scope:** Check if test sessions are correctly scoped and if schema creation happens within the right context for the test's session to see the tables.
- **Fixtures:** Review pytest fixtures responsible for database setup (e.g., `engine`, `session` fixtures) to ensure they correctly set up and tear down the database environment, including table creation.

**For `ArgumentError: Textual SQL expression ... should be explicitly declared as text(...)`:**
- **Import `text`:** Ensure `from sqlalchemy import text` is present in the relevant files.
- **Wrap SQL Strings:** Locate all raw SQL strings used in functions like `session.execute()` and wrap them with the `text()` construct. For example, `session.execute("DELETE FROM entity_mappings")` should become `session.execute(text("DELETE FROM entity_mappings"))`.

## Specific Error Examples
1.  `FAILED tests/cache/test_cached_mapper.py::CachedMapperTest::test_batch_map_mixed_hits - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: entity_mappings`
2.  `FAILED tests/cache/test_manager.py::CacheManagerTest::test_add_mapping - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: entity_mappings`
3.  `FAILED tests/core/test_metadata_fields.py::test_cache_results_populates_metadata_fields - sqlalchemy.exc.ArgumentError: Textual SQL expression 'DELETE FROM entity_mappin...' should be explicitly declared as text('DELETE FROM e...')`
## Affected Files/Modules
- `tests/integration/test_yaml_strategy_execution.py`
- `tests/core/engine_components/test_strategy_orchestrator.py`

## Common Error(s)
- `ModuleNotFoundError: No module named 'scripts.populate_metamapper_db'`
- `TypeError: 'coroutine' object does not support the asynchronous context manager protocol`

## Background/Context
**ModuleNotFoundError:**
The `scripts` directory, containing `populate_metamapper_db.py`, is not currently configured as a Python package (it lacks `__init__.py` files). This prevents direct import of the script as a module in the integration tests. The script is likely intended to be run as a command-line tool.

**TypeError with Async Context Managers:**
Tests for `StrategyOrchestrator` are failing with `TypeError: 'coroutine' object does not support the asynchronous context manager protocol`. This typically occurs when an `async def` function that is *not* a proper asynchronous context manager is used with `async with`. An asynchronous context manager requires `__aenter__` and `__aexit__` methods, or to be a generator decorated with `@asynccontextmanager` from `contextlib`.

## Debugging Guidance/Hypotheses

**For `ModuleNotFoundError: No module named 'scripts.populate_metamapper_db'`:**
- **Option 1 (Recommended for scripts): Run as Subprocess:** Modify the integration tests to execute `populate_metamapper_db.py` using `subprocess.run()` or `asyncio.create_subprocess_exec`. This aligns with how standalone scripts are typically invoked and tested. Remember that the script auto-discovers configs and takes `--drop-all` (Memory `[631e6476-8513-4727-aa46-494041b7b79b]`).
- **Option 2 (Make `scripts` a package):** Add empty `__init__.py` files to `/home/ubuntu/Software-Engineer-AI-Agent-Atlas/biomapper/scripts/` and `/home/ubuntu/Software-Engineer-AI-Agent-Atlas/biomapper/scripts/setup_and_configuration/`. This would allow imports like `from scripts.setup_and_configuration import populate_metamapper_db`. Ensure the project root is in `sys.path` (Poetry usually handles this).
- **Investigate Test Setup:** See how `tests/integration/test_yaml_strategy_execution.py` attempts to use or invoke the script. The fix will depend on this current approach.

**For `TypeError: 'coroutine' object does not support the asynchronous context manager protocol`:**
- **Review Async Context Managers:** Examine the objects being used with `async with` in `tests/core/engine_components/test_strategy_orchestrator.py`. 
- **Check for `@asynccontextmanager`:** If the object is an async generator function intended for context management, ensure it's decorated with `@asynccontextmanager` from the `contextlib` module and uses `yield` appropriately.
- **Verify `__aenter__` and `__aexit__`:** If it's a class, ensure it correctly implements the `async def __aenter__(self):` and `async def __aexit__(self, exc_type, exc_val, exc_tb):` methods.
- **Mocking:** If mocks are involved, ensure the mock object is configured to behave like a proper async context manager (e.g., its `__aenter__` returns an awaitable, or the mock itself is an `AsyncMock` configured appropriately).

## Specific Error Examples
1.  `ERROR tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_basic_linear_strategy - ModuleNotFoundError: No module named 'scripts.populate_metamapper_db'`
2.  `FAILED tests/core/engine_components/test_strategy_orchestrator.py::TestStrategyOrchestrator::test_successful_strategy_execution - TypeError: 'coroutine' object does not support the asynchronous context manager protocol`
3.  `FAILED tests/core/engine_components/test_strategy_orchestrator.py::TestStrategyOrchestrator::test_strategy_failure_required_step - TypeError: 'coroutine' object does not support the asynchronous context manager protocol`

## Acceptance Criteria
- All tests in `tests/cli/test_metamapper_db_cli.py`, `tests/core/test_config.py`, and `tests/core/engine_components/test_session_manager.py` pass.
- Incomplete tests (those with `assert 1 == 0`) are fully implemented with valid assertions.
- Assertions related to configuration values, mock calls, and error messages accurately reflect the current behavior of the tested components.
- Core configuration loading, CLI commands, and session management functionalities are robustly tested and verified.
- All tests listed in the 'Affected Files/Modules' for this miscellaneous category pass successfully.
- Configuration issues (URLs, Pydantic models) are resolved.
- Abstract class instantiation errors are fixed by using concrete implementations or appropriate test strategies.
- Database connectivity and operational errors are addressed.
- AttributeErrors and other specific component failures are resolved through targeted debugging and test/code updates.
- All tests in the listed 'Affected Files/Modules' that previously failed with `OperationalError: no such table: entity_mappings` now pass, indicating the `entity_mappings` table is correctly created and accessible.
- All tests that previously failed with `ArgumentError: Textual SQL expression ... should be explicitly declared as text(...)` now pass, with raw SQL queries correctly adapted for SQLAlchemy 2.0.
- Database interactions within these tests are robust and schema is correctly managed.
- Integration tests in `tests/integration/test_yaml_strategy_execution.py` can successfully invoke or utilize the `populate_metamapper_db.py` script, resolving the `ModuleNotFoundError`.
- All tests in `tests/core/engine_components/test_strategy_orchestrator.py` pass, with `TypeError`s related to async context managers resolved.
- The chosen solution for the `ModuleNotFoundError` is robust and aligns with good testing practices for scripts.
- Asynchronous context managers are correctly implemented and used in the strategy orchestrator tests.
