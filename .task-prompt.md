# Task: Create Unit Tests for `ProgressReporter`
# Task: Create Unit Tests for `IdentifierLoader`
# Task: Create Unit Tests for `ConfigLoader`

## Objective
To ensure the progress reporting mechanism is reliable and robust, create unit tests for the `ProgressReporter` component.
To validate the logic for loading identifiers from various data sources, create comprehensive unit tests for the `IdentifierLoader` component.
To ensure the reliability of the strategy configuration loading mechanism, create a suite of unit tests for the `ConfigLoader` component.

## Location for Tests
Create a new test file: `tests/core/engine_components/test_progress_reporter.py`
Create a new test file: `tests/core/engine_components/test_identifier_loader.py`
Create a new test file: `tests/core/engine_components/test_config_loader.py`

## Test Strategy
- Use `pytest` and `unittest.mock.Mock` to create mock callback functions.
- The tests will be synchronous and straightforward as the component itself is not async.
- Use `pytest` and `unittest.mock` with `AsyncMock` for async methods.
- Mock the `metamapper_session_factory` to return a mock `AsyncSession`.
- The mock `AsyncSession` should return mock SQLAlchemy models (`Endpoint`, `EndpointPropertyConfig`, `PropertyExtractionConfig`) when its `execute` method is called.
- Mock filesystem interactions (`os.path.exists`) and data loading (`pandas.read_csv`).
- Use `pytest` and `unittest.mock` for testing.
- Mock filesystem interactions (`open`, `os.path.exists`) to simulate the presence, absence, and content of YAML configuration files without needing real files.

## Test Cases

1.  **Test Initialization:**
    - Instantiate `ProgressReporter` with an initial callback and verify it's added.
    - Instantiate `ProgressReporter` with no initial callback and verify the callback list is empty.

2.  **Test `add_callback`:**
    - Add a valid callback and check that `has_callbacks` is `True`.
    - Add the same callback again and verify it is not duplicated in the list.

3.  **Test `remove_callback`:**
    - Add a callback, then remove it. Verify the callback list is empty.
    - Attempt to remove a callback that was never added and ensure no errors occur.

4.  **Test `report`:**
    - Register multiple mock callbacks.
    - Call `report` with sample data.
    - Assert that each mock callback was called exactly once with the correct data.

5.  **Test `report` with Failing Callback:**
    - Register two mock callbacks, one of which raises an exception.
    - Call `report` and assert that the non-failing callback was still called.

6.  **Test `clear_callbacks`:**
    - Add multiple callbacks, call `clear_callbacks`, and assert that `has_callbacks` is `False`.

7.  **Test `has_callbacks` Property:**
    - Assert it returns `False` when no callbacks are registered.
    - Assert it returns `True` when at least one callback is registered.
### `get_ontology_column`
1.  **Test Successful Lookup:** Mock the full chain of database objects and assert that the correct column name is returned from the mock `extraction_pattern`.
2.  **Test Endpoint Not Found:** Mock the session to return `None` for the `Endpoint` query. Assert a `ConfigurationError` is raised.
3.  **Test Property Config Not Found:** Mock the session to return `None` for the `EndpointPropertyConfig` query. Assert a `ConfigurationError` is raised.

### `load_endpoint_identifiers`
1.  **Test Successful Load (as List):** Mock a successful database and file lookup. Assert that a list of unique identifiers is returned.
2.  **Test Successful Load (as DataFrame):** Call with `return_dataframe=True` and assert that the mock DataFrame is returned.
3.  **Test File Not Found:** Mock `os.path.exists` to return `False`. Assert `FileNotFoundError` is raised.
4.  **Test Column Not Found:** Mock a DataFrame that is missing the required identifier column. Assert `KeyError` is raised.
5.  **Test Placeholder Resolution:** Verify that `resolve_placeholders` is called with the file path from the mock `Endpoint` configuration.

## Acceptance Criteria
- A new test file `tests/core/engine_components/test_identifier_loader.py` is created.
- The tests use async mocks to validate the asynchronous database logic.
- The tests cover all public methods and their primary success and failure modes.
- All tests pass successfully.
1.  **Test Successful Loading (.yaml):**
    - Mock a valid `strategy.yaml` file.
    - Call `load_strategy` and assert that the returned dictionary matches the mock file's content.

2.  **Test Successful Loading (.yml fallback):**
    - Mock `os.path.exists` to return `False` for `strategy.yaml` but `True` for `strategy.yml`.
    - Assert that `load_strategy` successfully loads from the `.yml` file.

3.  **Test Strategy Not Found:**
    - Mock `os.path.exists` to return `False` for both `.yaml` and `.yml` files.
    - Assert that `load_strategy` raises a `ConfigurationError`.

4.  **Test Malformed YAML:**
    - Mock the content of a YAML file to be invalid (e.g., incorrect indentation).
    - Assert that `load_strategy` catches the `yaml.YAMLError` and raises a `ConfigurationError`.

5.  **Test Invalid Config Format:**
    - Mock a YAML file whose root element is not a dictionary (e.g., a list).
    - Assert that `load_strategy` raises a `ConfigurationError`.

6.  **Test Name Injection:**
    - Mock a valid strategy config that is missing the top-level `name` key.
    - Call `load_strategy` and assert that the strategy name is correctly added to the resulting dictionary.

## Acceptance Criteria
- A new test file `tests/core/engine_components/test_progress_reporter.py` is created.
- The tests cover all public methods and properties of the `ProgressReporter` class.
- All tests pass successfully.
- A new test file `tests/core/engine_components/test_config_loader.py` is created.
- The tests cover all public methods of the `ConfigLoader` class and its primary error conditions.
- All tests pass successfully.
