Running pytest with safety measures...
Running main test suite (excluding problematic tests)...
============================= test session starts ==============================
platform linux -- Python 3.11.7, pytest-7.4.4, pluggy-1.5.0 -- /home/trentleslie/.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/bin/python
rootdir: /home/trentleslie/github/biomapper
configfile: pytest.ini
plugins: mock-3.14.0, anyio-4.8.0, asyncio-0.21.2, requests-mock-1.12.1, cov-4.1.0
asyncio: mode=Mode.AUTO
collecting ... collected 1136 items

examples/tutorials/test_gemini.py::test_gemini_api SKIPPED (GEMINI_A...) [  0%]
examples/tutorials/test_gemini.py::test_gemini_api_mocked PASSED         [  0%]
tests/test_yaml_strategy_provenance.py::TestYAMLStrategyProvenanceTracking::test_trace_mapping_chain_simple PASSED [  0%]
tests/test_yaml_strategy_provenance.py::TestYAMLStrategyProvenanceTracking::test_trace_mapping_chain_with_filter PASSED [  0%]
tests/test_yaml_strategy_provenance.py::TestYAMLStrategyProvenanceTracking::test_provenance_vs_position_mapping PASSED [  0%]
tests/cache/test_manager.py::CacheManagerTest::test_add_mapping PASSED   [  0%]
tests/cache/test_manager.py::CacheManagerTest::test_add_mapping_with_metadata PASSED [  0%]
tests/cache/test_manager.py::CacheManagerTest::test_bidirectional_lookup PASSED [  0%]
tests/cache/test_manager.py::CacheManagerTest::test_cache_stats PASSED   [  0%]
tests/cache/test_manager.py::CacheManagerTest::test_delete_expired_mappings PASSED [  0%]
tests/cache/test_manager.py::CacheManagerTest::test_lookup PASSED        [  0%]
tests/cli/test_metamapper_db_cli.py::TestResourcesCommands::test_resources_list_empty PASSED [  1%]
tests/cli/test_metamapper_db_cli.py::TestResourcesCommands::test_resources_list_json_output PASSED [  1%]
tests/cli/test_metamapper_db_cli.py::TestResourcesCommands::test_show_resource_not_found PASSED [  1%]
tests/cli/test_metamapper_db_cli.py::TestPathsCommands::test_find_paths_no_results PASSED [  1%]
tests/cli/test_metamapper_db_cli.py::TestValidationCommands::test_validate_clients_empty PASSED [  1%]
tests/cli/test_metamapper_db_cli.py::TestCLIIntegration::test_cli_help PASSED [  1%]
tests/cli/test_metamapper_db_cli.py::TestCLIIntegration::test_resources_help PASSED [  1%]
tests/cli/test_metamapper_db_cli.py::TestCLIIntegration::test_paths_help PASSED [  1%]
tests/cli/test_metamapper_db_cli.py::TestCLIIntegration::test_validate_help PASSED [  1%]
tests/core/test_alternate_mapping.py::test_various_db_combinations PASSED [  1%]
tests/core/test_base_llm.py::TestLLMConfig::test_valid_config PASSED     [  1%]
tests/core/test_base_llm.py::TestLLMConfig::test_invalid_temperature PASSED [  2%]
tests/core/test_base_llm.py::TestLLMConfig::test_invalid_max_tokens PASSED [  2%]
tests/core/test_base_llm.py::TestLLMConfig::test_config_immutable PASSED [  2%]
tests/core/test_base_llm.py::TestInsightType::test_valid_insight PASSED  [  2%]
tests/core/test_base_llm.py::TestInsightType::test_invalid_confidence PASSED [  2%]
tests/core/test_base_llm.py::TestInsightType::test_default_values PASSED [  2%]
tests/core/test_base_llm.py::TestAnalysisResult::test_valid_result PASSED [  2%]
tests/core/test_base_llm.py::TestAnalysisResult::test_empty_result PASSED [  2%]
tests/core/test_base_llm.py::TestBaseLLMAnalyzer::test_mock_analyzer PASSED [  2%]
tests/core/test_base_llm.py::TestBaseLLMAnalyzer::test_prompt_generation PASSED [  2%]
tests/core/test_base_llm.py::TestBaseLLMAnalyzer::test_response_processing PASSED [  2%]
tests/core/test_base_llm.py::test_llm_error PASSED                       [  2%]
tests/core/test_base_spoke.py::TestSPOKEConfig::test_valid_config PASSED [  3%]
tests/core/test_base_spoke.py::TestSPOKEConfig::test_invalid_timeout PASSED [  3%]
tests/core/test_base_spoke.py::TestSPOKEConfig::test_invalid_retries PASSED [  3%]
tests/core/test_base_spoke.py::TestSPOKEConfig::test_config_immutable PASSED [  3%]
tests/core/test_base_spoke.py::TestSPOKEEntity::test_valid_entity PASSED [  3%]
tests/core/test_base_spoke.py::TestSPOKEEntity::test_invalid_confidence PASSED [  3%]
tests/core/test_base_spoke.py::TestSPOKEEntity::test_invalid_node_type PASSED [  3%]
tests/core/test_base_spoke.py::TestSPOKEEntity::test_default_values PASSED [  3%]
tests/core/test_base_spoke.py::TestSPOKERelation::test_valid_relation PASSED [  3%]
tests/core/test_base_spoke.py::TestSPOKERelation::test_empty_properties PASSED [  3%]
tests/core/test_base_spoke.py::TestSPOKERelation::test_default_confidence PASSED [  3%]
tests/core/test_base_spoke.py::TestAQLQuery::test_valid_query PASSED     [  4%]
tests/core/test_base_spoke.py::TestAQLQuery::test_empty_parameters PASSED [  4%]
tests/core/test_base_spoke.py::TestSPOKEMappingResult::test_valid_result PASSED [  4%]
tests/core/test_base_spoke.py::TestSPOKEMappingResult::test_mapping_rate PASSED [  4%]
tests/core/test_base_spoke.py::TestSPOKEMappingResult::test_empty_result PASSED [  4%]
tests/core/test_base_spoke.py::TestBaseSPOKEMapper::test_mock_mapper PASSED [  4%]
tests/core/test_base_spoke.py::TestBaseSPOKEMapper::test_pathway_analysis PASSED [  4%]
tests/core/test_base_spoke.py::test_spoke_error PASSED                   [  4%]
tests/core/test_bidirectional_mapping_optimization.py::TestBidirectionalMappingOptimization::test_path_caching PASSED [  4%]
tests/core/test_bidirectional_mapping_optimization.py::TestBidirectionalMappingOptimization::test_concurrent_batch_processing PASSED [  4%]
tests/core/test_bidirectional_mapping_optimization.py::TestBidirectionalMappingOptimization::test_metrics_tracking PASSED [  4%]
tests/core/test_bidirectional_mapping_optimization.py::TestIntegrationOptimizedBidirectionalMapping::test_bidirectional_path_finding PASSED [  5%]
tests/core/test_bidirectional_mapping_optimization.py::TestIntegrationOptimizedBidirectionalMapping::test_path_execution_with_filtering PASSED [  5%]
tests/core/test_bidirectional_mapping_optimization.py::TestIntegrationOptimizedBidirectionalMapping::test_reversible_path_priority PASSED [  5%]
tests/core/test_composite_handler.py::TestCompositeIdentifierHandler::test_initialize PASSED [  5%]
tests/core/test_composite_handler.py::TestCompositeIdentifierHandler::test_has_patterns_for_ontology PASSED [  5%]
tests/core/test_composite_handler.py::TestCompositeIdentifierHandler::test_is_composite PASSED [  5%]
tests/core/test_composite_handler.py::TestCompositeIdentifierHandler::test_split_composite PASSED [  5%]
tests/core/test_composite_handler.py::TestCompositeMiddleware::test_preprocess_identifiers PASSED [  5%]
tests/core/test_composite_handler.py::TestCompositeMiddleware::test_aggregate_results_first_match PASSED [  5%]
tests/core/test_composite_handler.py::TestCompositeMiddleware::test_aggregate_results_all_matches PASSED [  5%]
tests/core/test_composite_handler.py::TestCompositeMiddleware::test_aggregate_results_no_matches PASSED [  5%]
tests/core/test_config.py::TestConfig::test_singleton_pattern PASSED     [  5%]
tests/core/test_config.py::TestConfig::test_get_defaults PASSED          [  6%]
tests/core/test_config.py::TestConfig::test_environment_variable_loading PASSED [  6%]
tests/core/test_config.py::TestConfig::test_file_loading PASSED          [  6%]
tests/core/test_config.py::TestConfig::test_precedence_order PASSED      [  6%]
tests/core/test_config.py::TestConfig::test_get_with_default PASSED      [  6%]
tests/core/test_config.py::TestConfig::test_get_all PASSED               [  6%]
tests/core/test_config.py::TestConfig::test_set_for_testing PASSED       [  6%]
tests/core/test_config.py::TestConfig::test_nested_keys PASSED           [  6%]
tests/core/test_config.py::TestConfig::test_type_conversion PASSED       [  6%]
tests/core/test_execution_lifecycle_service.py::test_save_checkpoint PASSED [  6%]
tests/core/test_execution_lifecycle_service.py::test_load_checkpoint PASSED [  6%]
tests/core/test_execution_lifecycle_service.py::test_report_progress PASSED [  7%]
tests/core/test_execution_lifecycle_service.py::test_report_progress_with_metrics PASSED [  7%]
tests/core/test_execution_lifecycle_service.py::test_add_progress_callback PASSED [  7%]
tests/core/test_execution_lifecycle_service.py::test_remove_progress_callback PASSED [  7%]
tests/core/test_execution_lifecycle_service.py::test_report_progress_with_callbacks PASSED [  7%]
tests/core/test_execution_lifecycle_service.py::test_start_execution PASSED [  7%]
tests/core/test_execution_lifecycle_service.py::test_complete_execution PASSED [  7%]
tests/core/test_execution_lifecycle_service.py::test_fail_execution PASSED [  7%]
tests/core/test_execution_lifecycle_service.py::test_report_batch_progress PASSED [  7%]
tests/core/test_execution_lifecycle_service.py::test_save_batch_checkpoint PASSED [  7%]
tests/core/test_execution_lifecycle_service.py::test_get_checkpoint_directory PASSED [  7%]
tests/core/test_execution_lifecycle_service.py::test_set_checkpoint_directory PASSED [  8%]
tests/core/test_mapping_executor_cache_skipped.py::test_cache_tests_skipped SKIPPED [  8%]
tests/core/test_mapping_executor_handlers.py::test_handle_convert_identifiers_local_success FAILED [  8%]
tests/core/test_mapping_executor_handlers.py::test_handle_execute_mapping_path_success PASSED [  8%]
tests/core/test_mapping_executor_handlers.py::test_handle_filter_identifiers_by_target_presence_success PASSED [  8%]
tests/core/test_mapping_executor_lifecycle.py::test_async_dispose PASSED [  8%]
tests/core/test_mapping_executor_lifecycle.py::test_save_checkpoint PASSED [  8%]
tests/core/test_mapping_executor_lifecycle.py::test_load_checkpoint PASSED [  8%]
tests/core/test_mapping_executor_lifecycle.py::test_start_session PASSED [  8%]
tests/core/test_mapping_executor_lifecycle.py::test_end_session PASSED   [  8%]
tests/core/test_mapping_executor_mapping.py::test_execute_mapping_success PASSED [  8%]
tests/core/test_mapping_executor_mapping.py::test_execute_mapping_no_path_found PASSED [  8%]
tests/core/test_mapping_executor_mapping.py::test_execute_mapping_empty_input PASSED [  9%]
tests/core/test_mapping_executor_mapping.py::test_execute_path_integration PASSED [  9%]
tests/core/test_mapping_executor_strategy.py::test_execute_strategy PASSED [  9%]
tests/core/test_mapping_executor_strategy.py::test_execute_yaml_strategy PASSED [  9%]
tests/core/test_mapping_executor_strategy.py::test_execute_robust_yaml_strategy PASSED [  9%]
tests/core/test_mapping_executor_strategy.py::test_get_strategy PASSED   [  9%]
tests/core/test_metadata_fields.py::test_cache_results_populates_metadata_fields PASSED [  9%]
tests/core/test_metadata_fields.py::test_confidence_score_calculation PASSED [  9%]
tests/core/test_metadata_fields.py::test_mapping_path_details_contents PASSED [  9%]
tests/core/test_metadata_impl.py::test_cache_results_populates_metadata_fields PASSED [  9%]
tests/core/test_metadata_impl.py::test_confidence_score_calculation PASSED [  9%]
tests/core/test_metadata_impl.py::test_mapping_path_details_contents PASSED [ 10%]
tests/core/test_metadata_population.py::test_cache_results_populates_metadata_fields PASSED [ 10%]
tests/core/test_metadata_population.py::test_confidence_score_calculation PASSED [ 10%]
tests/core/test_metadata_population.py::test_mapping_path_details_contents PASSED [ 10%]
tests/core/test_metadata_population.py::test_cache_results_handles_errors PASSED [ 10%]
tests/core/test_path_execution_manager.py::test_run_path_steps_basic PASSED [ 10%]
tests/core/test_path_execution_manager.py::test_execute_path_multi_step PASSED [ 10%]
tests/core/test_protein_metadata_comparison.py::test_process_protein_with_invalid_to_id PASSED [ 10%]
tests/core/test_protein_metadata_comparison.py::test_process_protein_with_missing_to_field PASSED [ 10%]
tests/core/test_protein_metadata_comparison.py::test_process_protein_with_empty_results PASSED [ 10%]
tests/core/test_protein_metadata_comparison.py::test_process_chunk_with_mixed_results PASSED [ 10%]
tests/core/test_protein_metadata_comparison.py::test_process_chunk_with_errors PASSED [ 11%]
tests/core/test_protein_metadata_comparison.py::test_process_chunk_with_invalid_response PASSED [ 11%]
tests/core/test_protein_metadata_comparison.py::test_process_chunk_mapping_error PASSED [ 11%]
tests/core/test_protein_metadata_comparison.py::test_process_chunk_causes_exception PASSED [ 11%]
tests/core/test_protein_metadata_comparison.py::test_process_chunk_error_handling PASSED [ 11%]
tests/core/test_set_analysis.py::test_load_dataset PASSED                [ 11%]
tests/core/test_set_analysis.py::test_detect_id_column PASSED            [ 11%]
tests/core/test_set_analysis.py::test_analyze PASSED                     [ 11%]
tests/core/test_set_analysis.py::test_id_column_update PASSED            [ 11%]
tests/core/test_set_analysis.py::test_plot_venn PASSED                   [ 11%]
tests/core/test_set_analysis.py::test_plot_upset PASSED                  [ 11%]
tests/core/test_set_analysis.py::test_generate_report PASSED             [ 11%]
tests/core/test_set_analysis.py::test_error_cases PASSED                 [ 12%]
tests/core/engine_components/test_managers.py::TestCheckpointManager::test_save_checkpoint PASSED [ 12%]
tests/core/engine_components/test_managers.py::TestCheckpointManager::test_load_checkpoint PASSED [ 12%]
tests/core/engine_components/test_managers.py::TestCheckpointManager::test_clear_checkpoint PASSED [ 12%]
tests/core/engine_components/test_managers.py::TestCheckpointManager::test_load_nonexistent_checkpoint PASSED [ 12%]
tests/core/engine_components/test_managers.py::TestCheckpointManager::test_checkpoint_directory_creation PASSED [ 12%]
tests/core/engine_components/test_managers.py::TestCheckpointManager::test_default_checkpoint_directory PASSED [ 12%]
tests/core/engine_components/test_managers.py::TestCheckpointManager::test_checkpoint_disabled PASSED [ 12%]
tests/core/engine_components/test_managers.py::TestCheckpointManager::test_save_checkpoint_with_error PASSED [ 12%]
tests/core/engine_components/test_managers.py::TestCheckpointManager::test_load_checkpoint_with_corrupt_file PASSED [ 12%]
tests/core/engine_components/test_managers.py::TestCheckpointManager::test_atomic_save PASSED [ 12%]
tests/core/engine_components/test_managers.py::TestCheckpointManager::test_progress_callbacks PASSED [ 13%]
tests/core/engine_components/test_managers.py::TestCheckpointManager::test_progress_callback_error_handling PASSED [ 13%]
tests/core/engine_components/test_managers.py::TestCheckpointManager::test_current_checkpoint_file_property PASSED [ 13%]
tests/core/engine_components/test_managers.py::TestCheckpointManager::test_clear_nonexistent_checkpoint PASSED [ 13%]
tests/core/engine_components/test_managers.py::TestCheckpointManager::test_clear_checkpoint_with_error PASSED [ 13%]
tests/core/engine_components/test_managers.py::TestCheckpointManager::test_get_checkpoint_file_without_dir PASSED [ 13%]
tests/core/engine_components/test_managers.py::TestCheckpointManager::test_multiple_checkpoints PASSED [ 13%]
tests/core/engine_components/test_managers.py::TestClientManager::test_client_instantiation PASSED [ 13%]
tests/core/engine_components/test_managers.py::TestClientManager::test_client_caching PASSED [ 13%]
tests/core/engine_components/test_managers.py::TestClientManager::test_different_configurations PASSED [ 13%]
tests/core/engine_components/test_managers.py::TestClientManager::test_invalid_class_path PASSED [ 13%]
tests/core/engine_components/test_managers.py::TestClientManager::test_missing_class_in_module PASSED [ 13%]
tests/core/engine_components/test_managers.py::TestClientManager::test_missing_configuration PASSED [ 14%]
tests/core/engine_components/test_managers.py::TestClientManager::test_invalid_json_config PASSED [ 14%]
tests/core/engine_components/test_managers.py::TestClientManager::test_client_initialization_error PASSED [ 14%]
tests/core/engine_components/test_managers.py::TestClientManager::test_client_without_config PASSED [ 14%]
tests/core/engine_components/test_managers.py::TestClientManager::test_get_client_cache PASSED [ 14%]
tests/core/engine_components/test_managers.py::TestClientManager::test_clear_cache PASSED [ 14%]
tests/core/engine_components/test_managers.py::TestClientManager::test_get_cache_size PASSED [ 14%]
tests/core/engine_components/test_managers.py::TestClientManager::test_cache_key_generation PASSED [ 14%]
tests/core/engine_components/test_managers.py::TestClientManager::test_logging_optimization_messages PASSED [ 14%]
tests/core/engine_components/test_mapping_executor_builder.py::TestMappingExecutorBuilder::test_builder_initialization PASSED [ 14%]
tests/core/engine_components/test_mapping_executor_builder.py::TestMappingExecutorBuilder::test_build_creates_executor PASSED [ 14%]
tests/core/engine_components/test_mapping_executor_builder.py::TestMappingExecutorBuilder::test_build_async_initializes_database PASSED [ 15%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_init_with_default_settings PASSED [ 15%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_init_with_custom_parameters PASSED [ 15%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_initialize_core_components PASSED [ 15%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_initialize_session_manager PASSED [ 15%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_initialize_cache_manager_success PASSED [ 15%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_initialize_cache_manager_no_session_manager_error PASSED [ 15%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_initialize_execution_components PASSED [ 15%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_initialize_metrics_tracking_enabled PASSED [ 15%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_initialize_metrics_tracking_disabled PASSED [ 15%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_initialize_metrics_tracking_import_error PASSED [ 15%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_get_convenience_references_success PASSED [ 16%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_get_convenience_references_no_session_manager_error PASSED [ 16%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_set_executor_function_references PASSED [ 16%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_set_executor_function_references_no_path_execution_manager PASSED [ 16%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_init_db_tables_success PASSED [ 16%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_init_db_tables_tables_already_exist PASSED [ 16%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_init_db_tables_error_handling PASSED [ 16%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_create_executor_success PASSED [ 16%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_create_executor_mapping_executor_creation_error PASSED [ 16%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_create_executor_db_init_error PASSED [ 16%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_initialize_components_success PASSED [ 16%]
tests/core/engine_components/test_mapping_executor_initializer.py::TestMappingExecutorInitializer::test_initialize_components_error_handling PASSED [ 16%]
tests/core/engine_components/test_path_finder.py::TestPathFinder::test_find_mapping_paths_returns_direct_path PASSED [ 17%]
tests/core/engine_components/test_path_finder.py::TestPathFinder::test_find_mapping_paths_returns_multi_step_path PASSED [ 17%]
tests/core/engine_components/test_path_finder.py::TestPathFinder::test_find_mapping_paths_returns_empty_when_no_paths_exist PASSED [ 17%]
tests/core/engine_components/test_path_finder.py::TestPathFinder::test_find_mapping_paths_orders_by_priority PASSED [ 17%]
tests/core/engine_components/test_path_finder.py::TestPathFinder::test_get_path_details_returns_complete_step_information PASSED [ 17%]
tests/core/engine_components/test_path_finder.py::TestPathFinder::test_get_path_details_not_found PASSED [ 17%]
tests/core/engine_components/test_path_finder.py::TestPathFinder::test_get_path_details_database_error PASSED [ 17%]
tests/core/engine_components/test_path_finder.py::TestPathFinder::test_behavioral_path_caching_demonstrates_performance_optimization PASSED [ 17%]
tests/core/engine_components/test_path_finder.py::TestPathFinder::test_path_caching_behavior PASSED [ 17%]
tests/core/engine_components/test_path_finder.py::TestPathFinder::test_find_best_path_returns_highest_priority_path PASSED [ 17%]
tests/core/engine_components/test_path_finder.py::TestPathFinder::test_find_best_path_returns_none_when_no_paths_exist PASSED [ 17%]
tests/core/engine_components/test_path_finder.py::TestPathFinder::test_cache_distinguishes_parameters PASSED [ 18%]
tests/core/engine_components/test_path_finder.py::TestPathFinder::test_cache_expiry_behavior PASSED [ 18%]
tests/core/engine_components/test_path_finder.py::TestPathFinder::test_bidirectional_search_with_endpoints PASSED [ 18%]
tests/core/engine_components/test_path_finder.py::TestPathFinder::test_find_direct_paths_complex_query PASSED [ 18%]
tests/core/engine_components/test_path_finder.py::TestPathFinder::test_reversible_path_priority_adjustment PASSED [ 18%]
tests/core/engine_components/test_path_finder.py::TestPathFinder::test_clear_cache_functionality PASSED [ 18%]
tests/core/engine_components/test_path_finder.py::TestPathFinder::test_error_propagation_from_database PASSED [ 18%]
tests/core/engine_components/test_path_finder.py::TestPathFinderIntegration::test_complete_mapping_workflow_with_caching_and_best_path_selection PASSED [ 18%]
tests/core/engine_components/test_progress_reporter.py::TestProgressReporter::test_initialization_with_callback PASSED [ 18%]
tests/core/engine_components/test_progress_reporter.py::TestProgressReporter::test_initialization_without_callback PASSED [ 18%]
tests/core/engine_components/test_progress_reporter.py::TestProgressReporter::test_add_callback PASSED [ 18%]
tests/core/engine_components/test_progress_reporter.py::TestProgressReporter::test_add_duplicate_callback PASSED [ 19%]
tests/core/engine_components/test_progress_reporter.py::TestProgressReporter::test_remove_callback PASSED [ 19%]
tests/core/engine_components/test_progress_reporter.py::TestProgressReporter::test_remove_nonexistent_callback PASSED [ 19%]
tests/core/engine_components/test_progress_reporter.py::TestProgressReporter::test_report_multiple_callbacks PASSED [ 19%]
tests/core/engine_components/test_progress_reporter.py::TestProgressReporter::test_report_with_failing_callback PASSED [ 19%]
tests/core/engine_components/test_progress_reporter.py::TestProgressReporter::test_clear_callbacks PASSED [ 19%]
tests/core/engine_components/test_progress_reporter.py::TestProgressReporter::test_has_callbacks_property PASSED [ 19%]
tests/core/engine_components/test_progress_reporter.py::TestProgressReporter::test_add_none_callback PASSED [ 19%]
tests/core/engine_components/test_progress_reporter.py::TestProgressReporter::test_callback_exception_logging PASSED [ 19%]
tests/core/engine_components/test_robust_execution_coordinator.py::TestRobustExecutionCoordinatorInit::test_init_with_all_parameters PASSED [ 19%]
tests/core/engine_components/test_robust_execution_coordinator.py::TestRobustExecutionCoordinatorInit::test_init_with_default_parameters PASSED [ 19%]
tests/core/engine_components/test_robust_execution_coordinator.py::TestRobustExecutionCoordinatorExecuteStrategyRobustly::test_successful_execution_no_checkpoint PASSED [ 19%]
tests/core/engine_components/test_robust_execution_coordinator.py::TestRobustExecutionCoordinatorExecuteStrategyRobustly::test_successful_execution_with_checkpoint PASSED [ 20%]
tests/core/engine_components/test_robust_execution_coordinator.py::TestRobustExecutionCoordinatorExecuteStrategyRobustly::test_execution_failure_no_checkpoint_save PASSED [ 20%]
tests/core/engine_components/test_robust_execution_coordinator.py::TestRobustExecutionCoordinatorExecuteStrategyRobustly::test_execution_failure_with_checkpoint_available PASSED [ 20%]
tests/core/engine_components/test_robust_execution_coordinator.py::TestRobustExecutionCoordinatorExecuteStrategyRobustly::test_execution_id_generation PASSED [ 20%]
tests/core/engine_components/test_robust_execution_coordinator.py::TestRobustExecutionCoordinatorExecuteStrategyRobustly::test_execution_id_provided PASSED [ 20%]
tests/core/engine_components/test_robust_execution_coordinator.py::TestRobustExecutionCoordinatorExecuteStrategyRobustly::test_checkpoint_disabled_no_operations PASSED [ 20%]
tests/core/engine_components/test_robust_execution_coordinator.py::TestRobustExecutionCoordinatorExecuteWithRetry::test_successful_execution_first_attempt PASSED [ 20%]
tests/core/engine_components/test_robust_execution_coordinator.py::TestRobustExecutionCoordinatorExecuteWithRetry::test_successful_execution_after_retries PASSED [ 20%]
tests/core/engine_components/test_robust_execution_coordinator.py::TestRobustExecutionCoordinatorExecuteWithRetry::test_permanent_failure_after_max_retries PASSED [ 20%]
tests/core/engine_components/test_robust_execution_coordinator.py::TestRobustExecutionCoordinatorInteractionWithDependencies::test_correct_method_call_order_success PASSED [ 20%]
tests/core/engine_components/test_robust_execution_coordinator.py::TestRobustExecutionCoordinatorInteractionWithDependencies::test_checkpoint_manager_called_with_correct_arguments PASSED [ 20%]
tests/core/engine_components/test_robust_execution_coordinator.py::TestRobustExecutionCoordinatorInteractionWithDependencies::test_strategy_orchestrator_called_with_correct_arguments PASSED [ 21%]
tests/core/engine_components/test_robust_execution_coordinator.py::TestRobustExecutionCoordinatorInteractionWithDependencies::test_progress_reporter_called_with_correct_data PASSED [ 21%]
tests/core/engine_components/test_session_manager.py::TestSessionManager::test_initialization PASSED [ 21%]
tests/core/engine_components/test_session_manager.py::TestSessionManager::test_get_async_url_sqlite PASSED [ 21%]
tests/core/engine_components/test_session_manager.py::TestSessionManager::test_get_async_url_non_sqlite PASSED [ 21%]
tests/core/engine_components/test_session_manager.py::TestSessionManager::test_ensure_db_directories_sqlite PASSED [ 21%]
tests/core/engine_components/test_session_manager.py::TestSessionManager::test_ensure_db_directories_non_sqlite PASSED [ 21%]
tests/core/engine_components/test_session_manager.py::TestSessionManager::test_get_async_metamapper_session PASSED [ 21%]
tests/core/engine_components/test_session_manager.py::TestSessionManager::test_get_async_cache_session PASSED [ 21%]
tests/core/engine_components/test_session_manager.py::TestSessionManager::test_async_metamapper_session_property PASSED [ 21%]
tests/core/engine_components/test_session_manager.py::TestSessionManager::test_async_cache_session_property PASSED [ 21%]
tests/core/engine_components/test_session_manager.py::TestSessionManager::test_ensure_db_directories_error_handling PASSED [ 22%]
tests/core/engine_components/test_session_manager.py::TestSessionManager::test_ensure_db_directories_malformed_url PASSED [ 22%]
tests/core/engine_components/test_strategy_orchestrator.py::TestStrategyOrchestrator::test_successful_strategy_execution PASSED [ 22%]
tests/core/engine_components/test_strategy_orchestrator.py::TestStrategyOrchestrator::test_strategy_failure_required_step PASSED [ 22%]
tests/core/engine_components/test_strategy_orchestrator.py::TestStrategyOrchestrator::test_strategy_failure_optional_step PASSED [ 22%]
tests/core/engine_components/test_strategy_orchestrator.py::TestStrategyOrchestrator::test_placeholder_resolution_in_context PASSED [ 22%]
tests/core/engine_components/test_strategy_orchestrator.py::TestStrategyOrchestrator::test_context_updates_between_steps PASSED [ 22%]
tests/core/engine_components/test_strategy_orchestrator.py::TestStrategyOrchestrator::test_result_bundle_finalization PASSED [ 22%]
tests/core/engine_components/test_strategy_orchestrator.py::TestStrategyOrchestrator::test_inactive_step_skipped PASSED [ 22%]
tests/core/engine_components/test_strategy_orchestrator.py::TestStrategyOrchestrator::test_progress_callback_invocation PASSED [ 22%]
tests/core/engine_components/test_strategy_orchestrator.py::TestStrategyOrchestrator::test_empty_identifiers_stops_execution PASSED [ 22%]
tests/core/engine_components/test_strategy_orchestrator.py::TestStrategyOrchestrator::test_endpoint_not_found_error PASSED [ 22%]
tests/core/engine_components/test_strategy_orchestrator.py::TestStrategyOrchestrator::test_complex_provenance_chain PASSED [ 23%]
tests/core/models/test_result_bundle.py::TestMappingResultBundle::test_initialization PASSED [ 23%]
tests/core/models/test_result_bundle.py::TestMappingResultBundle::test_add_step_result_success PASSED [ 23%]
tests/core/models/test_result_bundle.py::TestMappingResultBundle::test_add_step_result_failure PASSED [ 23%]
tests/core/models/test_result_bundle.py::TestMappingResultBundle::test_add_step_result_with_sampling PASSED [ 23%]
tests/core/models/test_result_bundle.py::TestMappingResultBundle::test_finalize_success PASSED [ 23%]
tests/core/models/test_result_bundle.py::TestMappingResultBundle::test_finalize_failure PASSED [ 23%]
tests/core/models/test_result_bundle.py::TestMappingResultBundle::test_to_dict_finalized PASSED [ 23%]
tests/core/models/test_result_bundle.py::TestMappingResultBundle::test_to_dict_not_finalized PASSED [ 23%]
tests/core/models/test_result_bundle.py::TestMappingResultBundle::test_to_dict_with_many_final_identifiers PASSED [ 23%]
tests/core/models/test_result_bundle.py::TestMappingResultBundle::test_resources_used_in_provenance PASSED [ 23%]
tests/core/models/test_result_bundle.py::TestMappingResultBundle::test_multiple_step_tracking PASSED [ 24%]
tests/core/services/test_direct_mapping_service.py::test_direct_mapping_service_no_path_found PASSED [ 24%]
tests/core/services/test_direct_mapping_service.py::test_direct_mapping_service_path_found_with_mappings PASSED [ 24%]
tests/core/services/test_direct_mapping_service.py::test_direct_mapping_service_all_ids_already_processed PASSED [ 24%]
tests/core/services/test_execution_trace_logger.py::TestExecutionTraceLogger::test_init PASSED [ 24%]
tests/core/services/test_execution_trace_logger.py::TestExecutionTraceLogger::test_log_mapping_session_start PASSED [ 24%]
tests/core/services/test_execution_trace_logger.py::TestExecutionTraceLogger::test_log_mapping_session_end PASSED [ 24%]
tests/core/services/test_execution_trace_logger.py::TestExecutionTraceLogger::test_log_path_execution PASSED [ 24%]
tests/core/services/test_execution_trace_logger.py::TestExecutionTraceLogger::test_log_entity_mappings PASSED [ 24%]
tests/core/services/test_execution_trace_logger.py::TestExecutionTraceLogger::test_log_execution_metric PASSED [ 24%]
tests/core/services/test_execution_trace_logger.py::TestExecutionTraceLogger::test_database_session_handling PASSED [ 24%]
tests/core/services/test_execution_trace_logger.py::TestExecutionTraceLogger::test_database_error_handling PASSED [ 25%]
tests/core/services/test_execution_trace_logger.py::TestExecutionTraceLogger::test_malformed_data_handling PASSED [ 25%]
tests/core/services/test_execution_trace_logger.py::TestExecutionTraceLogger::test_session_cleanup_on_success PASSED [ 25%]
tests/core/services/test_mapping_step_execution_service.py::test_execute_step_forward_success PASSED [ 25%]
tests/core/services/test_mapping_step_execution_service.py::test_execute_step_with_uniprot_cache_bypass PASSED [ 25%]
tests/core/services/test_mapping_step_execution_service.py::test_execute_step_reverse_with_specialized_method PASSED [ 25%]
tests/core/services/test_mapping_step_execution_service.py::test_execute_step_reverse_by_inversion PASSED [ 25%]
tests/core/services/test_mapping_step_execution_service.py::test_execute_step_client_error PASSED [ 25%]
tests/core/services/test_mapping_step_execution_service.py::test_execute_step_unexpected_error PASSED [ 25%]
tests/core/services/test_mapping_step_execution_service.py::test_execute_step_initialization_error PASSED [ 25%]
tests/core/services/test_mapping_step_execution_service.py::test_execute_step_ensures_all_inputs_in_results PASSED [ 25%]
tests/core/services/test_metadata_query_service.py::TestMetadataQueryService::test_init PASSED [ 25%]
tests/core/services/test_metadata_query_service.py::TestMetadataQueryService::test_get_endpoint_properties_success PASSED [ 26%]
tests/core/services/test_metadata_query_service.py::TestMetadataQueryService::test_get_endpoint_properties_empty_result PASSED [ 26%]
tests/core/services/test_metadata_query_service.py::TestMetadataQueryService::test_get_ontology_preferences_success PASSED [ 26%]
tests/core/services/test_metadata_query_service.py::TestMetadataQueryService::test_get_ontology_preferences_empty_result PASSED [ 26%]
tests/core/services/test_metadata_query_service.py::TestMetadataQueryService::test_get_endpoint_success PASSED [ 26%]
tests/core/services/test_metadata_query_service.py::TestMetadataQueryService::test_get_endpoint_not_found PASSED [ 26%]
tests/core/services/test_metadata_query_service.py::TestMetadataQueryService::test_get_endpoint_database_error PASSED [ 26%]
tests/core/services/test_metadata_query_service.py::TestMetadataQueryService::test_get_ontology_type_success PASSED [ 26%]
tests/core/services/test_metadata_query_service.py::TestMetadataQueryService::test_get_ontology_type_not_found PASSED [ 26%]
tests/core/services/test_metadata_query_service.py::TestMetadataQueryService::test_get_ontology_type_database_error PASSED [ 26%]
tests/core/services/test_metadata_query_service.py::TestMetadataQueryService::test_get_ontology_type_unexpected_error PASSED [ 26%]
tests/core/services/test_metadata_query_service.py::TestMetadataQueryService::test_get_ontology_type_multiple_valid_combinations PASSED [ 27%]
tests/core/services/test_metadata_query_service.py::TestMetadataQueryService::test_sql_query_construction PASSED [ 27%]
tests/core/services/test_metadata_query_service.py::TestMetadataQueryService::test_logging_behavior PASSED [ 27%]
tests/core/services/test_metadata_query_service.py::TestMetadataQueryService::test_session_manager_integration PASSED [ 27%]
tests/embedder/test_qdrant_store.py::TestQdrantVectorStoreScores::test_search_returns_similarity_scores PASSED [ 27%]
tests/embedder/test_qdrant_store.py::TestQdrantVectorStoreScores::test_search_with_no_results PASSED [ 27%]
tests/embedder/test_qdrant_store.py::TestQdrantVectorStoreScores::test_filter_search_returns_scores PASSED [ 27%]
tests/embedder/test_qdrant_store.py::TestQdrantVectorStoreScores::test_search_score_types PASSED [ 27%]
tests/embedder/storage/test_vector_store.py::TestFAISSVectorStore::test_init_default PASSED [ 27%]
tests/embedder/storage/test_vector_store.py::TestFAISSVectorStore::test_init_custom_parameters PASSED [ 27%]
tests/embedder/storage/test_vector_store.py::TestFAISSVectorStore::test_add_embeddings_basic PASSED [ 27%]
tests/embedder/storage/test_vector_store.py::TestFAISSVectorStore::test_add_embeddings_without_metadata PASSED [ 27%]
tests/embedder/storage/test_vector_store.py::TestFAISSVectorStore::test_add_embeddings_validation PASSED [ 28%]
tests/embedder/storage/test_vector_store.py::TestFAISSVectorStore::test_search_basic PASSED [ 28%]
tests/embedder/storage/test_vector_store.py::TestFAISSVectorStore::test_search_empty_store PASSED [ 28%]
tests/embedder/storage/test_vector_store.py::TestFAISSVectorStore::test_search_with_filter PASSED [ 28%]
tests/embedder/storage/test_vector_store.py::TestFAISSVectorStore::test_get_embedding PASSED [ 28%]
tests/embedder/storage/test_vector_store.py::TestFAISSVectorStore::test_save_and_load PASSED [ 28%]
tests/embedder/storage/test_vector_store.py::TestFAISSVectorStore::test_save_without_metadata_path PASSED [ 28%]
tests/embedder/storage/test_vector_store.py::TestFAISSVectorStore::test_clear PASSED [ 28%]
tests/embedder/storage/test_vector_store.py::TestFAISSVectorStore::test_normalize_embeddings PASSED [ 28%]
tests/embedder/storage/test_vector_store.py::TestFAISSVectorStore::test_ivf_index_type PASSED [ 28%]
tests/embedder/storage/test_vector_store.py::TestFAISSVectorStore::test_inner_product_metric PASSED [ 28%]
tests/embedder/storage/test_vector_store.py::TestFAISSVectorStore::test_repr PASSED [ 29%]
tests/embedder/storage/test_vector_store.py::TestFAISSVectorStore::test_len PASSED [ 29%]
tests/embedder/storage/test_vector_store.py::TestFAISSVectorStore::test_persistence_with_different_paths PASSED [ 29%]
tests/embedder/storage/test_vector_store.py::TestFAISSVectorStore::test_dimension_mismatch_on_search PASSED [ 29%]
tests/integration/test_historical_id_mapping.py::TestHistoricalIDMapping::test_mapping_with_historical_resolution PASSED [ 29%]
tests/integration/test_historical_id_mapping.py::TestHistoricalIDMapping::test_path_selection_order SKIPPED [ 29%]
tests/integration/test_historical_id_mapping.py::TestHistoricalIDMapping::test_cache_usage PASSED [ 29%]
tests/integration/test_historical_id_mapping.py::TestHistoricalIDMapping::test_error_handling SKIPPED [ 29%]
tests/integration/test_strategy_execution.py::test_ukbb_hpa_overlap_strategy FAILED [ 29%]
tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_basic_linear_strategy FAILED [ 29%]
tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_strategy_with_execute_mapping_path PASSED [ 29%]
tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_strategy_with_filter_action PASSED [ 30%]
tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_mixed_action_strategy FAILED [ 30%]
tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_strategy_not_found PASSED [ 30%]
tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_empty_initial_identifiers FAILED [ 30%]
tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_step_failure_handling PASSED [ 30%]
tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_ontology_type_tracking FAILED [ 30%]
tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_filter_with_conversion_path PASSED [ 30%]
tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_strategy_with_conditional_branching SKIPPED [ 30%]
tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_parallel_action_execution SKIPPED [ 30%]
tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_all_optional_strategy FAILED [ 30%]
tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_mixed_required_optional_strategy FAILED [ 30%]
tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_optional_fail_first_strategy FAILED [ 30%]
tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_optional_fail_last_strategy FAILED [ 31%]
tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_multiple_optional_failures_strategy FAILED [ 31%]
tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_required_fail_after_optional_strategy FAILED [ 31%]
tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_all_optional_fail_strategy PASSED [ 31%]
tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_required_step_explicit_true PASSED [ 31%]
tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_mapping_result_bundle_tracking FAILED [ 31%]
tests/integration/test_yaml_strategy_ukbb_hpa.py::TestUKBBToHPAYAMLStrategy::test_strategy_loaded_in_database PASSED [ 31%]
tests/integration/test_yaml_strategy_ukbb_hpa.py::TestUKBBToHPAYAMLStrategy::test_execute_yaml_strategy_basic FAILED [ 31%]
tests/integration/test_yaml_strategy_ukbb_hpa.py::TestUKBBToHPAYAMLStrategy::test_execute_yaml_strategy_with_invalid_strategy PASSED [ 31%]
tests/integration/test_yaml_strategy_ukbb_hpa.py::TestUKBBToHPAYAMLStrategy::test_execute_yaml_strategy_with_progress_callback FAILED [ 31%]
tests/integration/test_yaml_strategy_ukbb_hpa.py::TestUKBBToHPAYAMLStrategy::test_action_handlers_placeholder_behavior FAILED [ 31%]
tests/integration/test_yaml_strategy_ukbb_hpa.py::test_full_yaml_strategy_workflow PASSED [ 32%]
tests/integration/historical/test_ukbb_historical_mapping.py::test_historical_mapping PASSED [ 32%]
tests/mapping/test_endpoint_mapping.py::test_relationship_mapping SKIPPED [ 32%]
tests/mapping/test_extractors.py::test_extract_hmdb_id[HMDB0001234-HMDB0001234] PASSED [ 32%]
tests/mapping/test_extractors.py::test_extract_hmdb_id[foo HMDB0012345 bar-HMDB0012345] PASSED [ 32%]
tests/mapping/test_extractors.py::test_extract_hmdb_id[no id here-None] PASSED [ 32%]
tests/mapping/test_extractors.py::test_extract_chebi_id[CHEBI:15377-CHEBI:15377] PASSED [ 32%]
tests/mapping/test_extractors.py::test_extract_chebi_id[foo CHEBI:1234 bar-CHEBI:1234] PASSED [ 32%]
tests/mapping/test_extractors.py::test_extract_chebi_id[no chebi-None] PASSED [ 32%]
tests/mapping/test_extractors.py::test_extract_pubchem_id[1234567-1234567] PASSED [ 32%]
tests/mapping/test_extractors.py::test_extract_pubchem_id[foo 7654321 bar-7654321] PASSED [ 32%]
tests/mapping/test_extractors.py::test_extract_pubchem_id[abc-None] PASSED [ 33%]
tests/mapping/test_extractors.py::test_extract_uniprot_id[P12345-P12345] PASSED [ 33%]
tests/mapping/test_extractors.py::test_extract_uniprot_id[foo Q9XYZ1 bar-Q9XYZ1] PASSED [ 33%]
tests/mapping/test_extractors.py::test_extract_uniprot_id[not a uniprot-None] PASSED [ 33%]
tests/mapping/test_extractors.py::test_extract_all_ids PASSED            [ 33%]
tests/mapping/test_extractors.py::test_csv_adapter_extract_ids_from_row PASSED [ 33%]
tests/mapping/test_extractors.py::test_csv_adapter_extract_id_from_cell PASSED [ 33%]
tests/mapping/test_path_execution_manager.py::test_run_path_steps_basic PASSED [ 33%]
tests/mapping/test_path_execution_manager.py::test_execute_path_multi_step PASSED [ 33%]
tests/mapping/test_reverse_mapping.py::test_reverse_mapping PASSED       [ 33%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapter::test_csv_adapter_initialization PASSED [ 33%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapter::test_load_data_all_columns PASSED [ 33%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapter::test_load_data_selective_columns PASSED [ 34%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapter::test_load_data_empty_columns_list PASSED [ 34%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapter::test_load_data_nonexistent_columns PASSED [ 34%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapter::test_load_data_all_nonexistent_columns PASSED [ 34%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapter::test_load_data_caching PASSED [ 34%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapter::test_load_data_different_columns_different_cache PASSED [ 34%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapter::test_load_data_cache_eviction PASSED [ 34%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapter::test_load_data_file_not_found PASSED [ 34%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapter::test_load_data_no_file_path_no_endpoint PASSED [ 34%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapter::test_load_data_with_endpoint_file_path PASSED [ 34%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapter::test_load_data_with_endpoint_url PASSED [ 34%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapter::test_load_data_endpoint_no_path PASSED [ 35%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapter::test_clear_cache PASSED [ 35%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapter::test_get_cache_info PASSED [ 35%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapter::test_get_cache_stats_initial PASSED [ 35%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapter::test_extract_ids_functionality PASSED [ 35%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapter::test_get_supported_extractions PASSED [ 35%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapterIntegration::test_memory_usage_optimization PASSED [ 35%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapterIntegration::test_performance_with_caching PASSED [ 35%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapterPerformanceMonitoring::test_cache_hit_miss_tracking PASSED [ 35%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapterPerformanceMonitoring::test_cache_stats_with_different_files PASSED [ 35%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapterPerformanceMonitoring::test_clear_cache_resets_stats PASSED [ 35%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapterPerformanceMonitoring::test_hit_rate_calculation_edge_cases PASSED [ 36%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapterConfiguration::test_cache_size_from_settings PASSED [ 36%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapterConfiguration::test_cache_size_override PASSED [ 36%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapterConfiguration::test_cache_size_none_uses_settings PASSED [ 36%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapterConfiguration::test_settings_integration PASSED [ 36%]
tests/mapping/adapters/test_csv_adapter.py::TestCSVAdapterConfiguration::test_cache_stats_includes_max_size PASSED [ 36%]
tests/mapping/arango/test_arango_store.py::test_connection PASSED        [ 36%]
tests/mapping/arango/test_arango_store.py::test_context_manager PASSED   [ 36%]
tests/mapping/arango/test_arango_store.py::test_get_node PASSED          [ 36%]
tests/mapping/arango/test_arango_store.py::test_get_node_by_property PASSED [ 36%]
tests/mapping/arango/test_arango_store.py::test_get_neighbors PASSED     [ 36%]
tests/mapping/arango/test_arango_store.py::test_find_paths PASSED        [ 36%]
tests/mapping/arango/test_arango_store.py::test_get_types PASSED         [ 37%]
tests/mapping/arango/test_base_arango.py::test_connection PASSED         [ 37%]
tests/mapping/arango/test_base_arango.py::test_context_manager PASSED    [ 37%]
tests/mapping/arango/test_base_arango.py::test_get_node PASSED           [ 37%]
tests/mapping/arango/test_base_arango.py::test_get_node_by_property PASSED [ 37%]
tests/mapping/arango/test_base_arango.py::test_get_neighbors PASSED      [ 37%]
tests/mapping/arango/test_base_arango.py::test_find_paths PASSED         [ 37%]
tests/mapping/arango/test_base_arango.py::test_get_types PASSED          [ 37%]
tests/mapping/clients/test_arivale_lookup_client.py::TestArivaleMetadataLookupClient::test_initialize_client PASSED [ 37%]
tests/mapping/clients/test_arivale_lookup_client.py::TestArivaleMetadataLookupClient::test_initialization_with_missing_config PASSED [ 37%]
tests/mapping/clients/test_arivale_lookup_client.py::TestArivaleMetadataLookupClient::test_initialization_with_nonexistent_file PASSED [ 37%]
tests/mapping/clients/test_arivale_lookup_client.py::TestArivaleMetadataLookupClient::test_map_simple_identifiers PASSED [ 38%]
tests/mapping/clients/test_arivale_lookup_client.py::TestArivaleMetadataLookupClient::test_map_exact_composite_identifiers PASSED [ 38%]
tests/mapping/clients/test_arivale_lookup_client.py::TestArivaleMetadataLookupClient::test_map_component_match_identifiers PASSED [ 38%]
tests/mapping/clients/test_arivale_lookup_client.py::TestArivaleMetadataLookupClient::test_map_multi_component_matches PASSED [ 38%]
tests/mapping/clients/test_arivale_lookup_client.py::TestArivaleMetadataLookupClient::test_map_no_match_identifiers PASSED [ 38%]
tests/mapping/clients/test_arivale_lookup_client.py::TestArivaleMetadataLookupClient::test_map_empty_list PASSED [ 38%]
tests/mapping/clients/test_arivale_lookup_client.py::TestArivaleMetadataLookupClient::test_map_whitespace_handling PASSED [ 38%]
tests/mapping/clients/test_arivale_lookup_client.py::TestArivaleMetadataLookupClient::test_caching PASSED [ 38%]
tests/mapping/clients/test_arivale_lookup_client.py::TestArivaleMetadataLookupClient::test_reverse_map_identifiers PASSED [ 38%]
tests/mapping/clients/test_arivale_reverse_lookup_client.py::TestArivaleReverseLookupClient::test_initialize_client PASSED [ 38%]
tests/mapping/clients/test_arivale_reverse_lookup_client.py::TestArivaleReverseLookupClient::test_map_identifiers PASSED [ 38%]
tests/mapping/clients/test_arivale_reverse_lookup_client.py::TestArivaleReverseLookupClient::test_reverse_map_identifiers PASSED [ 38%]
tests/mapping/clients/test_chebi_client.py::test_get_entity_by_id_success PASSED [ 39%]
tests/mapping/clients/test_chebi_client.py::test_get_entity_missing_properties PASSED [ 39%]
tests/mapping/clients/test_chebi_client.py::test_search_by_name_success PASSED [ 39%]
tests/mapping/clients/test_chebi_client.py::test_search_by_name_partial_failures PASSED [ 39%]
tests/mapping/clients/test_chebi_client.py::test_max_results_limit PASSED [ 39%]
tests/mapping/clients/test_chebi_client.py::test_get_safe_property PASSED [ 39%]
tests/mapping/clients/test_chebi_client.py::test_chebi_id_prefix_handling PASSED [ 39%]
tests/mapping/clients/test_composite_gene_mapping.py::test_composite_gene_symbols PASSED [ 39%]
tests/mapping/clients/test_composite_gene_mapping.py::test_regular_gene_symbols PASSED [ 39%]
tests/mapping/clients/test_composite_gene_mapping.py::test_special_cases PASSED [ 39%]
tests/mapping/clients/test_kegg_client.py::TestKEGGClient::test_get_entity_by_id_error PASSED [ 39%]
tests/mapping/clients/test_kegg_client.py::TestKEGGClient::test_get_entity_by_id_success PASSED [ 40%]
tests/mapping/clients/test_kegg_client.py::TestKEGGClient::test_search_by_name_no_results PASSED [ 40%]
tests/mapping/clients/test_kegg_client.py::TestKEGGClient::test_search_by_name_success PASSED [ 40%]
tests/mapping/clients/test_metaboanalyst_client.py::TestMetaboAnalystClient::test_init_default_config PASSED [ 40%]
tests/mapping/clients/test_metaboanalyst_client.py::TestMetaboAnalystClient::test_init_custom_config PASSED [ 40%]
tests/mapping/clients/test_metaboanalyst_client.py::TestMetaboAnalystClient::test_map_compounds_empty_list PASSED [ 40%]
tests/mapping/clients/test_metaboanalyst_client.py::TestMetaboAnalystClient::test_map_compounds_invalid_input_type PASSED [ 40%]
tests/mapping/clients/test_metaboanalyst_client.py::TestMetaboAnalystClient::test_map_compounds_success PASSED [ 40%]
tests/mapping/clients/test_metaboanalyst_client.py::TestMetaboAnalystClient::test_map_compounds_api_error PASSED [ 40%]
tests/mapping/clients/test_metaboanalyst_client.py::TestMetaboAnalystClient::test_map_compounds_http_error PASSED [ 40%]
tests/mapping/clients/test_metaboanalyst_client.py::TestMetaboAnalystClient::test_map_compounds_unexpected_response PASSED [ 40%]
tests/mapping/clients/test_pubchem_client.py::TestPubChemClient::test_get_entity_by_id_error PASSED [ 41%]
tests/mapping/clients/test_pubchem_client.py::TestPubChemClient::test_get_entity_by_id_success PASSED [ 41%]
tests/mapping/clients/test_pubchem_client.py::TestPubChemClient::test_search_by_name_no_results PASSED [ 41%]
tests/mapping/clients/test_pubchem_client.py::TestPubChemClient::test_search_by_name_success PASSED [ 41%]
tests/mapping/clients/test_pubchem_rag_client.py::TestPubChemRAGMappingClientScores::test_map_identifiers_captures_scores PASSED [ 41%]
tests/mapping/clients/test_pubchem_rag_client.py::TestPubChemRAGMappingClientScores::test_map_identifiers_no_results PASSED [ 41%]
tests/mapping/clients/test_pubchem_rag_client.py::TestPubChemRAGMappingClientScores::test_map_identifiers_empty_input PASSED [ 41%]
tests/mapping/clients/test_pubchem_rag_client.py::TestPubChemRAGMappingClientScores::test_map_identifiers_error_handling PASSED [ 41%]
tests/mapping/clients/test_pubchem_rag_client.py::TestPubChemRAGMappingClientScores::test_map_identifiers_metadata_propagation PASSED [ 41%]
tests/mapping/clients/test_pubchem_rag_client.py::TestPubChemRAGMappingClientScores::test_get_last_mapping_output_before_mapping PASSED [ 41%]
tests/mapping/clients/test_pubchem_rag_client.py::TestPubChemRAGMappingClientScores::test_multiple_scores_handling PASSED [ 41%]
tests/mapping/clients/test_refmet_client.py::test_client_initialization PASSED [ 41%]
tests/mapping/clients/test_refmet_client.py::test_client_custom_config PASSED [ 42%]
tests/mapping/clients/test_refmet_client.py::test_successful_search PASSED [ 42%]
tests/mapping/clients/test_refmet_client.py::test_empty_response PASSED  [ 42%]
tests/mapping/clients/test_refmet_client.py::test_malformed_response PASSED [ 42%]
tests/mapping/clients/test_refmet_client.py::test_name_cleaning PASSED   [ 42%]
tests/mapping/clients/test_refmet_client.py::test_pandas_error_handling PASSED [ 42%]
tests/mapping/clients/test_refmet_client.py::test_request_exception PASSED [ 42%]
tests/mapping/clients/test_refmet_client.py::test_empty_dataframe PASSED [ 42%]
tests/mapping/clients/test_refmet_client.py::test_retry_mechanism PASSED [ 42%]
tests/mapping/clients/test_refmet_client.py::test_http_error PASSED      [ 42%]
tests/mapping/clients/test_refmet_client.py::test_search_compounds_error PASSED [ 42%]
tests/mapping/clients/test_refmet_client.py::test_search_by_name[glucose-Input name\tRefMet_ID\tStandardized name\tFormula\tExact mass\tINCHI_KEY\tPubChem_CID\tChEBI_ID\tHMDB_ID\tKEGG_ID\nglucose\tRM0135901\tGlucose\tC6H12O6\t180.0634\tWQZGKKKJIJFFOK-GASJEMHNSA-N\t5793\t4167\tHMDB0000122\tC00031\n-expected_result0] PASSED [ 43%]
tests/mapping/clients/test_refmet_client.py::test_search_by_name[invalid-compound-Input name\tStandardized name\tFormula\tExact mass\tINCHI_KEY\tPubChem_CID\tChEBI_ID\tHMDB_ID\tKEGG_ID\ninvalid-compound\t-\t-\t-\t-\t-\t-\t-\t-\n-None] PASSED [ 43%]
tests/mapping/clients/test_refmet_client.py::test_search_by_name[empty-result-Input name\tStandardized name\tFormula\tExact mass\tINCHI_KEY\tPubChem_CID\tChEBI_ID\tHMDB_ID\tKEGG_ID\n-None] PASSED [ 43%]
tests/mapping/clients/test_refmet_client.py::test_search_by_name_request_error PASSED [ 43%]
tests/mapping/clients/test_refmet_client.py::test_search_by_name_complex_terms PASSED [ 43%]
tests/mapping/clients/test_translator_name_resolver_client.py::test_init PASSED [ 43%]
tests/mapping/clients/test_translator_name_resolver_client.py::test_filter_matches_by_target_db PASSED [ 43%]
tests/mapping/clients/test_translator_name_resolver_client.py::test_extract_identifier_from_curie PASSED [ 43%]
tests/mapping/clients/test_translator_name_resolver_client.py::test_map_identifiers PASSED [ 43%]
tests/mapping/clients/test_translator_name_resolver_client.py::test_map_identifiers_empty_input PASSED [ 43%]
tests/mapping/clients/test_translator_name_resolver_client.py::test_map_identifiers_no_results PASSED [ 43%]
tests/mapping/clients/test_translator_name_resolver_client.py::test_map_identifiers_multiple_names PASSED [ 44%]
tests/mapping/clients/test_translator_name_resolver_client.py::test_lookup_entity_name PASSED [ 44%]
tests/mapping/clients/test_translator_name_resolver_client.py::test_perform_request_success PASSED [ 44%]
tests/mapping/clients/test_translator_name_resolver_client.py::test_perform_request_failure PASSED [ 44%]
tests/mapping/clients/test_translator_name_resolver_client.py::test_reverse_map_identifiers PASSED [ 44%]
tests/mapping/clients/test_translator_name_resolver_client.py::test_caching PASSED [ 44%]
tests/mapping/clients/test_translator_name_resolver_client.py::test_close PASSED [ 44%]
tests/mapping/clients/test_umls_client.py::test_init PASSED              [ 44%]
tests/mapping/clients/test_umls_client.py::test_get_tgt PASSED           [ 44%]
tests/mapping/clients/test_umls_client.py::test_get_service_ticket PASSED [ 44%]
tests/mapping/clients/test_umls_client.py::test_perform_search PASSED    [ 44%]
tests/mapping/clients/test_umls_client.py::test_get_concept_details PASSED [ 44%]
tests/mapping/clients/test_umls_client.py::test_get_concept_atoms PASSED [ 45%]
tests/mapping/clients/test_umls_client.py::test_extract_target_identifiers PASSED [ 45%]
tests/mapping/clients/test_umls_client.py::test_is_metabolite_concept PASSED [ 45%]
tests/mapping/clients/test_umls_client.py::test_resolve_term PASSED      [ 45%]
tests/mapping/clients/test_umls_client.py::test_map_identifiers PASSED   [ 45%]
tests/mapping/clients/test_umls_client.py::test_map_identifiers_empty_input PASSED [ 45%]
tests/mapping/clients/test_umls_client.py::test_reverse_map_identifiers PASSED [ 45%]
tests/mapping/clients/test_umls_client.py::test_close PASSED             [ 45%]
tests/mapping/clients/test_unichem_client.py::test_init PASSED           [ 45%]
tests/mapping/clients/test_unichem_client.py::test_get_unichem_source_id PASSED [ 45%]
tests/mapping/clients/test_unichem_client.py::test_map_identifiers PASSED [ 45%]
tests/mapping/clients/test_unichem_client.py::test_map_identifiers_empty_input PASSED [ 46%]
tests/mapping/clients/test_unichem_client.py::test_map_identifiers_missing_mapping PASSED [ 46%]
tests/mapping/clients/test_unichem_client.py::test_reverse_map_identifiers PASSED [ 46%]
tests/mapping/clients/test_unichem_client.py::test_close PASSED          [ 46%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_initialization PASSED [ 46%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_custom_config PASSED [ 46%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_get_available_mappings PASSED [ 46%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_map_id_all_categories PASSED [ 46%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_map_id_specific_category PASSED [ 46%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_map_id_invalid_target PASSED [ 46%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_map_id_failed_mapping PASSED [ 46%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_map_id_with_exception PASSED [ 47%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_map_id_with_http_error PASSED [ 47%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_map_to_database PASSED [ 47%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_map_to_database_submit_failure PASSED [ 47%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_map_to_database_request_exception PASSED [ 47%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_job_polling PASSED [ 47%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_failed_job_status PASSED [ 47%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_check_job_status_invalid_response PASSED [ 47%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_check_job_status_missing_location PASSED [ 47%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_retry_request PASSED [ 47%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_make_request_success PASSED [ 47%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_make_request_retry PASSED [ 47%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_retry_request_all_attempts_fail PASSED [ 48%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_retry_on_error_codes[server_error] PASSED [ 48%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_retry_on_error_codes[bad_gateway] PASSED [ 48%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_retry_on_error_codes[service_unavailable] PASSED [ 48%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_retry_on_error_codes[gateway_timeout] PASSED [ 48%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_should_retry_timeout PASSED [ 48%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_should_retry_timeout_with_max_retries PASSED [ 48%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_should_retry_connection_error PASSED [ 48%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_should_retry_connection_error_with_max_retries PASSED [ 48%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_should_retry_response_error PASSED [ 48%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_session_retry_configuration PASSED [ 48%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_session_configuration PASSED [ 49%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_get_job_results_retry PASSED [ 49%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_get_job_results_no_retry PASSED [ 49%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_submit_job_invalid_response PASSED [ 49%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_submit_job_request_exception PASSED [ 49%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_submit_job_with_http_error PASSED [ 49%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_check_job_status_with_http_error PASSED [ 49%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_remove_source_database_from_results PASSED [ 49%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_should_retry_other_exception PASSED [ 49%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_get_job_results_error_no_retry PASSED [ 49%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_submit_job_non_json_response PASSED [ 49%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_check_job_status_non_json_response PASSED [ 50%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_map_to_database_invalid_job_id PASSED [ 50%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_check_job_status_request_exception PASSED [ 50%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_map_to_database_timeout PASSED [ 50%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_generate_mappings PASSED [ 50%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_get_job_results_all_retries_fail PASSED [ 50%]
tests/mapping/clients/test_uniprot_focused_mapper.py::test_process_chunk_causes_exception PASSED [ 50%]
tests/mapping/clients/test_uniprot_historical_resolver_client.py::TestUniProtHistoricalResolverClient::test_initialize_client PASSED [ 50%]
tests/mapping/clients/test_uniprot_historical_resolver_client.py::TestUniProtHistoricalResolverClient::test_mock_primary_accession_resolution PASSED [ 50%]
tests/mapping/clients/test_uniprot_historical_resolver_client.py::TestUniProtHistoricalResolverClient::test_mock_secondary_accession_resolution PASSED [ 50%]
tests/mapping/clients/test_uniprot_historical_resolver_client.py::TestUniProtHistoricalResolverClient::test_mock_demerged_accession_resolution PASSED [ 50%]
tests/mapping/clients/test_uniprot_historical_resolver_client.py::TestUniProtHistoricalResolverClient::test_mock_non_existent_accession PASSED [ 50%]
tests/mapping/clients/test_uniprot_historical_resolver_client.py::TestUniProtHistoricalResolverClient::test_mock_api_error_handling PASSED [ 51%]
tests/mapping/clients/test_uniprot_historical_resolver_client.py::TestUniProtHistoricalResolverClient::test_mock_batch_processing PASSED [ 51%]
tests/mapping/clients/test_uniprot_historical_resolver_client.py::TestUniProtHistoricalResolverClient::test_cache_usage PASSED [ 51%]
tests/mapping/clients/test_uniprot_historical_resolver_client.py::TestUniProtHistoricalResolverClient::test_reverse_map_identifiers_not_supported PASSED [ 51%]
tests/mapping/clients/arivale/test_arivale_lookup.py::test_arivale_lookup_client PASSED [ 51%]
tests/mapping/clients/uniprot/test_uniprot_api.py::test_uniprot_api PASSED [ 51%]
tests/mapping/clients/uniprot/test_uniprot_demerged.py::test_uniprot_demerged PASSED [ 51%]
tests/mapping/clients/uniprot/test_uniprot_historical_resolution.py::test_historical_resolution PASSED [ 51%]
tests/mapping/clients/uniprot/test_uniprot_mapping.py::test PASSED       [ 51%]
tests/mapping/clients/uniprot/test_uniprot_name_mapping.py::test_uniprot_name_client PASSED [ 51%]
tests/mapping/clients/uniprot/test_uniprot_secondary_id_mapping.py::test_secondary_id_mapping PASSED [ 51%]
tests/mapping/embeddings/test_embedding_managers.py::test_huggingface_embed_text PASSED [ 52%]
tests/mapping/embeddings/test_embedding_managers.py::test_huggingface_embed_batch PASSED [ 52%]
tests/mapping/embeddings/test_embedding_managers.py::test_openai_embed_text PASSED [ 52%]
tests/mapping/embeddings/test_embedding_managers.py::test_openai_embed_batch PASSED [ 52%]
tests/mapping/embeddings/test_embedding_managers.py::test_openai_no_api_key PASSED [ 52%]
tests/mapping/rag/test_base_rag.py::test_document_creation PASSED        [ 52%]
tests/mapping/rag/test_base_rag.py::test_vector_store_operations PASSED  [ 52%]
tests/mapping/rag/test_base_rag.py::test_embedder_operations PASSED      [ 52%]
tests/mapping/rag/test_base_rag.py::test_prompt_manager PASSED           [ 52%]
tests/mapping/rag/test_base_rag.py::test_rag_mapper_success PASSED       [ 52%]
tests/mapping/rag/test_base_rag.py::test_rag_mapper_error_handling PASSED [ 52%]
tests/mapping/rag/test_chroma.py::test_add_documents PASSED              [ 52%]
tests/mapping/rag/test_chroma.py::test_add_documents_no_embeddings PASSED [ 53%]
tests/mapping/rag/test_chroma.py::test_get_relevant PASSED               [ 53%]
tests/mapping/rag/test_chroma.py::test_get_relevant_error PASSED         [ 53%]
tests/mapping/rag/test_chroma.py::test_clear PASSED                      [ 53%]
tests/mapping/rag/test_chroma.py::test_clear_error PASSED                [ 53%]
tests/mapping/rag/test_prompts.py::test_load_default_prompts PASSED      [ 53%]
tests/mapping/rag/test_prompts.py::test_get_prompt PASSED                [ 53%]
tests/mapping/rag/test_prompts.py::test_get_nonexistent_prompt PASSED    [ 53%]
tests/mapping/rag/test_prompts.py::test_add_prompt PASSED                [ 53%]
tests/mapping/rag/test_prompts.py::test_update_metrics PASSED            [ 53%]
tests/mapping/rag/test_rag_setup.py::test_rag_initialization PASSED      [ 53%]
tests/mapping/rag/test_rag_setup.py::test_rag_mapping PASSED             [ 54%]
tests/mapping/rag/test_store.py::test_add_documents PASSED               [ 54%]
tests/mapping/rag/test_store.py::test_query_empty_store PASSED           [ 54%]
tests/mapping/rag/test_store.py::test_add_documents_no_embeddings PASSED [ 54%]
tests/monitoring/test_langfuse_tracker.py::test_create_langfuse_client PASSED [ 54%]
tests/monitoring/test_langfuse_tracker.py::test_tracker_initialization PASSED [ 54%]
tests/monitoring/test_langfuse_tracker.py::test_tracker_initialization_with_env PASSED [ 54%]
tests/monitoring/test_langfuse_tracker.py::test_trace_mapping PASSED     [ 54%]
tests/monitoring/test_langfuse_tracker.py::test_trace_mapping_disabled PASSED [ 54%]
tests/monitoring/test_langfuse_tracker.py::test_record_error PASSED      [ 54%]
tests/monitoring/test_langfuse_tracker.py::test_record_span PASSED       [ 54%]
tests/monitoring/test_metrics.py::test_metrics_to_dict PASSED            [ 55%]
tests/monitoring/test_metrics.py::test_metrics_tracker_without_langfuse PASSED [ 55%]
tests/monitoring/test_metrics.py::test_metrics_tracker_with_langfuse PASSED [ 55%]
tests/monitoring/test_metrics.py::test_metrics_recording PASSED          [ 55%]
tests/monitoring/test_metrics.py::test_metrics_recording_no_langfuse PASSED [ 55%]
tests/monitoring/test_traces.py::test_analyze_traces_without_langfuse PASSED [ 55%]
tests/monitoring/test_traces.py::test_analyze_traces_with_langfuse PASSED [ 55%]
tests/monitoring/test_traces.py::test_analyze_traces_empty PASSED        [ 55%]
tests/mvp0_pipeline/test_llm_mapper.py::test_select_best_cid_with_llm_no_api_key PASSED [ 55%]
tests/mvp0_pipeline/test_llm_mapper.py::test_select_best_cid_with_llm_no_candidates PASSED [ 55%]
tests/mvp0_pipeline/test_llm_mapper.py::test_select_best_cid_with_llm_successful_response PASSED [ 55%]
tests/mvp0_pipeline/test_llm_mapper.py::test_select_best_cid_with_llm_no_match PASSED [ 55%]
tests/mvp0_pipeline/test_llm_mapper.py::test_select_best_cid_with_llm_api_error PASSED [ 56%]
tests/mvp0_pipeline/test_llm_mapper.py::test_select_best_cid_with_llm_invalid_json_response PASSED [ 56%]
tests/mvp0_pipeline/test_llm_mapper.py::test_select_best_cid_with_llm_string_confidence PASSED [ 56%]
tests/mvp0_pipeline/test_llm_mapper.py::test_llm_choice_model PASSED     [ 56%]
tests/mvp0_pipeline/test_pipeline_orchestrator.py::TestPipelineOrchestrator::test_init_successful PASSED [ 56%]
tests/mvp0_pipeline/test_pipeline_orchestrator.py::TestPipelineOrchestrator::test_init_missing_api_key PASSED [ 56%]
tests/mvp0_pipeline/test_pipeline_orchestrator.py::TestPipelineOrchestrator::test_init_missing_qdrant_url PASSED [ 56%]
tests/mvp0_pipeline/test_pipeline_orchestrator.py::TestPipelineOrchestrator::test_init_qdrant_connection_error PASSED [ 56%]
tests/mvp0_pipeline/test_pipeline_orchestrator.py::TestPipelineOrchestrator::test_run_single_mapping_success PASSED [ 56%]
tests/mvp0_pipeline/test_pipeline_orchestrator.py::TestPipelineOrchestrator::test_run_single_mapping_no_qdrant_hits PASSED [ 56%]
tests/mvp0_pipeline/test_pipeline_orchestrator.py::TestPipelineOrchestrator::test_run_single_mapping_insufficient_annotations PASSED [ 56%]
tests/mvp0_pipeline/test_pipeline_orchestrator.py::TestPipelineOrchestrator::test_run_single_mapping_llm_no_match PASSED [ 57%]
tests/mvp0_pipeline/test_pipeline_orchestrator.py::TestPipelineOrchestrator::test_run_single_mapping_qdrant_error PASSED [ 57%]
tests/mvp0_pipeline/test_pipeline_orchestrator.py::TestPipelineOrchestrator::test_run_single_mapping_pubchem_error PASSED [ 57%]
tests/mvp0_pipeline/test_pipeline_orchestrator.py::TestPipelineOrchestrator::test_run_single_mapping_llm_error PASSED [ 57%]
tests/mvp0_pipeline/test_pipeline_orchestrator.py::TestPipelineOrchestrator::test_run_pipeline_batch PASSED [ 57%]
tests/mvp0_pipeline/test_pipeline_orchestrator.py::TestPipelineOrchestrator::test_run_pipeline_empty_list PASSED [ 57%]
tests/mvp0_pipeline/test_pipeline_orchestrator.py::TestPipelineOrchestrator::test_create_orchestrator_factory PASSED [ 57%]
tests/mvp0_pipeline/test_pipeline_orchestrator.py::TestPipelineOrchestrator::test_create_orchestrator_from_env PASSED [ 57%]
tests/mvp0_pipeline/test_pipeline_orchestrator.py::TestPipelineIntegration::test_data_flow_between_components PASSED [ 57%]
tests/mvp0_pipeline/test_pipeline_orchestrator.py::TestPipelineIntegration::test_processing_time_tracking PASSED [ 57%]
tests/mvp0_pipeline/test_pubchem_annotator.py::TestPubChemAnnotator::test_fetch_single_cid_annotation_success PASSED [ 57%]
tests/mvp0_pipeline/test_pubchem_annotator.py::TestPubChemAnnotator::test_fetch_single_cid_annotation_not_found PASSED [ 58%]
tests/mvp0_pipeline/test_pubchem_annotator.py::TestPubChemAnnotator::test_fetch_pubchem_annotations_multiple_cids PASSED [ 58%]
tests/mvp0_pipeline/test_pubchem_annotator.py::TestPubChemAnnotator::test_fetch_pubchem_annotations_empty_list PASSED [ 58%]
tests/mvp0_pipeline/test_pubchem_annotator.py::TestPubChemAnnotator::test_fetch_pubchem_annotations_with_errors PASSED [ 58%]
tests/mvp0_pipeline/test_pubchem_annotator.py::TestPubChemAnnotator::test_rate_limiting PASSED [ 58%]
tests/mvp0_pipeline/test_qdrant_search.py::TestQdrantSearch::test_search_successful_with_scores PASSED [ 58%]
tests/mvp0_pipeline/test_qdrant_search.py::TestQdrantSearch::test_search_with_top_k_limit PASSED [ 58%]
tests/mvp0_pipeline/test_qdrant_search.py::TestQdrantSearch::test_search_empty_input PASSED [ 58%]
tests/mvp0_pipeline/test_qdrant_search.py::TestQdrantSearch::test_search_no_results PASSED [ 58%]
tests/mvp0_pipeline/test_qdrant_search.py::TestQdrantSearch::test_search_with_scores_mismatch PASSED [ 58%]
tests/mvp0_pipeline/test_qdrant_search.py::TestQdrantSearch::test_search_client_error PASSED [ 58%]
tests/mvp0_pipeline/test_qdrant_search.py::TestQdrantSearch::test_search_invalid_pubchem_id PASSED [ 58%]
tests/mvp0_pipeline/test_qdrant_search.py::TestQdrantSearch::test_search_with_default_client PASSED [ 59%]
tests/spoke/test_client.py::test_initialization PASSED                   [ 59%]
tests/spoke/test_client.py::test_base_url PASSED                         [ 59%]
tests/spoke/test_client.py::test_connect_success PASSED                  [ 59%]
tests/spoke/test_client.py::test_connect_failure PASSED                  [ 59%]
tests/spoke/test_client.py::test_disconnect PASSED                       [ 59%]
tests/spoke/test_client.py::test_execute_query_success PASSED            [ 59%]
tests/spoke/test_client.py::test_execute_query_with_bind_vars PASSED     [ 59%]
tests/spoke/test_client.py::test_execute_query_failure PASSED            [ 59%]
tests/spoke/test_client.py::test_get_node_by_id PASSED                   [ 59%]
tests/spoke/test_client.py::test_get_nodes_by_property PASSED            [ 59%]
tests/spoke/test_client.py::test_context_manager PASSED                  [ 60%]
tests/spoke/test_graph_analyzer.py::test_discover_node_types_spoke_style PASSED [ 60%]
tests/spoke/test_graph_analyzer.py::test_discover_relationship_types PASSED [ 60%]
tests/spoke/test_graph_analyzer.py::test_identify_ontology_fields PASSED [ 60%]
tests/spoke/test_graph_analyzer.py::test_generate_schema_mapping PASSED  [ 60%]
tests/spoke/test_graph_analyzer.py::test_spoke_graph_analyzer_init PASSED [ 60%]
tests/spoke/test_mapper.py::test_mapping_result_initialization PASSED    [ 60%]
tests/spoke/test_mapper.py::test_mapping_result_post_init PASSED         [ 60%]
tests/spoke/test_mapper.py::test_map_entity_success PASSED               [ 60%]
tests/spoke/test_mapper.py::test_map_entity_not_found PASSED             [ 60%]
tests/spoke/test_mapper.py::test_map_entity_error PASSED                 [ 60%]
tests/spoke/test_mapper.py::test_map_batch PASSED                        [ 61%]
tests/spoke/test_mapper.py::test_find_spoke_node_query PASSED            [ 61%]
tests/spoke/test_mapper.py::test_find_spoke_node_success PASSED          [ 61%]
tests/spoke/test_mapper.py::test_find_spoke_node_with_relationships PASSED [ 61%]
tests/standardization/test_ramp_client.py::test_client_initialization PASSED [ 61%]
tests/standardization/test_ramp_client.py::test_client_custom_config PASSED [ 61%]
tests/standardization/test_ramp_client.py::test_get_source_versions PASSED [ 61%]
tests/standardization/test_ramp_client.py::test_get_valid_id_types PASSED [ 61%]
tests/standardization/test_ramp_client.py::test_get_pathways_from_analytes PASSED [ 61%]
tests/standardization/test_ramp_client.py::test_get_chemical_properties PASSED [ 61%]
tests/standardization/test_ramp_client.py::test_api_error_handling PASSED [ 61%]
tests/standardization/test_ramp_client.py::test_analyze_pathway_stats PASSED [ 61%]
tests/standardization/test_ramp_client.py::test_find_pathway_overlaps PASSED [ 62%]
tests/standardization/test_ramp_client.py::test_get_ontologies_from_metabolites PASSED [ 62%]
tests/standardization/test_ramp_client.py::test_get_metabolites_from_ontologies PASSED [ 62%]
tests/standardization/test_ramp_client.py::test_get_chemical_classes PASSED [ 62%]
tests/standardization/test_ramp_client.py::test_get_common_reaction_analytes PASSED [ 62%]
tests/standardization/test_ramp_client.py::test_get_reactions_from_analytes PASSED [ 62%]
tests/standardization/test_ramp_client.py::test_get_reaction_classes PASSED [ 62%]
tests/standardization/test_ramp_client.py::test_empty_response_handling PASSED [ 62%]
tests/standardization/test_ramp_client.py::test_timeout_handling PASSED  [ 62%]
tests/standardization/test_ramp_client.py::test_full_pathway_analysis_flow PASSED [ 62%]
tests/standardization/test_ramp_client.py::test_analyze_pathway_stats_empty_result PASSED [ 62%]
tests/standardization/test_ramp_client.py::test_find_pathway_overlaps_empty_result PASSED [ 63%]
tests/standardization/test_ramp_client.py::test_perform_chemical_enrichment PASSED [ 63%]
tests/standardization/test_ramp_client.py::test_full_metabolite_workflow PASSED [ 63%]
tests/standardization/test_ramp_client.py::test_full_analyte_workflow PASSED [ 63%]
tests/standardization/test_ramp_client.py::test_pathwaystats_dataclass PASSED [ 63%]
tests/standardization/test_ramp_client.py::test_get_pathway_by_analyte_basic PASSED [ 63%]
tests/standardization/test_ramp_client.py::test_get_pathway_by_analyte_with_type PASSED [ 63%]
tests/standardization/test_ramp_client.py::test_get_pathway_by_name PASSED [ 63%]
tests/standardization/test_ramp_client.py::test_get_pathway_by_ontology PASSED [ 63%]
tests/standardization/test_ramp_client.py::test_get_analytes_by_pathway PASSED [ 63%]
tests/standardization/test_ramp_client.py::test_get_analytes_by_ontology PASSED [ 63%]
tests/standardization/test_ramp_client.py::test_pathway_stats PASSED     [ 63%]
tests/standardization/test_ramp_client.py::test_analyze_pathway_stats_invalid_data PASSED [ 64%]
tests/standardization/test_ramp_client.py::test_find_pathway_overlaps_invalid_data PASSED [ 64%]
tests/standardization/test_ramp_client.py::test_get_pathway_info PASSED  [ 64%]
tests/standardization/test_ramp_client.py::test_get_metabolite_info PASSED [ 64%]
tests/unit/test_composite_id_splitter.py::TestCompositeIdSplitter::test_basic_splitting PASSED [ 64%]
tests/unit/test_composite_id_splitter.py::TestCompositeIdSplitter::test_custom_delimiter PASSED [ 64%]
tests/unit/test_composite_id_splitter.py::TestCompositeIdSplitter::test_no_splitting_needed PASSED [ 64%]
tests/unit/test_composite_id_splitter.py::TestCompositeIdSplitter::test_metadata_lineage_tracking PASSED [ 64%]
tests/unit/test_composite_id_splitter.py::TestCompositeIdSplitter::test_empty_input PASSED [ 64%]
tests/unit/test_composite_id_splitter.py::TestCompositeIdSplitter::test_missing_input_key PASSED [ 64%]
tests/unit/test_composite_id_splitter.py::TestCompositeIdSplitter::test_missing_required_params PASSED [ 64%]
tests/unit/test_composite_id_splitter.py::TestCompositeIdSplitter::test_duplicate_handling PASSED [ 65%]
tests/unit/test_composite_id_splitter.py::TestCompositeIdSplitter::test_provenance_tracking PASSED [ 65%]
tests/unit/test_composite_id_splitter.py::TestCompositeIdSplitter::test_empty_string_handling PASSED [ 65%]
tests/unit/test_composite_id_splitter.py::TestCompositeIdSplitter::test_multi_character_delimiter PASSED [ 65%]
tests/unit/test_composite_id_splitter.py::TestCompositeIdSplitter::test_special_character_delimiters PASSED [ 65%]
tests/unit/test_composite_id_splitter.py::TestCompositeIdSplitter::test_edge_case_delimiter_at_boundaries PASSED [ 65%]
tests/unit/test_composite_id_splitter.py::TestCompositeIdSplitter::test_very_long_composite_ids PASSED [ 65%]
tests/unit/test_composite_id_splitter.py::TestCompositeIdSplitter::test_context_details_structure PASSED [ 65%]
tests/unit/test_overlap_analyzer.py::TestDatasetOverlapAnalyzer::test_partial_overlap PASSED [ 65%]
tests/unit/test_overlap_analyzer.py::TestDatasetOverlapAnalyzer::test_full_overlap PASSED [ 65%]
tests/unit/test_overlap_analyzer.py::TestDatasetOverlapAnalyzer::test_no_overlap PASSED [ 65%]
tests/unit/test_overlap_analyzer.py::TestDatasetOverlapAnalyzer::test_with_statistics PASSED [ 66%]
tests/unit/test_overlap_analyzer.py::TestDatasetOverlapAnalyzer::test_empty_datasets PASSED [ 66%]
tests/unit/test_overlap_analyzer.py::TestDatasetOverlapAnalyzer::test_one_empty_dataset PASSED [ 66%]
tests/unit/test_overlap_analyzer.py::TestDatasetOverlapAnalyzer::test_missing_required_params PASSED [ 66%]
tests/unit/test_overlap_analyzer.py::TestDatasetOverlapAnalyzer::test_missing_dataset_keys_in_context PASSED [ 66%]
tests/unit/test_overlap_analyzer.py::TestDatasetOverlapAnalyzer::test_duplicate_handling PASSED [ 66%]
tests/unit/test_overlap_analyzer.py::TestDatasetOverlapAnalyzer::test_provenance_tracking PASSED [ 66%]
tests/unit/core/test_action_executor.py::TestActionExecutor::test_init PASSED [ 66%]
tests/unit/core/test_action_executor.py::TestActionExecutor::test_process_action_parameters_simple PASSED [ 66%]
tests/unit/core/test_action_executor.py::TestActionExecutor::test_process_action_parameters_context_reference PASSED [ 66%]
tests/unit/core/test_action_executor.py::TestActionExecutor::test_update_context_for_execution PASSED [ 66%]
tests/unit/core/test_action_executor.py::TestActionExecutor::test_normalize_action_result_complete PASSED [ 66%]
tests/unit/core/test_action_executor.py::TestActionExecutor::test_normalize_action_result_missing_fields PASSED [ 67%]
tests/unit/core/test_action_executor.py::TestActionExecutor::test_normalize_action_result_with_input_identifiers PASSED [ 67%]
tests/unit/core/test_action_executor.py::TestActionExecutor::test_execute_action_success PASSED [ 67%]
tests/unit/core/test_action_executor.py::TestActionExecutor::test_execute_action_with_context_references PASSED [ 67%]
tests/unit/core/test_action_executor.py::TestActionExecutor::test_execute_action_load_failure PASSED [ 67%]
tests/unit/core/test_action_executor.py::TestActionExecutor::test_execute_action_execution_failure PASSED [ 67%]
tests/unit/core/test_action_loader.py::TestActionLoader::test_init PASSED [ 67%]
tests/unit/core/test_action_loader.py::TestActionLoader::test_action_registry_lazy_loading PASSED [ 67%]
tests/unit/core/test_action_loader.py::TestActionLoader::test_load_action_class_from_registry PASSED [ 67%]
tests/unit/core/test_action_loader.py::TestActionLoader::test_load_action_class_from_path PASSED [ 67%]
tests/unit/core/test_action_loader.py::TestActionLoader::test_load_action_class_invalid_type PASSED [ 67%]
tests/unit/core/test_action_loader.py::TestActionLoader::test_load_action_class_import_error PASSED [ 68%]
tests/unit/core/test_action_loader.py::TestActionLoader::test_load_action_class_attribute_error PASSED [ 68%]
tests/unit/core/test_action_loader.py::TestActionLoader::test_load_action_class_not_strategy_action PASSED [ 68%]
tests/unit/core/test_action_loader.py::TestActionLoader::test_instantiate_action PASSED [ 68%]
tests/unit/core/test_action_loader.py::TestActionLoader::test_instantiate_action_failure PASSED [ 68%]
tests/unit/core/test_action_loader.py::TestActionLoader::test_module_caching PASSED [ 68%]
tests/unit/core/test_mapping_executor.py::TestMappingExecutorDelegation::test_execute_mapping_delegates_to_mapping_coordinator SKIPPED [ 68%]
tests/unit/core/test_mapping_executor.py::TestMappingExecutorDelegation::test_execute_path_delegates_to_mapping_coordinator SKIPPED [ 68%]
tests/unit/core/test_mapping_executor.py::TestMappingExecutorDelegation::test_execute_strategy_delegates_to_strategy_coordinator SKIPPED [ 68%]
tests/unit/core/test_mapping_executor.py::TestMappingExecutorDelegation::test_execute_yaml_strategy_delegates_to_strategy_coordinator SKIPPED [ 68%]
tests/unit/core/test_mapping_executor.py::TestMappingExecutorDelegation::test_execute_yaml_strategy_robust_delegates_to_strategy_coordinator SKIPPED [ 68%]
tests/unit/core/test_mapping_executor.py::TestMappingExecutorDelegation::test_async_dispose_delegates_to_lifecycle_manager SKIPPED [ 69%]
tests/unit/core/test_mapping_executor.py::TestMappingExecutorDelegation::test_save_checkpoint_delegates_to_lifecycle_manager SKIPPED [ 69%]
tests/unit/core/test_mapping_executor.py::TestMappingExecutorDelegation::test_load_checkpoint_delegates_to_lifecycle_manager SKIPPED [ 69%]
tests/unit/core/test_mapping_executor.py::TestMappingExecutorDelegation::test_add_progress_callback_delegates_to_lifecycle_manager SKIPPED [ 69%]
tests/unit/core/test_mapping_executor.py::TestMappingExecutorDelegation::test_get_endpoint_by_name_delegates_to_metadata_query_service SKIPPED [ 69%]
tests/unit/core/test_mapping_executor.py::TestMappingExecutorDelegation::test_get_ontology_column_delegates_to_identifier_loader SKIPPED [ 69%]
tests/unit/core/test_mapping_executor.py::TestMappingExecutorDelegation::test_load_endpoint_identifiers_delegates_to_identifier_loader SKIPPED [ 69%]
tests/unit/core/test_mapping_executor.py::TestMappingExecutorDelegation::test_load_client_delegates_to_client_manager SKIPPED [ 69%]
tests/unit/core/test_mapping_executor.py::TestMappingExecutorDelegation::test_get_strategy_delegates_to_metadata_query_service SKIPPED [ 69%]
tests/unit/core/test_mapping_executor.py::TestMappingExecutorDelegation::test_report_progress_delegates_to_lifecycle_manager SKIPPED [ 69%]
tests/unit/core/test_mapping_executor.py::TestMappingExecutorDelegation::test_checkpoint_dir_property_delegates_to_lifecycle_manager SKIPPED [ 69%]
tests/unit/core/test_mapping_executor.py::TestMappingExecutorInitialization::test_create_factory_method_delegates_to_initializer SKIPPED [ 69%]
tests/unit/core/test_mapping_executor.py::TestMappingExecutorComplexMethods::test_execute_with_retry_delegates_and_handles_retries SKIPPED [ 70%]
tests/unit/core/test_mapping_executor.py::TestMappingExecutorComplexMethods::test_process_in_batches_delegates_batch_operations SKIPPED [ 70%]
tests/unit/core/test_mapping_executor_robust_features.py::TestCheckpointing::test_checkpoint_directory_creation PASSED [ 70%]
tests/unit/core/test_mapping_executor_robust_features.py::TestCheckpointing::test_checkpoint_save_and_load PASSED [ 70%]
tests/unit/core/test_mapping_executor_robust_features.py::TestCheckpointing::test_checkpoint_resume_execution PASSED [ 70%]
tests/unit/core/test_mapping_executor_robust_features.py::TestCheckpointing::test_checkpoint_with_corrupted_file PASSED [ 70%]
tests/unit/core/test_mapping_executor_robust_features.py::TestRetryMechanisms::test_retry_on_transient_failure PASSED [ 70%]
tests/unit/core/test_mapping_executor_robust_features.py::TestRetryMechanisms::test_retry_exhaustion PASSED [ 70%]
tests/unit/core/test_mapping_executor_robust_features.py::TestRetryMechanisms::test_retry_delay PASSED [ 70%]
tests/unit/core/test_mapping_executor_robust_features.py::TestBatchProcessing::test_batch_size_processing PASSED [ 70%]
tests/unit/core/test_mapping_executor_robust_features.py::TestBatchProcessing::test_batch_aggregation PASSED [ 70%]
tests/unit/core/test_mapping_executor_robust_features.py::TestBatchProcessing::test_edge_case_batch_sizes PASSED [ 71%]
tests/unit/core/test_mapping_executor_robust_features.py::TestProgressCallbacks::test_progress_callback_invocation PASSED [ 71%]
tests/unit/core/test_mapping_executor_robust_features.py::TestProgressCallbacks::test_multiple_progress_callbacks PASSED [ 71%]
tests/unit/core/test_mapping_executor_robust_features.py::TestProgressCallbacks::test_callback_with_batch_processing PASSED [ 71%]
tests/unit/core/test_mapping_executor_robust_features.py::TestIntegration::test_checkpoint_with_retry PASSED [ 71%]
tests/unit/core/test_mapping_executor_robust_features.py::TestIntegration::test_batch_processing_with_progress PASSED [ 71%]
tests/unit/core/test_mapping_executor_utilities.py::TestGetStrategy::test_get_strategy_success PASSED [ 71%]
tests/unit/core/test_mapping_executor_utilities.py::TestGetStrategy::test_get_strategy_not_found PASSED [ 71%]
tests/unit/core/test_mapping_executor_utilities.py::TestGetStrategy::test_get_strategy_database_error PASSED [ 71%]
tests/unit/core/test_mapping_executor_utilities.py::TestGetOntologyColumn::test_get_ontology_column_success PASSED [ 71%]
tests/unit/core/test_mapping_executor_utilities.py::TestGetOntologyColumn::test_get_ontology_column_endpoint_not_found PASSED [ 71%]
tests/unit/core/test_mapping_executor_utilities.py::TestGetOntologyColumn::test_get_ontology_column_property_config_not_found PASSED [ 72%]
tests/unit/core/test_mapping_executor_utilities.py::TestGetOntologyColumn::test_get_ontology_column_invalid_json PASSED [ 72%]
tests/unit/core/test_mapping_executor_utilities.py::TestLoadEndpointIdentifiers::test_load_endpoint_identifiers_success PASSED [ 72%]
tests/unit/core/test_mapping_executor_utilities.py::TestLoadEndpointIdentifiers::test_load_endpoint_identifiers_return_dataframe PASSED [ 72%]
tests/unit/core/test_mapping_executor_utilities.py::TestLoadEndpointIdentifiers::test_load_endpoint_identifiers_file_not_found PASSED [ 72%]
tests/unit/core/test_mapping_executor_utilities.py::TestLoadEndpointIdentifiers::test_load_endpoint_identifiers_column_not_found PASSED [ 72%]
tests/unit/core/test_mapping_executor_utilities.py::TestGetStrategyInfo::test_get_strategy_info_success PASSED [ 72%]
tests/unit/core/test_mapping_executor_utilities.py::TestGetStrategyInfo::test_get_strategy_info_not_found PASSED [ 72%]
tests/unit/core/test_mapping_executor_utilities.py::TestValidateStrategyPrerequisites::test_validate_prerequisites_all_valid PASSED [ 72%]
tests/unit/core/test_mapping_executor_utilities.py::TestValidateStrategyPrerequisites::test_validate_prerequisites_strategy_not_found PASSED [ 72%]
tests/unit/core/test_mapping_executor_utilities.py::TestValidateStrategyPrerequisites::test_validate_prerequisites_inactive_strategy PASSED [ 72%]
tests/unit/core/test_mapping_executor_utilities.py::TestValidateStrategyPrerequisites::test_validate_prerequisites_endpoint_not_found PASSED [ 72%]
tests/unit/core/test_mapping_executor_utilities.py::TestValidateStrategyPrerequisites::test_validate_prerequisites_file_not_found PASSED [ 73%]
tests/unit/core/test_mapping_executor_utilities.py::TestExecuteStrategyWithComprehensiveResults::test_execute_comprehensive_success PASSED [ 73%]
tests/unit/core/test_mapping_executor_utilities.py::TestExecuteStrategyWithComprehensiveResults::test_execute_comprehensive_with_empty_results PASSED [ 73%]
tests/unit/core/test_path_finder.py::test_find_direct_paths PASSED       [ 73%]
tests/unit/core/test_path_finder.py::test_find_mapping_paths_direct PASSED [ 73%]
tests/unit/core/test_path_finder.py::test_find_mapping_paths_bidirectional PASSED [ 73%]
tests/unit/core/test_path_finder.py::test_find_best_path PASSED          [ 73%]
tests/unit/core/test_path_finder.py::test_get_path_details PASSED        [ 73%]
tests/unit/core/test_path_finder.py::test_cache_functionality PASSED     [ 73%]
tests/unit/core/test_path_finder.py::test_clear_cache PASSED             [ 73%]
tests/unit/core/test_reversible_path.py::TestReversiblePath::test_init_forward PASSED [ 73%]
tests/unit/core/test_reversible_path.py::TestReversiblePath::test_init_reverse PASSED [ 74%]
tests/unit/core/test_reversible_path.py::TestReversiblePath::test_id_property PASSED [ 74%]
tests/unit/core/test_reversible_path.py::TestReversiblePath::test_name_forward PASSED [ 74%]
tests/unit/core/test_reversible_path.py::TestReversiblePath::test_name_reverse PASSED [ 74%]
tests/unit/core/test_reversible_path.py::TestReversiblePath::test_priority_forward PASSED [ 74%]
tests/unit/core/test_reversible_path.py::TestReversiblePath::test_priority_reverse PASSED [ 74%]
tests/unit/core/test_reversible_path.py::TestReversiblePath::test_priority_none_handling PASSED [ 74%]
tests/unit/core/test_reversible_path.py::TestReversiblePath::test_steps_forward PASSED [ 74%]
tests/unit/core/test_reversible_path.py::TestReversiblePath::test_steps_reverse PASSED [ 74%]
tests/unit/core/test_reversible_path.py::TestReversiblePath::test_steps_reverse_with_none_order PASSED [ 74%]
tests/unit/core/test_reversible_path.py::TestReversiblePath::test_getattr_delegation PASSED [ 74%]
tests/unit/core/test_reversible_path.py::TestReversiblePath::test_getattr_missing_attribute PASSED [ 75%]
tests/unit/core/test_strategy_handler.py::TestStrategyHandler::test_init PASSED [ 75%]
tests/unit/core/test_strategy_handler.py::TestStrategyHandler::test_load_strategy_success PASSED [ 75%]
tests/unit/core/test_strategy_handler.py::TestStrategyHandler::test_load_strategy_not_found PASSED [ 75%]
tests/unit/core/test_strategy_handler.py::TestStrategyHandler::test_load_strategy_inactive PASSED [ 75%]
tests/unit/core/test_strategy_handler.py::TestStrategyHandler::test_validate_strategy_steps_success PASSED [ 75%]
tests/unit/core/test_strategy_handler.py::TestStrategyHandler::test_validate_strategy_steps_no_steps PASSED [ 75%]
tests/unit/core/test_strategy_handler.py::TestStrategyHandler::test_validate_strategy_steps_duplicate_orders PASSED [ 75%]
tests/unit/core/test_strategy_handler.py::TestStrategyHandler::test_validate_strategy_steps_no_action_type PASSED [ 75%]
tests/unit/core/test_strategy_handler.py::TestStrategyHandler::test_validate_strategy_steps_active_no_params PASSED [ 75%]
tests/unit/core/test_strategy_handler.py::TestStrategyHandler::test_get_endpoint_by_name PASSED [ 75%]
tests/unit/core/engine_components/test_initialization_service.py::TestInitializationService::test_default_creation PASSED [ 75%]
tests/unit/core/engine_components/test_initialization_service.py::TestInitializationService::test_custom_configuration PASSED [ 76%]
tests/unit/core/engine_components/test_initialization_service.py::TestInitializationService::test_component_dependencies PASSED [ 76%]
tests/unit/core/engine_components/test_initialization_service.py::TestInitializationService::test_convenience_session_references PASSED [ 76%]
tests/unit/core/engine_components/test_initialization_service.py::TestInitializationService::test_all_create_methods_called PASSED [ 76%]
tests/unit/core/engine_components/test_initialization_service.py::TestInitializationService::test_default_settings_used PASSED [ 76%]
tests/unit/core/engine_components/test_initialization_service.py::TestInitializationService::test_logging_messages PASSED [ 76%]
tests/unit/core/engine_components/test_initialization_service.py::TestInitializationService::test_complete_initialization PASSED [ 76%]
tests/unit/core/engine_components/test_initialization_service.py::TestInitializationService::test_complete_initialization_creates_services PASSED [ 76%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_initialization PASSED [ 76%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_initialization_with_custom_logger PASSED [ 76%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_async_dispose PASSED [ 76%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_async_dispose_with_error PASSED [ 77%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_checkpoint_dir_getter PASSED [ 77%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_checkpoint_dir_setter PASSED [ 77%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_checkpoint_dir_setter_none PASSED [ 77%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_checkpoint_enabled_property PASSED [ 77%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_save_checkpoint PASSED [ 77%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_save_checkpoint_with_complex_data PASSED [ 77%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_load_checkpoint PASSED [ 77%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_load_checkpoint_not_found PASSED [ 77%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_report_progress PASSED [ 77%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_add_progress_callback PASSED [ 77%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_remove_progress_callback PASSED [ 77%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_multiple_callbacks PASSED [ 78%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_start_execution PASSED [ 78%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_start_execution_without_metadata PASSED [ 78%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_complete_execution PASSED [ 78%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_complete_execution_without_summary PASSED [ 78%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_fail_execution PASSED [ 78%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_fail_execution_without_context PASSED [ 78%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_report_batch_progress PASSED [ 78%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_report_batch_progress_without_metadata PASSED [ 78%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_save_batch_checkpoint PASSED [ 78%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_save_batch_checkpoint_without_metadata PASSED [ 78%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_full_execution_lifecycle PASSED [ 79%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_execution_with_error_handling PASSED [ 79%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_concurrent_operations PASSED [ 79%]
tests/unit/core/engine_components/test_lifecycle_coordinator.py::TestLifecycleCoordinator::test_backward_compatibility_interface PASSED [ 79%]
tests/unit/core/engine_components/test_mapping_executor_builder.py::TestMappingExecutorBuilder::test_build_orchestration PASSED [ 79%]
tests/unit/core/engine_components/test_mapping_executor_builder.py::TestMappingExecutorBuilder::test_post_build_reference_setting PASSED [ 79%]
tests/unit/core/engine_components/test_mapping_executor_builder.py::TestMappingExecutorBuilder::test_build_async PASSED [ 79%]
tests/unit/core/engine_components/test_mapping_executor_builder.py::TestMappingExecutorBuilder::test_create_lifecycle_coordinator PASSED [ 79%]
tests/unit/core/engine_components/test_mapping_executor_builder.py::TestMappingExecutorBuilder::test_create_mapping_coordinator PASSED [ 79%]
tests/unit/core/engine_components/test_mapping_executor_builder.py::TestMappingExecutorBuilder::test_create_strategy_coordinator PASSED [ 79%]
tests/unit/core/engine_components/test_mapping_executor_builder.py::TestMappingExecutorBuilder::test_initialization_with_empty_config PASSED [ 79%]
tests/unit/core/engine_components/test_mapping_executor_builder.py::TestMappingExecutorBuilder::test_initialization_with_config PASSED [ 80%]
tests/unit/core/services/test_bidirectional_validation_service.py::TestBidirectionalValidationService::test_validate_mappings_no_mappings PASSED [ 80%]
tests/unit/core/services/test_bidirectional_validation_service.py::TestBidirectionalValidationService::test_validate_mappings_no_reverse_path PASSED [ 80%]
tests/unit/core/services/test_bidirectional_validation_service.py::TestBidirectionalValidationService::test_validate_mappings_with_reverse_path PASSED [ 80%]
tests/unit/core/services/test_bidirectional_validation_service.py::TestBidirectionalValidationService::test_extract_target_ids PASSED [ 80%]
tests/unit/core/services/test_bidirectional_validation_service.py::TestBidirectionalValidationService::test_normalize_arivale_id PASSED [ 80%]
tests/unit/core/services/test_bidirectional_validation_service.py::TestBidirectionalValidationService::test_reconcile_bidirectional_mappings_validated PASSED [ 80%]
tests/unit/core/services/test_bidirectional_validation_service.py::TestBidirectionalValidationService::test_reconcile_bidirectional_mappings_ambiguous PASSED [ 80%]
tests/unit/core/services/test_bidirectional_validation_service.py::TestBidirectionalValidationService::test_reconcile_bidirectional_mappings_no_reverse_path PASSED [ 80%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_initialization_without_checkpoint_dir PASSED [ 80%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_initialization_with_checkpoint_dir PASSED [ 80%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_set_checkpoint_directory PASSED [ 80%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_disable_checkpointing PASSED [ 81%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_save_checkpoint_enabled PASSED [ 81%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_save_checkpoint_disabled PASSED [ 81%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_save_checkpoint_error PASSED [ 81%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_load_checkpoint_enabled PASSED [ 81%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_load_checkpoint_disabled PASSED [ 81%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_load_checkpoint_not_found PASSED [ 81%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_checkpoint_exists PASSED [ 81%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_delete_checkpoint PASSED [ 81%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_save_batch_checkpoint_enabled PASSED [ 81%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_save_batch_checkpoint_disabled PASSED [ 81%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_load_batch_checkpoint PASSED [ 82%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_get_checkpoint_path PASSED [ 82%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_cleanup_old_checkpoints PASSED [ 82%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_validate_checkpoint_data PASSED [ 82%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_save_checkpoint_large_data PASSED [ 82%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_concurrent_checkpoint_operations PASSED [ 82%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_set_checkpoint_directory_with_invalid_path PASSED [ 82%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_save_batch_checkpoint_edge_cases PASSED [ 82%]
tests/unit/core/services/test_checkpoint_service.py::TestCheckpointService::test_load_checkpoint_with_corrupted_data PASSED [ 82%]
tests/unit/core/services/test_execution_session_service.py::TestExecutionSessionService::test_start_session PASSED [ 82%]
tests/unit/core/services/test_execution_session_service.py::TestExecutionSessionService::test_complete_session PASSED [ 82%]
tests/unit/core/services/test_execution_session_service.py::TestExecutionSessionService::test_fail_session PASSED [ 83%]
tests/unit/core/services/test_execution_session_service.py::TestExecutionSessionService::test_complete_unknown_session PASSED [ 83%]
tests/unit/core/services/test_execution_session_service.py::TestExecutionSessionService::test_report_progress PASSED [ 83%]
tests/unit/core/services/test_execution_session_service.py::TestExecutionSessionService::test_report_batch_progress PASSED [ 83%]
tests/unit/core/services/test_execution_session_service.py::TestExecutionSessionService::test_add_progress_callback PASSED [ 83%]
tests/unit/core/services/test_execution_session_service.py::TestExecutionSessionService::test_remove_progress_callback PASSED [ 83%]
tests/unit/core/services/test_execution_session_service.py::TestExecutionSessionService::test_get_active_sessions PASSED [ 83%]
tests/unit/core/services/test_execution_session_service.py::TestExecutionSessionService::test_get_session_info PASSED [ 83%]
tests/unit/core/services/test_execution_session_service.py::TestExecutionSessionService::test_is_session_active PASSED [ 83%]
tests/unit/core/services/test_execution_session_service.py::TestExecutionSessionService::test_start_session_with_empty_metadata PASSED [ 83%]
tests/unit/core/services/test_execution_session_service.py::TestExecutionSessionService::test_multiple_session_lifecycle PASSED [ 83%]
tests/unit/core/services/test_execution_session_service.py::TestExecutionSessionService::test_report_progress_with_complex_data PASSED [ 83%]
tests/unit/core/services/test_execution_session_service.py::TestExecutionSessionService::test_fail_session_with_custom_exception PASSED [ 84%]
tests/unit/core/services/test_execution_session_service.py::TestExecutionSessionService::test_report_batch_progress_edge_cases PASSED [ 84%]
tests/unit/core/services/test_execution_session_service.py::TestExecutionSessionService::test_session_service_callbacks_propagation PASSED [ 84%]
tests/unit/core/services/test_execution_session_service.py::TestExecutionSessionService::test_session_concurrent_operations PASSED [ 84%]
tests/unit/core/services/test_mapping_step_execution_service.py::test_execute_step_client_error PASSED [ 84%]
tests/unit/core/services/test_mapping_step_execution_service.py::test_execute_step_generic_exception PASSED [ 84%]
tests/unit/core/services/test_mapping_step_execution_service.py::test_execute_step_reverse_mapping PASSED [ 84%]
tests/unit/core/services/test_mapping_step_execution_service.py::test_execute_step_with_cache_hit PASSED [ 84%]
tests/unit/core/services/test_mapping_step_execution_service.py::test_execute_step_partial_cache_hit PASSED [ 84%]
tests/unit/core/services/test_mapping_step_execution_service.py::test_execute_step_client_initialization_error PASSED [ 84%]
tests/unit/core/services/test_metadata_query_service.py::test_get_ontology_type_success PASSED [ 84%]
tests/unit/core/services/test_metadata_query_service.py::test_get_ontology_type_not_found PASSED [ 85%]
tests/unit/core/services/test_metadata_query_service.py::test_get_ontology_type_sql_error PASSED [ 85%]
tests/unit/core/services/test_metadata_query_service.py::test_get_endpoint_success PASSED [ 85%]
tests/unit/core/services/test_metadata_query_service.py::test_get_endpoint_not_found PASSED [ 85%]
tests/unit/core/services/test_metadata_query_service.py::test_get_endpoint_properties_success PASSED [ 85%]
tests/unit/core/services/test_metadata_query_service.py::test_get_ontology_preferences_success PASSED [ 85%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_initialization PASSED [ 85%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_dispose_all PASSED [ 85%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_dispose_all_idempotent PASSED [ 85%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_dispose_metamapper_engine PASSED [ 85%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_dispose_cache_engine PASSED [ 85%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_clear_client_cache PASSED [ 86%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_dispose_all_without_client_manager PASSED [ 86%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_dispose_all_without_engines PASSED [ 86%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_dispose_all_with_errors PASSED [ 86%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_dispose_on_error PASSED [ 86%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_dispose_on_error_with_disposal_failure PASSED [ 86%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_get_resource_status PASSED [ 86%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_get_resource_status_partial PASSED [ 86%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_verify_disposal PASSED [ 86%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_verify_disposal_incomplete PASSED [ 86%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_context_manager PASSED [ 86%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_clear_client_cache_without_manager PASSED [ 86%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_dispose_metamapper_engine_not_exists PASSED [ 87%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_dispose_cache_engine_not_exists PASSED [ 87%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_dispose_with_slow_engines PASSED [ 87%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_dispose_on_error_with_context PASSED [ 87%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_get_resource_status_after_partial_disposal PASSED [ 87%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_concurrent_disposal_calls PASSED [ 87%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_dispose_specific_engines_sequence PASSED [ 87%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_context_manager_with_error PASSED [ 87%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_verify_disposal_with_partial_cleanup PASSED [ 87%]
tests/unit/core/services/test_resource_disposal_service.py::TestResourceDisposalService::test_resource_status_with_no_session_manager PASSED [ 87%]
tests/unit/core/strategy_actions/test_bidirectional_match.py::TestBidirectionalMatchAction::test_empty_input_returns_empty_result PASSED [ 87%]
tests/unit/core/strategy_actions/test_bidirectional_match.py::TestBidirectionalMatchAction::test_missing_required_parameters_raises_error PASSED [ 88%]
tests/unit/core/strategy_actions/test_bidirectional_match.py::TestBidirectionalMatchAction::test_basic_matching_many_to_many PASSED [ 88%]
tests/unit/core/strategy_actions/test_bidirectional_match.py::TestBidirectionalMatchAction::test_composite_identifier_handling PASSED [ 88%]
tests/unit/core/strategy_actions/test_bidirectional_match.py::TestBidirectionalMatchAction::test_composite_handling_both_mode PASSED [ 88%]
tests/unit/core/strategy_actions/test_bidirectional_match.py::TestBidirectionalMatchAction::test_one_to_one_matching_mode PASSED [ 88%]
tests/unit/core/strategy_actions/test_bidirectional_match.py::TestBidirectionalMatchAction::test_custom_context_keys PASSED [ 88%]
tests/unit/core/strategy_actions/test_bidirectional_match.py::TestBidirectionalMatchAction::test_error_handling PASSED [ 88%]
tests/unit/core/strategy_actions/test_bidirectional_match.py::TestBidirectionalMatchAction::test_provenance_tracking PASSED [ 88%]
tests/unit/core/strategy_actions/test_bidirectional_match.py::TestBidirectionalMatchAction::test_empty_endpoint_data PASSED [ 88%]
tests/unit/core/strategy_actions/test_execute_mapping_path.py::TestExecuteMappingPathAction::test_successful_execution PASSED [ 88%]
tests/unit/core/strategy_actions/test_execute_mapping_path.py::TestExecuteMappingPathAction::test_nonexistent_mapping_path PASSED [ 88%]
tests/unit/core/strategy_actions/test_execute_mapping_path.py::TestExecuteMappingPathAction::test_missing_path_name PASSED [ 88%]
tests/unit/core/strategy_actions/test_execute_mapping_path.py::TestExecuteMappingPathAction::test_missing_mapping_executor PASSED [ 89%]
tests/unit/core/strategy_actions/test_execute_mapping_path.py::TestExecuteMappingPathAction::test_executor_error_propagation PASSED [ 89%]
tests/unit/core/strategy_actions/test_execute_mapping_path.py::TestExecuteMappingPathAction::test_default_cache_settings PASSED [ 89%]
tests/unit/core/strategy_actions/test_execute_mapping_path.py::TestExecuteMappingPathAction::test_all_unmapped_identifiers PASSED [ 89%]
tests/unit/core/strategy_actions/test_execute_mapping_path.py::TestExecuteMappingPathAction::test_empty_input_identifiers PASSED [ 89%]
tests/unit/core/strategy_actions/test_export_results.py::TestExportResultsAction::test_export_to_csv PASSED [ 89%]
tests/unit/core/strategy_actions/test_export_results.py::TestExportResultsAction::test_export_to_json PASSED [ 89%]
tests/unit/core/strategy_actions/test_export_results.py::TestExportResultsAction::test_export_with_column_filtering PASSED [ 89%]
tests/unit/core/strategy_actions/test_export_results.py::TestExportResultsAction::test_export_to_context PASSED [ 89%]
tests/unit/core/strategy_actions/test_export_results.py::TestExportResultsAction::test_export_with_provenance PASSED [ 89%]
tests/unit/core/strategy_actions/test_export_results.py::TestExportResultsAction::test_error_on_missing_output_destination PASSED [ 89%]
tests/unit/core/strategy_actions/test_export_results.py::TestExportResultsAction::test_invalid_output_format PASSED [ 90%]
tests/unit/core/strategy_actions/test_export_results.py::TestExportResultsAction::test_handles_unmapped_identifiers PASSED [ 90%]
tests/unit/core/strategy_actions/test_filter_by_target_presence.py::TestFilterByTargetPresenceAction::test_basic_filtering_without_conversion PASSED [ 90%]
tests/unit/core/strategy_actions/test_filter_by_target_presence.py::TestFilterByTargetPresenceAction::test_filtering_with_conversion_path PASSED [ 90%]
tests/unit/core/strategy_actions/test_filter_by_target_presence.py::TestFilterByTargetPresenceAction::test_empty_target_endpoint PASSED [ 90%]
tests/unit/core/strategy_actions/test_filter_by_target_presence.py::TestFilterByTargetPresenceAction::test_all_identifiers_filtered PASSED [ 90%]
tests/unit/core/strategy_actions/test_filter_by_target_presence.py::TestFilterByTargetPresenceAction::test_no_identifiers_filtered PASSED [ 90%]
tests/unit/core/strategy_actions/test_filter_by_target_presence.py::TestFilterByTargetPresenceAction::test_invalid_endpoint_context PASSED [ 90%]
tests/unit/core/strategy_actions/test_filter_by_target_presence.py::TestFilterByTargetPresenceAction::test_missing_ontology_type_to_match PASSED [ 90%]
tests/unit/core/strategy_actions/test_filter_by_target_presence.py::TestFilterByTargetPresenceAction::test_missing_property_config PASSED [ 90%]
tests/unit/core/strategy_actions/test_filter_by_target_presence.py::TestFilterByTargetPresenceAction::test_empty_input_identifiers PASSED [ 90%]
tests/unit/core/strategy_actions/test_filter_by_target_presence.py::TestFilterByTargetPresenceAction::test_duplicate_identifiers_in_target PASSED [ 91%]
tests/unit/core/strategy_actions/test_filter_by_target_presence_edge_cases.py::TestFilterByTargetPresenceEdgeCases::test_composite_identifiers PASSED [ 91%]
tests/unit/core/strategy_actions/test_filter_by_target_presence_edge_cases.py::TestFilterByTargetPresenceEdgeCases::test_whitespace_handling PASSED [ 91%]
tests/unit/core/strategy_actions/test_filter_by_target_presence_edge_cases.py::TestFilterByTargetPresenceEdgeCases::test_null_and_empty_values PASSED [ 91%]
tests/unit/core/strategy_actions/test_filter_by_target_presence_edge_cases.py::TestFilterByTargetPresenceEdgeCases::test_case_sensitivity PASSED [ 91%]
tests/unit/core/strategy_actions/test_filter_by_target_presence_edge_cases.py::TestFilterByTargetPresenceEdgeCases::test_large_dataset_performance PASSED [ 91%]
tests/unit/core/strategy_actions/test_filter_by_target_presence_edge_cases.py::TestFilterByTargetPresenceEdgeCases::test_special_characters_in_identifiers PASSED [ 91%]
tests/unit/core/strategy_actions/test_generate_detailed_report.py::TestGenerateDetailedReportAction::test_generate_markdown_report PASSED [ 91%]
tests/unit/core/strategy_actions/test_generate_detailed_report.py::TestGenerateDetailedReportAction::test_grouping_by_ontology PASSED [ 91%]
tests/unit/core/strategy_actions/test_generate_detailed_report.py::TestGenerateDetailedReportAction::test_grouping_by_method PASSED [ 91%]
tests/unit/core/strategy_actions/test_generate_detailed_report.py::TestGenerateDetailedReportAction::test_unmatched_analysis PASSED [ 91%]
tests/unit/core/strategy_actions/test_generate_detailed_report.py::TestGenerateDetailedReportAction::test_relationship_analysis PASSED [ 91%]
tests/unit/core/strategy_actions/test_generate_detailed_report.py::TestGenerateDetailedReportAction::test_html_output PASSED [ 92%]
tests/unit/core/strategy_actions/test_generate_detailed_report.py::TestGenerateDetailedReportAction::test_exclude_unmatched PASSED [ 92%]
tests/unit/core/strategy_actions/test_generate_detailed_report.py::TestGenerateDetailedReportAction::test_invalid_grouping_strategy PASSED [ 92%]
tests/unit/core/strategy_actions/test_generate_mapping_summary.py::TestGenerateMappingSummaryAction::test_console_output_summary PASSED [ 92%]
tests/unit/core/strategy_actions/test_generate_mapping_summary.py::TestGenerateMappingSummaryAction::test_json_output_to_file PASSED [ 92%]
tests/unit/core/strategy_actions/test_generate_mapping_summary.py::TestGenerateMappingSummaryAction::test_csv_output PASSED [ 92%]
tests/unit/core/strategy_actions/test_generate_mapping_summary.py::TestGenerateMappingSummaryAction::test_save_to_context PASSED [ 92%]
tests/unit/core/strategy_actions/test_generate_mapping_summary.py::TestGenerateMappingSummaryAction::test_without_statistics PASSED [ 92%]
tests/unit/core/strategy_actions/test_generate_mapping_summary.py::TestGenerateMappingSummaryAction::test_empty_input_handling PASSED [ 92%]
tests/unit/core/strategy_actions/test_local_id_converter.py::TestLocalIdConverter::test_successful_conversion PASSED [ 92%]
tests/unit/core/strategy_actions/test_local_id_converter.py::TestLocalIdConverter::test_missing_required_parameters PASSED [ 92%]
tests/unit/core/strategy_actions/test_local_id_converter.py::TestLocalIdConverter::test_composite_identifier_expansion PASSED [ 93%]
tests/unit/core/strategy_actions/test_local_id_converter.py::TestLocalIdConverter::test_no_composite_expansion PASSED [ 93%]
tests/unit/core/strategy_actions/test_local_id_converter.py::TestLocalIdConverter::test_context_key_usage PASSED [ 93%]
tests/unit/core/strategy_actions/test_local_id_converter.py::TestLocalIdConverter::test_empty_input_identifiers PASSED [ 93%]
tests/unit/core/strategy_actions/test_local_id_converter.py::TestLocalIdConverter::test_nonexistent_mapping_file PASSED [ 93%]
tests/unit/core/strategy_actions/test_local_id_converter.py::TestLocalIdConverter::test_invalid_column_names PASSED [ 93%]
tests/unit/core/strategy_actions/test_local_id_converter.py::TestLocalIdConverter::test_csv_delimiter_autodetection PASSED [ 93%]
tests/unit/core/strategy_actions/test_local_id_converter.py::TestLocalIdConverter::test_custom_composite_delimiter PASSED [ 93%]
tests/unit/core/strategy_actions/test_local_id_converter.py::TestLocalIdConverter::test_environment_variable_expansion PASSED [ 93%]
tests/unit/core/strategy_actions/test_local_id_converter.py::TestLocalIdConverter::test_provenance_tracking PASSED [ 93%]
tests/unit/core/strategy_actions/test_resolve_and_match_forward.py::TestResolveAndMatchForwardAction::test_basic_resolution_and_matching PASSED [ 93%]
tests/unit/core/strategy_actions/test_resolve_and_match_forward.py::TestResolveAndMatchForwardAction::test_composite_identifier_handling PASSED [ 94%]
tests/unit/core/strategy_actions/test_resolve_and_match_forward.py::TestResolveAndMatchForwardAction::test_error_handling PASSED [ 94%]
tests/unit/core/strategy_actions/test_resolve_and_match_forward.py::TestResolveAndMatchForwardAction::test_empty_input PASSED [ 94%]
tests/unit/core/strategy_actions/test_resolve_and_match_forward.py::TestResolveAndMatchForwardAction::test_batch_processing PASSED [ 94%]
tests/unit/core/strategy_actions/test_resolve_and_match_forward.py::TestResolveAndMatchForwardAction::test_many_to_many_vs_one_to_one_mode PASSED [ 94%]
tests/unit/core/strategy_actions/test_resolve_and_match_forward.py::TestResolveAndMatchForwardAction::test_provenance_tracking PASSED [ 94%]
tests/unit/core/strategy_actions/test_resolve_and_match_forward.py::TestResolveAndMatchForwardAction::test_resolver_api_failure_handling PASSED [ 94%]
tests/unit/core/strategy_actions/test_resolve_and_match_reverse.py::TestResolveAndMatchReverse::test_basic_reverse_resolution_and_matching PASSED [ 94%]
tests/unit/core/strategy_actions/test_resolve_and_match_reverse.py::TestResolveAndMatchReverse::test_composite_identifier_handling PASSED [ 94%]
tests/unit/core/strategy_actions/test_resolve_and_match_reverse.py::TestResolveAndMatchReverse::test_many_to_many_mapping PASSED [ 94%]
tests/unit/core/strategy_actions/test_resolve_and_match_reverse.py::TestResolveAndMatchReverse::test_one_to_one_mode PASSED [ 94%]
tests/unit/core/strategy_actions/test_resolve_and_match_reverse.py::TestResolveAndMatchReverse::test_empty_input_handling PASSED [ 94%]
tests/unit/core/strategy_actions/test_resolve_and_match_reverse.py::TestResolveAndMatchReverse::test_missing_required_parameters PASSED [ 95%]
tests/unit/core/strategy_actions/test_resolve_and_match_reverse.py::TestResolveAndMatchReverse::test_batch_processing PASSED [ 95%]
tests/unit/core/strategy_actions/test_resolve_and_match_reverse.py::TestResolveAndMatchReverse::test_context_append_behavior PASSED [ 95%]
tests/unit/core/strategy_actions/test_resolve_and_match_reverse.py::TestResolveAndMatchReverse::test_resolver_exception_handling PASSED [ 95%]
tests/unit/core/strategy_actions/test_resolve_and_match_reverse.py::TestResolveAndMatchReverse::test_complex_composite_scenarios PASSED [ 95%]
tests/unit/core/strategy_actions/test_visualize_mapping_flow.py::TestVisualizeMappingFlowAction::test_json_visualization_output PASSED [ 95%]
tests/unit/core/strategy_actions/test_visualize_mapping_flow.py::TestVisualizeMappingFlowAction::test_sankey_diagram_generation PASSED [ 95%]
tests/unit/core/strategy_actions/test_visualize_mapping_flow.py::TestVisualizeMappingFlowAction::test_flow_diagram_generation PASSED [ 95%]
tests/unit/core/strategy_actions/test_visualize_mapping_flow.py::TestVisualizeMappingFlowAction::test_bar_chart_with_matplotlib PASSED [ 95%]
tests/unit/core/strategy_actions/test_visualize_mapping_flow.py::TestVisualizeMappingFlowAction::test_bar_chart_fallback_without_matplotlib PASSED [ 95%]
tests/unit/core/strategy_actions/test_visualize_mapping_flow.py::TestVisualizeMappingFlowAction::test_save_to_context PASSED [ 95%]
tests/unit/core/strategy_actions/test_visualize_mapping_flow.py::TestVisualizeMappingFlowAction::test_without_statistics PASSED [ 96%]
tests/unit/core/strategy_actions/test_visualize_mapping_flow.py::TestVisualizeMappingFlowAction::test_error_on_missing_output_file PASSED [ 96%]
tests/unit/core/strategy_actions/test_visualize_mapping_flow.py::TestVisualizeMappingFlowAction::test_invalid_chart_type PASSED [ 96%]
tests/unit/strategy_actions/test_api_resolver.py::TestApiResolver::test_execute_successful_resolution PASSED [ 96%]
tests/unit/strategy_actions/test_api_resolver.py::TestApiResolver::test_execute_with_nested_response_fields PASSED [ 96%]
tests/unit/strategy_actions/test_api_resolver.py::TestApiResolver::test_execute_with_404_responses PASSED [ 96%]
tests/unit/strategy_actions/test_api_resolver.py::TestApiResolver::test_execute_with_retry_on_errors FAILED [ 96%]
tests/unit/strategy_actions/test_api_resolver.py::TestApiResolver::test_execute_with_max_retries_exceeded PASSED [ 96%]
tests/unit/strategy_actions/test_api_resolver.py::TestApiResolver::test_execute_with_rate_limiting PASSED [ 96%]
tests/unit/strategy_actions/test_api_resolver.py::TestApiResolver::test_execute_with_empty_input PASSED [ 96%]
tests/unit/strategy_actions/test_api_resolver.py::TestApiResolver::test_execute_missing_input_key PASSED [ 96%]
tests/unit/strategy_actions/test_api_resolver.py::TestApiResolver::test_execute_validation_errors PASSED [ 97%]
tests/unit/strategy_actions/test_api_resolver.py::TestApiResolver::test_execute_with_request_params PASSED [ 97%]
tests/unit/strategy_actions/test_api_resolver.py::TestApiResolver::test_execute_with_connection_error PASSED [ 97%]
tests/unit/strategy_actions/test_api_resolver.py::TestApiResolver::test_extract_field_method PASSED [ 97%]
tests/unit/strategy_actions/test_api_resolver.py::TestApiResolver::test_session_lifecycle PASSED [ 97%]
tests/unit/strategy_actions/test_reconcile_bidirectional_action.py::TestReconcileBidirectionalAction::test_basic_bidirectional_reconciliation PASSED [ 97%]
tests/unit/strategy_actions/test_reconcile_bidirectional_action.py::TestReconcileBidirectionalAction::test_forward_only_mappings PASSED [ 97%]
tests/unit/strategy_actions/test_reconcile_bidirectional_action.py::TestReconcileBidirectionalAction::test_reverse_only_mappings PASSED [ 97%]
tests/unit/strategy_actions/test_reconcile_bidirectional_action.py::TestReconcileBidirectionalAction::test_many_to_one_mappings PASSED [ 97%]
tests/unit/strategy_actions/test_reconcile_bidirectional_action.py::TestReconcileBidirectionalAction::test_empty_mapping_results PASSED [ 97%]
tests/unit/strategy_actions/test_reconcile_bidirectional_action.py::TestReconcileBidirectionalAction::test_missing_context_keys PASSED [ 97%]
tests/unit/strategy_actions/test_reconcile_bidirectional_action.py::TestReconcileBidirectionalAction::test_parameter_validation PASSED [ 97%]
tests/unit/strategy_actions/test_reconcile_bidirectional_action.py::TestReconcileBidirectionalAction::test_provenance_tracking PASSED [ 98%]
tests/unit/strategy_actions/test_reconcile_bidirectional_action.py::TestReconcileBidirectionalAction::test_complex_scenario PASSED [ 98%]
tests/unit/strategy_actions/test_results_saver.py::TestResultsSaver::test_save_list_of_dicts_as_csv PASSED [ 98%]
tests/unit/strategy_actions/test_results_saver.py::TestResultsSaver::test_save_dataframe_as_csv PASSED [ 98%]
tests/unit/strategy_actions/test_results_saver.py::TestResultsSaver::test_save_as_json PASSED [ 98%]
tests/unit/strategy_actions/test_results_saver.py::TestResultsSaver::test_csv_with_summary PASSED [ 98%]
tests/unit/strategy_actions/test_results_saver.py::TestResultsSaver::test_timestamp_in_filename PASSED [ 98%]
tests/unit/strategy_actions/test_results_saver.py::TestResultsSaver::test_ensure_unique_filename PASSED [ 98%]
tests/unit/strategy_actions/test_results_saver.py::TestResultsSaver::test_environment_variable_expansion PASSED [ 98%]
tests/unit/strategy_actions/test_results_saver.py::TestResultsSaver::test_missing_data_warning PASSED [ 98%]
tests/unit/strategy_actions/test_results_saver.py::TestResultsSaver::test_permission_error_handling PASSED [ 98%]
tests/unit/strategy_actions/test_results_saver.py::TestResultsSaver::test_invalid_format_error PASSED [ 99%]
tests/unit/strategy_actions/test_results_saver.py::TestResultsSaver::test_missing_required_parameters PASSED [ 99%]
tests/unit/strategy_actions/test_results_saver.py::TestResultsSaver::test_complex_nested_json PASSED [ 99%]
tests/utils/test_dspy_integration.py::test_predictor_initialization PASSED [ 99%]
tests/utils/test_dspy_integration.py::test_mapping_with_mock_predictor PASSED [ 99%]
tests/utils/test_dspy_integration.py::test_error_handling PASSED         [ 99%]
tests/utils/test_io_utils.py::test_load_tabular_file_with_comments PASSED [ 99%]
tests/utils/test_io_utils.py::test_load_tabular_file_auto_separator PASSED [ 99%]
tests/utils/test_io_utils.py::test_get_max_file_size PASSED              [ 99%]
tests/utils/test_optimization.py::test_optimize_prompts PASSED           [ 99%]
tests/utils/test_optimization.py::test_optimize_prompts_custom_metrics PASSED [ 99%]
tests/utils/test_optimization.py::test_optimize_prompts_no_data PASSED   [100%]

=================================== FAILURES ===================================
________________ test_handle_convert_identifiers_local_success _________________

mapping_executor = <biomapper.core.mapping_executor.MappingExecutor object at 0x7c203cf96d10>

    @pytest.mark.asyncio
    async def test_handle_convert_identifiers_local_success(mapping_executor):
        """Test _handle_convert_identifiers_local with valid parameters."""
        action_parameters = {
            'endpoint_context': 'SOURCE',
            'output_ontology_type': 'TARGET_ONTOLOGY',
            'input_ontology_type': 'SOURCE_ONTOLOGY'
        }
    
        # Mock the StrategyAction to succeed
>       with patch('biomapper.core.strategy_actions.convert_identifiers_local.ConvertIdentifiersLocalAction') as mock_action_class:

tests/core/test_mapping_executor_handlers.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.pyenv/versions/3.11.7/lib/python3.11/unittest/mock.py:1427: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'biomapper.core.strategy_actions.convert_identifiers_local'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
E           AttributeError: module 'biomapper.core.strategy_actions' has no attribute 'convert_identifiers_local'

../../.pyenv/versions/3.11.7/lib/python3.11/pkgutil.py:715: AttributeError
________________________ test_ukbb_hpa_overlap_strategy ________________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        try:
>           yield

../../.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/lib/python3.11/site-packages/httpx/_transports/default.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/lib/python3.11/site-packages/httpx/_transports/default.py:377: in handle_async_request
    resp = await self._pool.handle_async_request(req)
../../.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/lib/python3.11/site-packages/httpcore/_async/connection_pool.py:256: in handle_async_request
    raise exc from None
../../.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/lib/python3.11/site-packages/httpcore/_async/connection_pool.py:236: in handle_async_request
    response = await connection.handle_async_request(
../../.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/lib/python3.11/site-packages/httpcore/_async/connection.py:101: in handle_async_request
    raise exc
../../.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/lib/python3.11/site-packages/httpcore/_async/connection.py:78: in handle_async_request
    stream = await self._connect(request)
../../.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/lib/python3.11/site-packages/httpcore/_async/connection.py:124: in _connect
    stream = await self._network_backend.connect_tcp(**kwargs)
../../.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/lib/python3.11/site-packages/httpcore/_backends/auto.py:31: in connect_tcp
    return await self._backend.connect_tcp(
../../.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/lib/python3.11/site-packages/httpcore/_backends/anyio.py:113: in connect_tcp
    with map_exceptions(exc_map):
../../.pyenv/versions/3.11.7/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>, <class 'anyio.BrokenResourceError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: All connection attempts failed

../../.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

    @pytest.mark.asyncio
    async def test_ukbb_hpa_overlap_strategy():
        """Test the UKBB_HPA_PROTEIN_OVERLAP_ANALYSIS strategy through the API."""
    
        # Define sample data with overlapping and unique protein identifiers
        sample_data = {
            "ukbb_protein_ids": [
                "P12345",  # Overlapping
                "Q67890",  # Overlapping
                "P98765",  # Unique to UKBB
                "Q11111",  # Unique to UKBB
                "P22222",  # Overlapping
            ],
            "hpa_protein_ids": [
                "P12345",  # Overlapping
                "Q67890",  # Overlapping
                "P33333",  # Unique to HPA
                "Q44444",  # Unique to HPA
                "P22222",  # Overlapping
                "P55555",  # Unique to HPA
            ]
        }
    
        # Expected overlapping proteins
        expected_overlap = {"P12345", "Q67890", "P22222"}
    
        # Create the request payload
        request_payload = {
            "context": sample_data
        }
    
        # Make the API request
        async with httpx.AsyncClient() as client:
>           response = await client.post(
                f"{BASE_URL}/api/strategies/UKBB_HPA_PROTEIN_OVERLAP_ANALYSIS/execute",
                json=request_payload
            )

tests/integration/test_strategy_execution.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/lib/python3.11/site-packages/httpx/_client.py:1905: in post
    return await self.request(
../../.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/lib/python3.11/site-packages/httpx/_client.py:1585: in request
    return await self.send(request, auth=auth, follow_redirects=follow_redirects)
../../.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/lib/python3.11/site-packages/httpx/_client.py:1674: in send
    response = await self._send_handling_auth(
../../.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/lib/python3.11/site-packages/httpx/_client.py:1702: in _send_handling_auth
    response = await self._send_handling_redirects(
../../.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/lib/python3.11/site-packages/httpx/_client.py:1739: in _send_handling_redirects
    response = await self._send_single_request(request)
../../.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/lib/python3.11/site-packages/httpx/_client.py:1776: in _send_single_request
    response = await transport.handle_async_request(request)
../../.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/lib/python3.11/site-packages/httpx/_transports/default.py:376: in handle_async_request
    with map_httpcore_exceptions():
../../.pyenv/versions/3.11.7/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: All connection attempts failed

../../.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/lib/python3.11/site-packages/httpx/_transports/default.py:89: ConnectError
_____________ TestYAMLStrategyExecution.test_basic_linear_strategy _____________

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c20342a4a90>
step = <MappingStrategyStep id=1 strategy=1 step=S1_CONVERT_TO_GENE order=1 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['TEST1', 'TEST2', 'TEST3']
current_ontology_type = 'hgnc'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c203443cb90>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c203443c3d0>
use_cache = True, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': True}, 'current_identifiers': ['TEST1', 'TEST2', 'TEST3'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c202c50ac50>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
>           action = self.action_loader.instantiate_action(action_type, db_session)

biomapper/core/engine_components/action_executor.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/engine_components/action_loader.py:137: in instantiate_action
    action_class = self.load_action_class(action_type)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_loader.ActionLoader object at 0x7c20342a62d0>
action_type = 'CONVERT_IDENTIFIERS_LOCAL'

    def load_action_class(self, action_type: str) -> Type[StrategyAction]:
        """
        Load an action class by type or class path.
    
        Args:
            action_type: Either a registered action type (e.g., "CONVERT_IDENTIFIERS_LOCAL")
                        or a full class path (e.g., "biomapper.core.strategy_actions.load_endpoint_identifiers.LoadEndpointIdentifiersAction")
    
        Returns:
            The action class ready for instantiation
    
        Raises:
            ConfigurationError: If the action cannot be loaded
        """
        # First check if it's a registered action type
        if action_type in self.action_registry:
            logger.debug(f"Found action '{action_type}' in registry")
            return self.action_registry[action_type]
    
        # If not in registry, try to load it as a class path
        if '.' in action_type:
            logger.debug(f"Attempting to load action from class path: {action_type}")
            return self._load_from_class_path(action_type)
    
        # Neither registry nor class path
>       raise ConfigurationError(
            f"Unknown action type: '{action_type}'. "
            f"Action must be either registered in ACTION_REGISTRY or specified as a full class path."
        )
E       biomapper.core.exceptions.ConfigurationError: [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_loader.py:61: ConfigurationError

During handling of the above exception, another exception occurred:

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c20342a4350>
strategy_name = 'basic_linear_strategy'
input_identifiers = ['TEST1', 'TEST2', 'TEST3'], initial_context = None
source_endpoint_name = 'test_source', target_endpoint_name = 'test_target'
mapping_session_id = None, source_ontology_type = 'hgnc'
target_ontology_type = None, use_cache = True, max_cache_age_days = None
progress_callback = None, batch_size = 250, min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
>                   result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )

biomapper/core/engine_components/strategy_orchestrator.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c20342a4a90>
step = <MappingStrategyStep id=1 strategy=1 step=S1_CONVERT_TO_GENE order=1 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['TEST1', 'TEST2', 'TEST3']
current_ontology_type = 'hgnc'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c203443cb90>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c203443c3d0>
use_cache = True, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': True}, 'current_identifiers': ['TEST1', 'TEST2', 'TEST3'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c202c50ac50>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
            action = self.action_loader.instantiate_action(action_type, db_session)
        except Exception as e:
>           raise MappingExecutionError(
                f"Failed to load action '{action_type}': {str(e)}"
            )
E           biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_executor.py:99: MappingExecutionError

During handling of the above exception, another exception occurred:

self = <tests.integration.test_yaml_strategy_execution.TestYAMLStrategyExecution object at 0x7c203fbcc690>
setup_test_environment = <biomapper.core.mapping_executor.MappingExecutor object at 0x7c20344377d0>
mock_client_files = {'filter_target': '/home/trentleslie/github/biomapper/tests/integration/data/mock_client_files/test_filter_target.csv'...t_hgnc.tsv', 'uniprot': '/home/trentleslie/github/biomapper/tests/integration/data/mock_client_files/test_uniprot.tsv'}

    async def test_basic_linear_strategy(self, setup_test_environment, mock_client_files):
        """Test a basic linear strategy with CONVERT_IDENTIFIERS_LOCAL steps."""
        # Initial identifiers
        initial_ids = ["TEST1", "TEST2", "TEST3"]
    
        executor = setup_test_environment
    
        # Execute strategy
>       result = await executor.execute_yaml_strategy(
            strategy_name="basic_linear_strategy",
            source_endpoint_name="test_source",
            target_endpoint_name="test_target",
            input_identifiers=initial_ids,
            source_ontology_type="hgnc"
        )

tests/integration/test_yaml_strategy_execution.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/mapping_executor.py:261: in execute_yaml_strategy
    return await self.strategy_coordinator.execute_yaml_strategy(
biomapper/core/engine_components/strategy_coordinator_service.py:148: in execute_yaml_strategy
    return await self.yaml_strategy_execution_service.execute(
biomapper/core/services/execution_services.py:625: in execute
    return await self.strategy_orchestrator.execute_strategy(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c20342a4350>
strategy_name = 'basic_linear_strategy'
input_identifiers = ['TEST1', 'TEST2', 'TEST3'], initial_context = None
source_endpoint_name = 'test_source', target_endpoint_name = 'test_target'
mapping_session_id = None, source_ontology_type = 'hgnc'
target_ontology_type = None, use_cache = True, max_cache_age_days = None
progress_callback = None, batch_size = 250, min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
                    result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )
    
                    # Track step result
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "success",
                        "input_count": len(current_identifiers),
                        "output_count": len(result.get('output_identifiers', [])),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds(),
                        "details": result.get('details', {})
                    }
    
                    # Update current state
                    current_identifiers = result.get('output_identifiers', [])
                    current_ontology_type = result.get('output_ontology_type', current_ontology_type)
    
                    # Update context with current state
                    strategy_context['current_identifiers'] = current_identifiers
                    strategy_context['current_ontology_type'] = current_ontology_type
    
                    # Accumulate provenance if present
                    if 'provenance' in result:
                        strategy_context['all_provenance'].extend(result['provenance'])
    
                except Exception as e:
                    self.logger.error(f"Step {step.step_id} failed: {str(e)}")
    
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "failed",
                        "error": str(e),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds()
                    }
    
                    # Check if step is required
                    if step.is_required:
>                       raise MappingExecutionError(
                            f"Required step '{step.step_id}' failed: {str(e)}"
                        )
E                       biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Required step 'S1_CONVERT_TO_GENE' failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/strategy_orchestrator.py:233: MappingExecutionError
------------------------------ Captured log setup ------------------------------
WARNING  langfuse:client.py:259 Langfuse client is disabled since no public_key was provided as a parameter or environment variable 'LANGFUSE_PUBLIC_KEY'. See our docs: https://langfuse.com/docs/sdk/python/low-level-sdk#initialize-client
------------------------------ Captured log call -------------------------------
ERROR    biomapper.core.engine_components.initialization_service:strategy_orchestrator.py:220 Step S1_CONVERT_TO_GENE failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.
_____________ TestYAMLStrategyExecution.test_mixed_action_strategy _____________

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c20341f2850>
step = <MappingStrategyStep id=5 strategy=4 step=S1_CONVERT_HGNC order=1 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['TEST1', 'TEST2'], current_ontology_type = 'hgnc'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c20341e8dd0>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c20341e9e10>
use_cache = True, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': True}, 'current_identifiers': ['TEST1', 'TEST2'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c203c54f590>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
>           action = self.action_loader.instantiate_action(action_type, db_session)

biomapper/core/engine_components/action_executor.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/engine_components/action_loader.py:137: in instantiate_action
    action_class = self.load_action_class(action_type)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_loader.ActionLoader object at 0x7c20341f2e90>
action_type = 'CONVERT_IDENTIFIERS_LOCAL'

    def load_action_class(self, action_type: str) -> Type[StrategyAction]:
        """
        Load an action class by type or class path.
    
        Args:
            action_type: Either a registered action type (e.g., "CONVERT_IDENTIFIERS_LOCAL")
                        or a full class path (e.g., "biomapper.core.strategy_actions.load_endpoint_identifiers.LoadEndpointIdentifiersAction")
    
        Returns:
            The action class ready for instantiation
    
        Raises:
            ConfigurationError: If the action cannot be loaded
        """
        # First check if it's a registered action type
        if action_type in self.action_registry:
            logger.debug(f"Found action '{action_type}' in registry")
            return self.action_registry[action_type]
    
        # If not in registry, try to load it as a class path
        if '.' in action_type:
            logger.debug(f"Attempting to load action from class path: {action_type}")
            return self._load_from_class_path(action_type)
    
        # Neither registry nor class path
>       raise ConfigurationError(
            f"Unknown action type: '{action_type}'. "
            f"Action must be either registered in ACTION_REGISTRY or specified as a full class path."
        )
E       biomapper.core.exceptions.ConfigurationError: [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_loader.py:61: ConfigurationError

During handling of the above exception, another exception occurred:

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c20341f0550>
strategy_name = 'complex_mixed_strategy', input_identifiers = ['TEST1', 'TEST2']
initial_context = None, source_endpoint_name = 'test_source'
target_endpoint_name = 'test_target', mapping_session_id = None
source_ontology_type = 'hgnc', target_ontology_type = None, use_cache = True
max_cache_age_days = None, progress_callback = None, batch_size = 250
min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
>                   result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )

biomapper/core/engine_components/strategy_orchestrator.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c20341f2850>
step = <MappingStrategyStep id=5 strategy=4 step=S1_CONVERT_HGNC order=1 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['TEST1', 'TEST2'], current_ontology_type = 'hgnc'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c20341e8dd0>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c20341e9e10>
use_cache = True, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': True}, 'current_identifiers': ['TEST1', 'TEST2'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c203c54f590>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
            action = self.action_loader.instantiate_action(action_type, db_session)
        except Exception as e:
>           raise MappingExecutionError(
                f"Failed to load action '{action_type}': {str(e)}"
            )
E           biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_executor.py:99: MappingExecutionError

During handling of the above exception, another exception occurred:

self = <tests.integration.test_yaml_strategy_execution.TestYAMLStrategyExecution object at 0x7c203fbcd3d0>
setup_test_environment = <biomapper.core.mapping_executor.MappingExecutor object at 0x7c20341f3890>
mock_client_files = {'filter_target': '/home/trentleslie/github/biomapper/tests/integration/data/mock_client_files/test_filter_target.csv'...t_hgnc.tsv', 'uniprot': '/home/trentleslie/github/biomapper/tests/integration/data/mock_client_files/test_uniprot.tsv'}

    async def test_mixed_action_strategy(self, setup_test_environment, mock_client_files):
        """Test a strategy combining all action types."""
        initial_ids = ["TEST1", "TEST2"]  # Use valid IDs that will map successfully
    
        executor = setup_test_environment
    
>       result = await executor.execute_yaml_strategy(
            strategy_name="complex_mixed_strategy",
            source_endpoint_name="test_source",
            target_endpoint_name="test_target",
            input_identifiers=initial_ids,
            source_ontology_type="hgnc"
        )

tests/integration/test_yaml_strategy_execution.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/mapping_executor.py:261: in execute_yaml_strategy
    return await self.strategy_coordinator.execute_yaml_strategy(
biomapper/core/engine_components/strategy_coordinator_service.py:148: in execute_yaml_strategy
    return await self.yaml_strategy_execution_service.execute(
biomapper/core/services/execution_services.py:625: in execute
    return await self.strategy_orchestrator.execute_strategy(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c20341f0550>
strategy_name = 'complex_mixed_strategy', input_identifiers = ['TEST1', 'TEST2']
initial_context = None, source_endpoint_name = 'test_source'
target_endpoint_name = 'test_target', mapping_session_id = None
source_ontology_type = 'hgnc', target_ontology_type = None, use_cache = True
max_cache_age_days = None, progress_callback = None, batch_size = 250
min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
                    result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )
    
                    # Track step result
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "success",
                        "input_count": len(current_identifiers),
                        "output_count": len(result.get('output_identifiers', [])),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds(),
                        "details": result.get('details', {})
                    }
    
                    # Update current state
                    current_identifiers = result.get('output_identifiers', [])
                    current_ontology_type = result.get('output_ontology_type', current_ontology_type)
    
                    # Update context with current state
                    strategy_context['current_identifiers'] = current_identifiers
                    strategy_context['current_ontology_type'] = current_ontology_type
    
                    # Accumulate provenance if present
                    if 'provenance' in result:
                        strategy_context['all_provenance'].extend(result['provenance'])
    
                except Exception as e:
                    self.logger.error(f"Step {step.step_id} failed: {str(e)}")
    
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "failed",
                        "error": str(e),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds()
                    }
    
                    # Check if step is required
                    if step.is_required:
>                       raise MappingExecutionError(
                            f"Required step '{step.step_id}' failed: {str(e)}"
                        )
E                       biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Required step 'S1_CONVERT_HGNC' failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/strategy_orchestrator.py:233: MappingExecutionError
------------------------------ Captured log setup ------------------------------
WARNING  langfuse:client.py:259 Langfuse client is disabled since no public_key was provided as a parameter or environment variable 'LANGFUSE_PUBLIC_KEY'. See our docs: https://langfuse.com/docs/sdk/python/low-level-sdk#initialize-client
------------------------------ Captured log call -------------------------------
ERROR    biomapper.core.engine_components.initialization_service:strategy_orchestrator.py:220 Step S1_CONVERT_HGNC failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.
___________ TestYAMLStrategyExecution.test_empty_initial_identifiers ___________

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c20340f9510>
step = <MappingStrategyStep id=1 strategy=1 step=S1_CONVERT_TO_GENE order=1 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = [], current_ontology_type = 'hgnc'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c2034060410>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c2034060b10>
use_cache = True, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': True}, 'current_identifiers': [], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c203409a150>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
>           action = self.action_loader.instantiate_action(action_type, db_session)

biomapper/core/engine_components/action_executor.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/engine_components/action_loader.py:137: in instantiate_action
    action_class = self.load_action_class(action_type)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_loader.ActionLoader object at 0x7c20340f9190>
action_type = 'CONVERT_IDENTIFIERS_LOCAL'

    def load_action_class(self, action_type: str) -> Type[StrategyAction]:
        """
        Load an action class by type or class path.
    
        Args:
            action_type: Either a registered action type (e.g., "CONVERT_IDENTIFIERS_LOCAL")
                        or a full class path (e.g., "biomapper.core.strategy_actions.load_endpoint_identifiers.LoadEndpointIdentifiersAction")
    
        Returns:
            The action class ready for instantiation
    
        Raises:
            ConfigurationError: If the action cannot be loaded
        """
        # First check if it's a registered action type
        if action_type in self.action_registry:
            logger.debug(f"Found action '{action_type}' in registry")
            return self.action_registry[action_type]
    
        # If not in registry, try to load it as a class path
        if '.' in action_type:
            logger.debug(f"Attempting to load action from class path: {action_type}")
            return self._load_from_class_path(action_type)
    
        # Neither registry nor class path
>       raise ConfigurationError(
            f"Unknown action type: '{action_type}'. "
            f"Action must be either registered in ACTION_REGISTRY or specified as a full class path."
        )
E       biomapper.core.exceptions.ConfigurationError: [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_loader.py:61: ConfigurationError

During handling of the above exception, another exception occurred:

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c20340f9490>
strategy_name = 'basic_linear_strategy', input_identifiers = []
initial_context = None, source_endpoint_name = 'test_source'
target_endpoint_name = 'test_target', mapping_session_id = None
source_ontology_type = 'hgnc', target_ontology_type = None, use_cache = True
max_cache_age_days = None, progress_callback = None, batch_size = 250
min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
>                   result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )

biomapper/core/engine_components/strategy_orchestrator.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c20340f9510>
step = <MappingStrategyStep id=1 strategy=1 step=S1_CONVERT_TO_GENE order=1 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = [], current_ontology_type = 'hgnc'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c2034060410>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c2034060b10>
use_cache = True, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': True}, 'current_identifiers': [], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c203409a150>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
            action = self.action_loader.instantiate_action(action_type, db_session)
        except Exception as e:
>           raise MappingExecutionError(
                f"Failed to load action '{action_type}': {str(e)}"
            )
E           biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_executor.py:99: MappingExecutionError

During handling of the above exception, another exception occurred:

self = <tests.integration.test_yaml_strategy_execution.TestYAMLStrategyExecution object at 0x7c203fbce310>
setup_test_environment = <biomapper.core.mapping_executor.MappingExecutor object at 0x7c20340f9ad0>

    async def test_empty_initial_identifiers(self, setup_test_environment):
        """Test running a strategy with empty initial identifiers."""
        executor = setup_test_environment
    
>       result = await executor.execute_yaml_strategy(
            strategy_name="basic_linear_strategy",
            source_endpoint_name="test_source",
            target_endpoint_name="test_target",
            input_identifiers=[],
            source_ontology_type="hgnc"
        )

tests/integration/test_yaml_strategy_execution.py:299: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/mapping_executor.py:261: in execute_yaml_strategy
    return await self.strategy_coordinator.execute_yaml_strategy(
biomapper/core/engine_components/strategy_coordinator_service.py:148: in execute_yaml_strategy
    return await self.yaml_strategy_execution_service.execute(
biomapper/core/services/execution_services.py:625: in execute
    return await self.strategy_orchestrator.execute_strategy(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c20340f9490>
strategy_name = 'basic_linear_strategy', input_identifiers = []
initial_context = None, source_endpoint_name = 'test_source'
target_endpoint_name = 'test_target', mapping_session_id = None
source_ontology_type = 'hgnc', target_ontology_type = None, use_cache = True
max_cache_age_days = None, progress_callback = None, batch_size = 250
min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
                    result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )
    
                    # Track step result
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "success",
                        "input_count": len(current_identifiers),
                        "output_count": len(result.get('output_identifiers', [])),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds(),
                        "details": result.get('details', {})
                    }
    
                    # Update current state
                    current_identifiers = result.get('output_identifiers', [])
                    current_ontology_type = result.get('output_ontology_type', current_ontology_type)
    
                    # Update context with current state
                    strategy_context['current_identifiers'] = current_identifiers
                    strategy_context['current_ontology_type'] = current_ontology_type
    
                    # Accumulate provenance if present
                    if 'provenance' in result:
                        strategy_context['all_provenance'].extend(result['provenance'])
    
                except Exception as e:
                    self.logger.error(f"Step {step.step_id} failed: {str(e)}")
    
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "failed",
                        "error": str(e),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds()
                    }
    
                    # Check if step is required
                    if step.is_required:
>                       raise MappingExecutionError(
                            f"Required step '{step.step_id}' failed: {str(e)}"
                        )
E                       biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Required step 'S1_CONVERT_TO_GENE' failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/strategy_orchestrator.py:233: MappingExecutionError
------------------------------ Captured log setup ------------------------------
WARNING  langfuse:client.py:259 Langfuse client is disabled since no public_key was provided as a parameter or environment variable 'LANGFUSE_PUBLIC_KEY'. See our docs: https://langfuse.com/docs/sdk/python/low-level-sdk#initialize-client
------------------------------ Captured log call -------------------------------
ERROR    biomapper.core.engine_components.initialization_service:strategy_orchestrator.py:220 Step S1_CONVERT_TO_GENE failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.
____________ TestYAMLStrategyExecution.test_ontology_type_tracking _____________

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c2034097ad0>
step = <MappingStrategyStep id=9 strategy=6 step=S1_EXTRACT_GENE order=1 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['HGNC:1234', 'HGNC:5678'], current_ontology_type = 'hgnc'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c793350>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c793b90>
use_cache = True, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': True}, 'current_identifiers': ['HGNC:1234', 'HGNC:5678'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c202c7ec4d0>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
>           action = self.action_loader.instantiate_action(action_type, db_session)

biomapper/core/engine_components/action_executor.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/engine_components/action_loader.py:137: in instantiate_action
    action_class = self.load_action_class(action_type)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_loader.ActionLoader object at 0x7c2034097a10>
action_type = 'CONVERT_IDENTIFIERS_LOCAL'

    def load_action_class(self, action_type: str) -> Type[StrategyAction]:
        """
        Load an action class by type or class path.
    
        Args:
            action_type: Either a registered action type (e.g., "CONVERT_IDENTIFIERS_LOCAL")
                        or a full class path (e.g., "biomapper.core.strategy_actions.load_endpoint_identifiers.LoadEndpointIdentifiersAction")
    
        Returns:
            The action class ready for instantiation
    
        Raises:
            ConfigurationError: If the action cannot be loaded
        """
        # First check if it's a registered action type
        if action_type in self.action_registry:
            logger.debug(f"Found action '{action_type}' in registry")
            return self.action_registry[action_type]
    
        # If not in registry, try to load it as a class path
        if '.' in action_type:
            logger.debug(f"Attempting to load action from class path: {action_type}")
            return self._load_from_class_path(action_type)
    
        # Neither registry nor class path
>       raise ConfigurationError(
            f"Unknown action type: '{action_type}'. "
            f"Action must be either registered in ACTION_REGISTRY or specified as a full class path."
        )
E       biomapper.core.exceptions.ConfigurationError: [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_loader.py:61: ConfigurationError

During handling of the above exception, another exception occurred:

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c2034097050>
strategy_name = 'ontology_tracking_strategy'
input_identifiers = ['HGNC:1234', 'HGNC:5678'], initial_context = None
source_endpoint_name = 'test_source', target_endpoint_name = 'test_target'
mapping_session_id = None, source_ontology_type = 'hgnc'
target_ontology_type = 'uniprot', use_cache = True, max_cache_age_days = None
progress_callback = None, batch_size = 250, min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
>                   result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )

biomapper/core/engine_components/strategy_orchestrator.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c2034097ad0>
step = <MappingStrategyStep id=9 strategy=6 step=S1_EXTRACT_GENE order=1 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['HGNC:1234', 'HGNC:5678'], current_ontology_type = 'hgnc'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c793350>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c793b90>
use_cache = True, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': True}, 'current_identifiers': ['HGNC:1234', 'HGNC:5678'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c202c7ec4d0>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
            action = self.action_loader.instantiate_action(action_type, db_session)
        except Exception as e:
>           raise MappingExecutionError(
                f"Failed to load action '{action_type}': {str(e)}"
            )
E           biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_executor.py:99: MappingExecutionError

During handling of the above exception, another exception occurred:

self = <tests.integration.test_yaml_strategy_execution.TestYAMLStrategyExecution object at 0x7c203fbcf150>
setup_test_environment = <biomapper.core.mapping_executor.MappingExecutor object at 0x7c20340979d0>

    async def test_ontology_type_tracking(self, setup_test_environment):
        """Test that current_source_ontology_type is properly tracked."""
        initial_ids = ["HGNC:1234", "HGNC:5678"]
    
        executor = setup_test_environment
    
>       result = await executor.execute_yaml_strategy(
            strategy_name="ontology_tracking_strategy",
            source_endpoint_name="test_source",
            target_endpoint_name="test_target",
            input_identifiers=initial_ids,
            source_ontology_type="hgnc",
            target_ontology_type="uniprot"
        )

tests/integration/test_yaml_strategy_execution.py:333: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/mapping_executor.py:261: in execute_yaml_strategy
    return await self.strategy_coordinator.execute_yaml_strategy(
biomapper/core/engine_components/strategy_coordinator_service.py:148: in execute_yaml_strategy
    return await self.yaml_strategy_execution_service.execute(
biomapper/core/services/execution_services.py:625: in execute
    return await self.strategy_orchestrator.execute_strategy(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c2034097050>
strategy_name = 'ontology_tracking_strategy'
input_identifiers = ['HGNC:1234', 'HGNC:5678'], initial_context = None
source_endpoint_name = 'test_source', target_endpoint_name = 'test_target'
mapping_session_id = None, source_ontology_type = 'hgnc'
target_ontology_type = 'uniprot', use_cache = True, max_cache_age_days = None
progress_callback = None, batch_size = 250, min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
                    result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )
    
                    # Track step result
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "success",
                        "input_count": len(current_identifiers),
                        "output_count": len(result.get('output_identifiers', [])),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds(),
                        "details": result.get('details', {})
                    }
    
                    # Update current state
                    current_identifiers = result.get('output_identifiers', [])
                    current_ontology_type = result.get('output_ontology_type', current_ontology_type)
    
                    # Update context with current state
                    strategy_context['current_identifiers'] = current_identifiers
                    strategy_context['current_ontology_type'] = current_ontology_type
    
                    # Accumulate provenance if present
                    if 'provenance' in result:
                        strategy_context['all_provenance'].extend(result['provenance'])
    
                except Exception as e:
                    self.logger.error(f"Step {step.step_id} failed: {str(e)}")
    
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "failed",
                        "error": str(e),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds()
                    }
    
                    # Check if step is required
                    if step.is_required:
>                       raise MappingExecutionError(
                            f"Required step '{step.step_id}' failed: {str(e)}"
                        )
E                       biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Required step 'S1_EXTRACT_GENE' failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/strategy_orchestrator.py:233: MappingExecutionError
------------------------------ Captured log setup ------------------------------
WARNING  langfuse:client.py:259 Langfuse client is disabled since no public_key was provided as a parameter or environment variable 'LANGFUSE_PUBLIC_KEY'. See our docs: https://langfuse.com/docs/sdk/python/low-level-sdk#initialize-client
------------------------------ Captured log call -------------------------------
ERROR    biomapper.core.engine_components.initialization_service:strategy_orchestrator.py:220 Step S1_EXTRACT_GENE failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.
_____________ TestYAMLStrategyExecution.test_all_optional_strategy _____________

self = <tests.integration.test_yaml_strategy_execution.TestYAMLStrategyExecution object at 0x7c203f510bd0>
setup_optional_test_environment = <biomapper.core.mapping_executor.MappingExecutor object at 0x7c202c529cd0>
mock_client_files = {'filter_target': '/home/trentleslie/github/biomapper/tests/integration/data/mock_client_files/test_filter_target.csv'...t_hgnc.tsv', 'uniprot': '/home/trentleslie/github/biomapper/tests/integration/data/mock_client_files/test_uniprot.tsv'}

    async def test_all_optional_strategy(self, setup_optional_test_environment, mock_client_files):
        """Test strategy where all steps are optional, including failures."""
        initial_ids = ["TEST1", "TEST2", "TEST3"]
    
        executor = setup_optional_test_environment
    
        result = await executor.execute_yaml_strategy(
            strategy_name="all_optional_strategy",
            source_endpoint_name="test_source",
            target_endpoint_name="test_target",
            input_identifiers=initial_ids,
            source_ontology_type="hgnc"
        )
    
        # Should complete even with optional failures
        assert "metadata" in result
        assert "step_results" in result
        assert result["metadata"]["execution_status"] == "completed"
        assert "summary" in result
        # Strategy should complete successfully even with optional step failures
        assert result["summary"]["strategy_name"] == "all_optional_strategy"
    
        # Check step results
        step_results = result.get("step_results", [])
        assert len(step_results) == 3
    
        # First step should succeed (valid mapping)
>       assert step_results[0]["status"] == "success"
E       AssertionError: assert 'failed' == 'success'
E         - success
E         + failed

tests/integration/test_yaml_strategy_execution.py:414: AssertionError
------------------------------ Captured log setup ------------------------------
WARNING  langfuse:client.py:259 Langfuse client is disabled since no public_key was provided as a parameter or environment variable 'LANGFUSE_PUBLIC_KEY'. See our docs: https://langfuse.com/docs/sdk/python/low-level-sdk#initialize-client
------------------------------ Captured log call -------------------------------
ERROR    biomapper.core.engine_components.initialization_service:strategy_orchestrator.py:220 Step S1_OPTIONAL_CONVERT failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.
ERROR    biomapper.core.engine_components.initialization_service:strategy_orchestrator.py:220 Step S2_OPTIONAL_FAIL failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.
_______ TestYAMLStrategyExecution.test_mixed_required_optional_strategy ________

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c202c530c90>
step = <MappingStrategyStep id=4 strategy=2 step=S1_REQUIRED order=1 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['TEST1', 'TEST2'], current_ontology_type = 'hgnc'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c4eb650>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c4e8210>
use_cache = True, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': True}, 'current_identifiers': ['TEST1', 'TEST2'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c202c5c7990>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
>           action = self.action_loader.instantiate_action(action_type, db_session)

biomapper/core/engine_components/action_executor.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/engine_components/action_loader.py:137: in instantiate_action
    action_class = self.load_action_class(action_type)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_loader.ActionLoader object at 0x7c202c530c50>
action_type = 'CONVERT_IDENTIFIERS_LOCAL'

    def load_action_class(self, action_type: str) -> Type[StrategyAction]:
        """
        Load an action class by type or class path.
    
        Args:
            action_type: Either a registered action type (e.g., "CONVERT_IDENTIFIERS_LOCAL")
                        or a full class path (e.g., "biomapper.core.strategy_actions.load_endpoint_identifiers.LoadEndpointIdentifiersAction")
    
        Returns:
            The action class ready for instantiation
    
        Raises:
            ConfigurationError: If the action cannot be loaded
        """
        # First check if it's a registered action type
        if action_type in self.action_registry:
            logger.debug(f"Found action '{action_type}' in registry")
            return self.action_registry[action_type]
    
        # If not in registry, try to load it as a class path
        if '.' in action_type:
            logger.debug(f"Attempting to load action from class path: {action_type}")
            return self._load_from_class_path(action_type)
    
        # Neither registry nor class path
>       raise ConfigurationError(
            f"Unknown action type: '{action_type}'. "
            f"Action must be either registered in ACTION_REGISTRY or specified as a full class path."
        )
E       biomapper.core.exceptions.ConfigurationError: [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_loader.py:61: ConfigurationError

During handling of the above exception, another exception occurred:

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c202c530a50>
strategy_name = 'mixed_required_optional_strategy'
input_identifiers = ['TEST1', 'TEST2'], initial_context = None
source_endpoint_name = 'test_source', target_endpoint_name = 'test_target'
mapping_session_id = None, source_ontology_type = 'hgnc'
target_ontology_type = None, use_cache = True, max_cache_age_days = None
progress_callback = None, batch_size = 250, min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
>                   result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )

biomapper/core/engine_components/strategy_orchestrator.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c202c530c90>
step = <MappingStrategyStep id=4 strategy=2 step=S1_REQUIRED order=1 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['TEST1', 'TEST2'], current_ontology_type = 'hgnc'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c4eb650>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c4e8210>
use_cache = True, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': True}, 'current_identifiers': ['TEST1', 'TEST2'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c202c5c7990>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
            action = self.action_loader.instantiate_action(action_type, db_session)
        except Exception as e:
>           raise MappingExecutionError(
                f"Failed to load action '{action_type}': {str(e)}"
            )
E           biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_executor.py:99: MappingExecutionError

During handling of the above exception, another exception occurred:

self = <tests.integration.test_yaml_strategy_execution.TestYAMLStrategyExecution object at 0x7c203f5115d0>
setup_optional_test_environment = <biomapper.core.mapping_executor.MappingExecutor object at 0x7c202c531290>
mock_client_files = {'filter_target': '/home/trentleslie/github/biomapper/tests/integration/data/mock_client_files/test_filter_target.csv'...t_hgnc.tsv', 'uniprot': '/home/trentleslie/github/biomapper/tests/integration/data/mock_client_files/test_uniprot.tsv'}

    async def test_mixed_required_optional_strategy(self, setup_optional_test_environment, mock_client_files):
        """Test strategy with both required and optional steps."""
        initial_ids = ["TEST1", "TEST2"]
    
        executor = setup_optional_test_environment
    
>       result = await executor.execute_yaml_strategy(
            strategy_name="mixed_required_optional_strategy",
            source_endpoint_name="test_source",
            target_endpoint_name="test_target",
            input_identifiers=initial_ids,
            source_ontology_type="hgnc",
        )

tests/integration/test_yaml_strategy_execution.py:439: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/mapping_executor.py:261: in execute_yaml_strategy
    return await self.strategy_coordinator.execute_yaml_strategy(
biomapper/core/engine_components/strategy_coordinator_service.py:148: in execute_yaml_strategy
    return await self.yaml_strategy_execution_service.execute(
biomapper/core/services/execution_services.py:625: in execute
    return await self.strategy_orchestrator.execute_strategy(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c202c530a50>
strategy_name = 'mixed_required_optional_strategy'
input_identifiers = ['TEST1', 'TEST2'], initial_context = None
source_endpoint_name = 'test_source', target_endpoint_name = 'test_target'
mapping_session_id = None, source_ontology_type = 'hgnc'
target_ontology_type = None, use_cache = True, max_cache_age_days = None
progress_callback = None, batch_size = 250, min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
                    result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )
    
                    # Track step result
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "success",
                        "input_count": len(current_identifiers),
                        "output_count": len(result.get('output_identifiers', [])),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds(),
                        "details": result.get('details', {})
                    }
    
                    # Update current state
                    current_identifiers = result.get('output_identifiers', [])
                    current_ontology_type = result.get('output_ontology_type', current_ontology_type)
    
                    # Update context with current state
                    strategy_context['current_identifiers'] = current_identifiers
                    strategy_context['current_ontology_type'] = current_ontology_type
    
                    # Accumulate provenance if present
                    if 'provenance' in result:
                        strategy_context['all_provenance'].extend(result['provenance'])
    
                except Exception as e:
                    self.logger.error(f"Step {step.step_id} failed: {str(e)}")
    
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "failed",
                        "error": str(e),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds()
                    }
    
                    # Check if step is required
                    if step.is_required:
>                       raise MappingExecutionError(
                            f"Required step '{step.step_id}' failed: {str(e)}"
                        )
E                       biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Required step 'S1_REQUIRED' failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/strategy_orchestrator.py:233: MappingExecutionError
------------------------------ Captured log setup ------------------------------
WARNING  langfuse:client.py:259 Langfuse client is disabled since no public_key was provided as a parameter or environment variable 'LANGFUSE_PUBLIC_KEY'. See our docs: https://langfuse.com/docs/sdk/python/low-level-sdk#initialize-client
------------------------------ Captured log call -------------------------------
ERROR    biomapper.core.engine_components.initialization_service:strategy_orchestrator.py:220 Step S1_REQUIRED failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.
_________ TestYAMLStrategyExecution.test_optional_fail_first_strategy __________

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c202c67d290>
step = <MappingStrategyStep id=8 strategy=3 step=S2_REQUIRED_CONVERT order=2 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['TEST1', 'TEST2'], current_ontology_type = 'hgnc'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c51bfd0>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c519290>
use_cache = True, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': True}, 'current_identifiers': ['TEST1', 'TEST2'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c202c487b90>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
>           action = self.action_loader.instantiate_action(action_type, db_session)

biomapper/core/engine_components/action_executor.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/engine_components/action_loader.py:137: in instantiate_action
    action_class = self.load_action_class(action_type)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_loader.ActionLoader object at 0x7c202c67e010>
action_type = 'CONVERT_IDENTIFIERS_LOCAL'

    def load_action_class(self, action_type: str) -> Type[StrategyAction]:
        """
        Load an action class by type or class path.
    
        Args:
            action_type: Either a registered action type (e.g., "CONVERT_IDENTIFIERS_LOCAL")
                        or a full class path (e.g., "biomapper.core.strategy_actions.load_endpoint_identifiers.LoadEndpointIdentifiersAction")
    
        Returns:
            The action class ready for instantiation
    
        Raises:
            ConfigurationError: If the action cannot be loaded
        """
        # First check if it's a registered action type
        if action_type in self.action_registry:
            logger.debug(f"Found action '{action_type}' in registry")
            return self.action_registry[action_type]
    
        # If not in registry, try to load it as a class path
        if '.' in action_type:
            logger.debug(f"Attempting to load action from class path: {action_type}")
            return self._load_from_class_path(action_type)
    
        # Neither registry nor class path
>       raise ConfigurationError(
            f"Unknown action type: '{action_type}'. "
            f"Action must be either registered in ACTION_REGISTRY or specified as a full class path."
        )
E       biomapper.core.exceptions.ConfigurationError: [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_loader.py:61: ConfigurationError

During handling of the above exception, another exception occurred:

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c202c67dc10>
strategy_name = 'optional_fail_first_strategy'
input_identifiers = ['TEST1', 'TEST2'], initial_context = None
source_endpoint_name = 'test_source', target_endpoint_name = 'test_target'
mapping_session_id = None, source_ontology_type = 'hgnc'
target_ontology_type = None, use_cache = True, max_cache_age_days = None
progress_callback = None, batch_size = 250, min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
>                   result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )

biomapper/core/engine_components/strategy_orchestrator.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c202c67d290>
step = <MappingStrategyStep id=8 strategy=3 step=S2_REQUIRED_CONVERT order=2 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['TEST1', 'TEST2'], current_ontology_type = 'hgnc'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c51bfd0>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c519290>
use_cache = True, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': True}, 'current_identifiers': ['TEST1', 'TEST2'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c202c487b90>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
            action = self.action_loader.instantiate_action(action_type, db_session)
        except Exception as e:
>           raise MappingExecutionError(
                f"Failed to load action '{action_type}': {str(e)}"
            )
E           biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_executor.py:99: MappingExecutionError

During handling of the above exception, another exception occurred:

self = <tests.integration.test_yaml_strategy_execution.TestYAMLStrategyExecution object at 0x7c203f511750>
setup_optional_test_environment = <biomapper.core.mapping_executor.MappingExecutor object at 0x7c202c67e190>
mock_client_files = {'filter_target': '/home/trentleslie/github/biomapper/tests/integration/data/mock_client_files/test_filter_target.csv'...t_hgnc.tsv', 'uniprot': '/home/trentleslie/github/biomapper/tests/integration/data/mock_client_files/test_uniprot.tsv'}

    async def test_optional_fail_first_strategy(self, setup_optional_test_environment, mock_client_files):
        """Test strategy where first step is optional and fails."""
        initial_ids = ["TEST1", "TEST2"]
    
        executor = setup_optional_test_environment
    
>       result = await executor.execute_yaml_strategy(
            strategy_name="optional_fail_first_strategy",
            source_endpoint_name="test_source",
            target_endpoint_name="test_target",
            input_identifiers=initial_ids,
            source_ontology_type="hgnc",
        )

tests/integration/test_yaml_strategy_execution.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/mapping_executor.py:261: in execute_yaml_strategy
    return await self.strategy_coordinator.execute_yaml_strategy(
biomapper/core/engine_components/strategy_coordinator_service.py:148: in execute_yaml_strategy
    return await self.yaml_strategy_execution_service.execute(
biomapper/core/services/execution_services.py:625: in execute
    return await self.strategy_orchestrator.execute_strategy(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c202c67dc10>
strategy_name = 'optional_fail_first_strategy'
input_identifiers = ['TEST1', 'TEST2'], initial_context = None
source_endpoint_name = 'test_source', target_endpoint_name = 'test_target'
mapping_session_id = None, source_ontology_type = 'hgnc'
target_ontology_type = None, use_cache = True, max_cache_age_days = None
progress_callback = None, batch_size = 250, min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
                    result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )
    
                    # Track step result
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "success",
                        "input_count": len(current_identifiers),
                        "output_count": len(result.get('output_identifiers', [])),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds(),
                        "details": result.get('details', {})
                    }
    
                    # Update current state
                    current_identifiers = result.get('output_identifiers', [])
                    current_ontology_type = result.get('output_ontology_type', current_ontology_type)
    
                    # Update context with current state
                    strategy_context['current_identifiers'] = current_identifiers
                    strategy_context['current_ontology_type'] = current_ontology_type
    
                    # Accumulate provenance if present
                    if 'provenance' in result:
                        strategy_context['all_provenance'].extend(result['provenance'])
    
                except Exception as e:
                    self.logger.error(f"Step {step.step_id} failed: {str(e)}")
    
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "failed",
                        "error": str(e),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds()
                    }
    
                    # Check if step is required
                    if step.is_required:
>                       raise MappingExecutionError(
                            f"Required step '{step.step_id}' failed: {str(e)}"
                        )
E                       biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Required step 'S2_REQUIRED_CONVERT' failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/strategy_orchestrator.py:233: MappingExecutionError
------------------------------ Captured log setup ------------------------------
WARNING  langfuse:client.py:259 Langfuse client is disabled since no public_key was provided as a parameter or environment variable 'LANGFUSE_PUBLIC_KEY'. See our docs: https://langfuse.com/docs/sdk/python/low-level-sdk#initialize-client
------------------------------ Captured log call -------------------------------
ERROR    biomapper.core.engine_components.initialization_service:strategy_orchestrator.py:220 Step S1_OPTIONAL_FAIL_FIRST failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.
ERROR    biomapper.core.engine_components.initialization_service:strategy_orchestrator.py:220 Step S2_REQUIRED_CONVERT failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.
__________ TestYAMLStrategyExecution.test_optional_fail_last_strategy __________

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c20343f8e90>
step = <MappingStrategyStep id=9 strategy=4 step=S1_REQUIRED_SUCCESS order=1 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['TEST1', 'TEST2', 'TEST3']
current_ontology_type = 'hgnc'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c20342756d0>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c2034275b90>
use_cache = True, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': True}, 'current_identifiers': ['TEST1', 'TEST2', 'TEST3'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c2034413c90>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
>           action = self.action_loader.instantiate_action(action_type, db_session)

biomapper/core/engine_components/action_executor.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/engine_components/action_loader.py:137: in instantiate_action
    action_class = self.load_action_class(action_type)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_loader.ActionLoader object at 0x7c20343f9150>
action_type = 'CONVERT_IDENTIFIERS_LOCAL'

    def load_action_class(self, action_type: str) -> Type[StrategyAction]:
        """
        Load an action class by type or class path.
    
        Args:
            action_type: Either a registered action type (e.g., "CONVERT_IDENTIFIERS_LOCAL")
                        or a full class path (e.g., "biomapper.core.strategy_actions.load_endpoint_identifiers.LoadEndpointIdentifiersAction")
    
        Returns:
            The action class ready for instantiation
    
        Raises:
            ConfigurationError: If the action cannot be loaded
        """
        # First check if it's a registered action type
        if action_type in self.action_registry:
            logger.debug(f"Found action '{action_type}' in registry")
            return self.action_registry[action_type]
    
        # If not in registry, try to load it as a class path
        if '.' in action_type:
            logger.debug(f"Attempting to load action from class path: {action_type}")
            return self._load_from_class_path(action_type)
    
        # Neither registry nor class path
>       raise ConfigurationError(
            f"Unknown action type: '{action_type}'. "
            f"Action must be either registered in ACTION_REGISTRY or specified as a full class path."
        )
E       biomapper.core.exceptions.ConfigurationError: [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_loader.py:61: ConfigurationError

During handling of the above exception, another exception occurred:

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c20343fac90>
strategy_name = 'optional_fail_last_strategy'
input_identifiers = ['TEST1', 'TEST2', 'TEST3'], initial_context = None
source_endpoint_name = 'test_source', target_endpoint_name = 'test_target'
mapping_session_id = None, source_ontology_type = 'hgnc'
target_ontology_type = None, use_cache = True, max_cache_age_days = None
progress_callback = None, batch_size = 250, min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
>                   result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )

biomapper/core/engine_components/strategy_orchestrator.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c20343f8e90>
step = <MappingStrategyStep id=9 strategy=4 step=S1_REQUIRED_SUCCESS order=1 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['TEST1', 'TEST2', 'TEST3']
current_ontology_type = 'hgnc'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c20342756d0>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c2034275b90>
use_cache = True, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': True}, 'current_identifiers': ['TEST1', 'TEST2', 'TEST3'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c2034413c90>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
            action = self.action_loader.instantiate_action(action_type, db_session)
        except Exception as e:
>           raise MappingExecutionError(
                f"Failed to load action '{action_type}': {str(e)}"
            )
E           biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_executor.py:99: MappingExecutionError

During handling of the above exception, another exception occurred:

self = <tests.integration.test_yaml_strategy_execution.TestYAMLStrategyExecution object at 0x7c203f5121d0>
setup_optional_test_environment = <biomapper.core.mapping_executor.MappingExecutor object at 0x7c20343f9850>
mock_client_files = {'filter_target': '/home/trentleslie/github/biomapper/tests/integration/data/mock_client_files/test_filter_target.csv'...t_hgnc.tsv', 'uniprot': '/home/trentleslie/github/biomapper/tests/integration/data/mock_client_files/test_uniprot.tsv'}

    async def test_optional_fail_last_strategy(self, setup_optional_test_environment, mock_client_files):
        """Test strategy where last step is optional and fails."""
        initial_ids = ["TEST1", "TEST2", "TEST3"]
    
        executor = setup_optional_test_environment
    
>       result = await executor.execute_yaml_strategy(
            strategy_name="optional_fail_last_strategy",
            source_endpoint_name="test_source",
            target_endpoint_name="test_target",
            input_identifiers=initial_ids,
            source_ontology_type="hgnc",
        )

tests/integration/test_yaml_strategy_execution.py:513: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/mapping_executor.py:261: in execute_yaml_strategy
    return await self.strategy_coordinator.execute_yaml_strategy(
biomapper/core/engine_components/strategy_coordinator_service.py:148: in execute_yaml_strategy
    return await self.yaml_strategy_execution_service.execute(
biomapper/core/services/execution_services.py:625: in execute
    return await self.strategy_orchestrator.execute_strategy(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c20343fac90>
strategy_name = 'optional_fail_last_strategy'
input_identifiers = ['TEST1', 'TEST2', 'TEST3'], initial_context = None
source_endpoint_name = 'test_source', target_endpoint_name = 'test_target'
mapping_session_id = None, source_ontology_type = 'hgnc'
target_ontology_type = None, use_cache = True, max_cache_age_days = None
progress_callback = None, batch_size = 250, min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
                    result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )
    
                    # Track step result
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "success",
                        "input_count": len(current_identifiers),
                        "output_count": len(result.get('output_identifiers', [])),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds(),
                        "details": result.get('details', {})
                    }
    
                    # Update current state
                    current_identifiers = result.get('output_identifiers', [])
                    current_ontology_type = result.get('output_ontology_type', current_ontology_type)
    
                    # Update context with current state
                    strategy_context['current_identifiers'] = current_identifiers
                    strategy_context['current_ontology_type'] = current_ontology_type
    
                    # Accumulate provenance if present
                    if 'provenance' in result:
                        strategy_context['all_provenance'].extend(result['provenance'])
    
                except Exception as e:
                    self.logger.error(f"Step {step.step_id} failed: {str(e)}")
    
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "failed",
                        "error": str(e),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds()
                    }
    
                    # Check if step is required
                    if step.is_required:
>                       raise MappingExecutionError(
                            f"Required step '{step.step_id}' failed: {str(e)}"
                        )
E                       biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Required step 'S1_REQUIRED_SUCCESS' failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/strategy_orchestrator.py:233: MappingExecutionError
------------------------------ Captured log setup ------------------------------
WARNING  langfuse:client.py:259 Langfuse client is disabled since no public_key was provided as a parameter or environment variable 'LANGFUSE_PUBLIC_KEY'. See our docs: https://langfuse.com/docs/sdk/python/low-level-sdk#initialize-client
------------------------------ Captured log call -------------------------------
ERROR    biomapper.core.engine_components.initialization_service:strategy_orchestrator.py:220 Step S1_REQUIRED_SUCCESS failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.
______ TestYAMLStrategyExecution.test_multiple_optional_failures_strategy ______

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c203406fc50>
step = <MappingStrategyStep id=13 strategy=5 step=S3_REQUIRED_SUCCESS order=3 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['TEST1', 'TEST2'], current_ontology_type = 'hgnc'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c42fe50>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c41a010>
use_cache = True, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': True}, 'current_identifiers': ['TEST1', 'TEST2'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c202c484490>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
>           action = self.action_loader.instantiate_action(action_type, db_session)

biomapper/core/engine_components/action_executor.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/engine_components/action_loader.py:137: in instantiate_action
    action_class = self.load_action_class(action_type)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_loader.ActionLoader object at 0x7c203406c690>
action_type = 'CONVERT_IDENTIFIERS_LOCAL'

    def load_action_class(self, action_type: str) -> Type[StrategyAction]:
        """
        Load an action class by type or class path.
    
        Args:
            action_type: Either a registered action type (e.g., "CONVERT_IDENTIFIERS_LOCAL")
                        or a full class path (e.g., "biomapper.core.strategy_actions.load_endpoint_identifiers.LoadEndpointIdentifiersAction")
    
        Returns:
            The action class ready for instantiation
    
        Raises:
            ConfigurationError: If the action cannot be loaded
        """
        # First check if it's a registered action type
        if action_type in self.action_registry:
            logger.debug(f"Found action '{action_type}' in registry")
            return self.action_registry[action_type]
    
        # If not in registry, try to load it as a class path
        if '.' in action_type:
            logger.debug(f"Attempting to load action from class path: {action_type}")
            return self._load_from_class_path(action_type)
    
        # Neither registry nor class path
>       raise ConfigurationError(
            f"Unknown action type: '{action_type}'. "
            f"Action must be either registered in ACTION_REGISTRY or specified as a full class path."
        )
E       biomapper.core.exceptions.ConfigurationError: [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_loader.py:61: ConfigurationError

During handling of the above exception, another exception occurred:

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c203406f7d0>
strategy_name = 'multiple_optional_failures_strategy'
input_identifiers = ['TEST1', 'TEST2'], initial_context = None
source_endpoint_name = 'test_source', target_endpoint_name = 'test_target'
mapping_session_id = None, source_ontology_type = 'hgnc'
target_ontology_type = None, use_cache = True, max_cache_age_days = None
progress_callback = None, batch_size = 250, min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
>                   result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )

biomapper/core/engine_components/strategy_orchestrator.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c203406fc50>
step = <MappingStrategyStep id=13 strategy=5 step=S3_REQUIRED_SUCCESS order=3 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['TEST1', 'TEST2'], current_ontology_type = 'hgnc'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c42fe50>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c41a010>
use_cache = True, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': True}, 'current_identifiers': ['TEST1', 'TEST2'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c202c484490>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
            action = self.action_loader.instantiate_action(action_type, db_session)
        except Exception as e:
>           raise MappingExecutionError(
                f"Failed to load action '{action_type}': {str(e)}"
            )
E           biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_executor.py:99: MappingExecutionError

During handling of the above exception, another exception occurred:

self = <tests.integration.test_yaml_strategy_execution.TestYAMLStrategyExecution object at 0x7c203fbcd310>
setup_optional_test_environment = <biomapper.core.mapping_executor.MappingExecutor object at 0x7c202c74e9d0>
mock_client_files = {'filter_target': '/home/trentleslie/github/biomapper/tests/integration/data/mock_client_files/test_filter_target.csv'...t_hgnc.tsv', 'uniprot': '/home/trentleslie/github/biomapper/tests/integration/data/mock_client_files/test_uniprot.tsv'}

    async def test_multiple_optional_failures_strategy(self, setup_optional_test_environment, mock_client_files):
        """Test strategy with multiple optional steps failing in sequence."""
        initial_ids = ["TEST1", "TEST2"]
    
        executor = setup_optional_test_environment
    
>       result = await executor.execute_yaml_strategy(
            strategy_name="multiple_optional_failures_strategy",
            source_endpoint_name="test_source",
            target_endpoint_name="test_target",
            input_identifiers=initial_ids,
            source_ontology_type="hgnc",
        )

tests/integration/test_yaml_strategy_execution.py:546: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/mapping_executor.py:261: in execute_yaml_strategy
    return await self.strategy_coordinator.execute_yaml_strategy(
biomapper/core/engine_components/strategy_coordinator_service.py:148: in execute_yaml_strategy
    return await self.yaml_strategy_execution_service.execute(
biomapper/core/services/execution_services.py:625: in execute
    return await self.strategy_orchestrator.execute_strategy(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c203406f7d0>
strategy_name = 'multiple_optional_failures_strategy'
input_identifiers = ['TEST1', 'TEST2'], initial_context = None
source_endpoint_name = 'test_source', target_endpoint_name = 'test_target'
mapping_session_id = None, source_ontology_type = 'hgnc'
target_ontology_type = None, use_cache = True, max_cache_age_days = None
progress_callback = None, batch_size = 250, min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
                    result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )
    
                    # Track step result
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "success",
                        "input_count": len(current_identifiers),
                        "output_count": len(result.get('output_identifiers', [])),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds(),
                        "details": result.get('details', {})
                    }
    
                    # Update current state
                    current_identifiers = result.get('output_identifiers', [])
                    current_ontology_type = result.get('output_ontology_type', current_ontology_type)
    
                    # Update context with current state
                    strategy_context['current_identifiers'] = current_identifiers
                    strategy_context['current_ontology_type'] = current_ontology_type
    
                    # Accumulate provenance if present
                    if 'provenance' in result:
                        strategy_context['all_provenance'].extend(result['provenance'])
    
                except Exception as e:
                    self.logger.error(f"Step {step.step_id} failed: {str(e)}")
    
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "failed",
                        "error": str(e),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds()
                    }
    
                    # Check if step is required
                    if step.is_required:
>                       raise MappingExecutionError(
                            f"Required step '{step.step_id}' failed: {str(e)}"
                        )
E                       biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Required step 'S3_REQUIRED_SUCCESS' failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/strategy_orchestrator.py:233: MappingExecutionError
------------------------------ Captured log setup ------------------------------
WARNING  langfuse:client.py:259 Langfuse client is disabled since no public_key was provided as a parameter or environment variable 'LANGFUSE_PUBLIC_KEY'. See our docs: https://langfuse.com/docs/sdk/python/low-level-sdk#initialize-client
------------------------------ Captured log call -------------------------------
ERROR    biomapper.core.engine_components.initialization_service:strategy_orchestrator.py:220 Step S1_OPTIONAL_FAIL_1 failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.
ERROR    biomapper.core.engine_components.action_executor:action_executor.py:120 Error executing strategy action EXECUTE_MAPPING_PATH: Mapping path 'non_existent_path' not found
ERROR    biomapper.core.engine_components.initialization_service:strategy_orchestrator.py:220 Step S2_OPTIONAL_FAIL_2 failed: [MAPPING_EXECUTION_ERROR] Strategy action EXECUTE_MAPPING_PATH failed: Mapping path 'non_existent_path' not found
ERROR    biomapper.core.engine_components.initialization_service:strategy_orchestrator.py:220 Step S3_REQUIRED_SUCCESS failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.
_____ TestYAMLStrategyExecution.test_required_fail_after_optional_strategy _____

self = <tests.integration.test_yaml_strategy_execution.TestYAMLStrategyExecution object at 0x7c203f511cd0>
setup_optional_test_environment = <biomapper.core.mapping_executor.MappingExecutor object at 0x7c203c271d50>
mock_client_files = {'filter_target': '/home/trentleslie/github/biomapper/tests/integration/data/mock_client_files/test_filter_target.csv'...t_hgnc.tsv', 'uniprot': '/home/trentleslie/github/biomapper/tests/integration/data/mock_client_files/test_uniprot.tsv'}

    async def test_required_fail_after_optional_strategy(self, setup_optional_test_environment, mock_client_files):
        """Test strategy where required step fails after optional steps."""
        initial_ids = ["TEST1", "TEST2"]
    
        executor = setup_optional_test_environment
    
        # This should raise an error because required step fails
>       with pytest.raises(MappingExecutionError) as exc_info:
E       Failed: DID NOT RAISE <class 'biomapper.core.exceptions.MappingExecutionError'>

tests/integration/test_yaml_strategy_execution.py:581: Failed
------------------------------ Captured log setup ------------------------------
WARNING  langfuse:client.py:259 Langfuse client is disabled since no public_key was provided as a parameter or environment variable 'LANGFUSE_PUBLIC_KEY'. See our docs: https://langfuse.com/docs/sdk/python/low-level-sdk#initialize-client
------------------------------ Captured log call -------------------------------
ERROR    biomapper.core.engine_components.initialization_service:strategy_orchestrator.py:220 Step S1_OPTIONAL_SUCCESS failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.
WARNING  biomapper.core.engine_components.initialization_service:strategy_orchestrator.py:241 No identifiers remaining, stopping strategy execution
________ TestYAMLStrategyExecution.test_mapping_result_bundle_tracking _________

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c202c63c5d0>
step = <MappingStrategyStep id=4 strategy=2 step=S1_REQUIRED order=1 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['TEST1', 'TEST2'], current_ontology_type = 'hgnc'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c20342fa5d0>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c20342fbd50>
use_cache = True, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': True}, 'current_identifiers': ['TEST1', 'TEST2'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c203c271fd0>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
>           action = self.action_loader.instantiate_action(action_type, db_session)

biomapper/core/engine_components/action_executor.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/engine_components/action_loader.py:137: in instantiate_action
    action_class = self.load_action_class(action_type)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_loader.ActionLoader object at 0x7c202c63c1d0>
action_type = 'CONVERT_IDENTIFIERS_LOCAL'

    def load_action_class(self, action_type: str) -> Type[StrategyAction]:
        """
        Load an action class by type or class path.
    
        Args:
            action_type: Either a registered action type (e.g., "CONVERT_IDENTIFIERS_LOCAL")
                        or a full class path (e.g., "biomapper.core.strategy_actions.load_endpoint_identifiers.LoadEndpointIdentifiersAction")
    
        Returns:
            The action class ready for instantiation
    
        Raises:
            ConfigurationError: If the action cannot be loaded
        """
        # First check if it's a registered action type
        if action_type in self.action_registry:
            logger.debug(f"Found action '{action_type}' in registry")
            return self.action_registry[action_type]
    
        # If not in registry, try to load it as a class path
        if '.' in action_type:
            logger.debug(f"Attempting to load action from class path: {action_type}")
            return self._load_from_class_path(action_type)
    
        # Neither registry nor class path
>       raise ConfigurationError(
            f"Unknown action type: '{action_type}'. "
            f"Action must be either registered in ACTION_REGISTRY or specified as a full class path."
        )
E       biomapper.core.exceptions.ConfigurationError: [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_loader.py:61: ConfigurationError

During handling of the above exception, another exception occurred:

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c202c63c2d0>
strategy_name = 'mixed_required_optional_strategy'
input_identifiers = ['TEST1', 'TEST2'], initial_context = None
source_endpoint_name = 'test_source', target_endpoint_name = 'test_target'
mapping_session_id = None, source_ontology_type = 'hgnc'
target_ontology_type = None, use_cache = True, max_cache_age_days = None
progress_callback = None, batch_size = 250, min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
>                   result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )

biomapper/core/engine_components/strategy_orchestrator.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c202c63c5d0>
step = <MappingStrategyStep id=4 strategy=2 step=S1_REQUIRED order=1 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['TEST1', 'TEST2'], current_ontology_type = 'hgnc'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c20342fa5d0>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c20342fbd50>
use_cache = True, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': True}, 'current_identifiers': ['TEST1', 'TEST2'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c203c271fd0>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
            action = self.action_loader.instantiate_action(action_type, db_session)
        except Exception as e:
>           raise MappingExecutionError(
                f"Failed to load action '{action_type}': {str(e)}"
            )
E           biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_executor.py:99: MappingExecutionError

During handling of the above exception, another exception occurred:

self = <tests.integration.test_yaml_strategy_execution.TestYAMLStrategyExecution object at 0x7c203f5134d0>
setup_optional_test_environment = <biomapper.core.mapping_executor.MappingExecutor object at 0x7c202c477990>
mock_client_files = {'filter_target': '/home/trentleslie/github/biomapper/tests/integration/data/mock_client_files/test_filter_target.csv'...t_hgnc.tsv', 'uniprot': '/home/trentleslie/github/biomapper/tests/integration/data/mock_client_files/test_uniprot.tsv'}

    async def test_mapping_result_bundle_tracking(self, setup_optional_test_environment, mock_client_files):
        """Test that MappingResultBundle correctly tracks optional step failures."""
        initial_ids = ["TEST1", "TEST2"]
    
        executor = setup_optional_test_environment
    
>       result = await executor.execute_yaml_strategy(
            strategy_name="mixed_required_optional_strategy",
            source_endpoint_name="test_source",
            target_endpoint_name="test_target",
            input_identifiers=initial_ids,
            source_ontology_type="hgnc",
        )

tests/integration/test_yaml_strategy_execution.py:652: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/mapping_executor.py:261: in execute_yaml_strategy
    return await self.strategy_coordinator.execute_yaml_strategy(
biomapper/core/engine_components/strategy_coordinator_service.py:148: in execute_yaml_strategy
    return await self.yaml_strategy_execution_service.execute(
biomapper/core/services/execution_services.py:625: in execute
    return await self.strategy_orchestrator.execute_strategy(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c202c63c2d0>
strategy_name = 'mixed_required_optional_strategy'
input_identifiers = ['TEST1', 'TEST2'], initial_context = None
source_endpoint_name = 'test_source', target_endpoint_name = 'test_target'
mapping_session_id = None, source_ontology_type = 'hgnc'
target_ontology_type = None, use_cache = True, max_cache_age_days = None
progress_callback = None, batch_size = 250, min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
                    result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )
    
                    # Track step result
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "success",
                        "input_count": len(current_identifiers),
                        "output_count": len(result.get('output_identifiers', [])),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds(),
                        "details": result.get('details', {})
                    }
    
                    # Update current state
                    current_identifiers = result.get('output_identifiers', [])
                    current_ontology_type = result.get('output_ontology_type', current_ontology_type)
    
                    # Update context with current state
                    strategy_context['current_identifiers'] = current_identifiers
                    strategy_context['current_ontology_type'] = current_ontology_type
    
                    # Accumulate provenance if present
                    if 'provenance' in result:
                        strategy_context['all_provenance'].extend(result['provenance'])
    
                except Exception as e:
                    self.logger.error(f"Step {step.step_id} failed: {str(e)}")
    
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "failed",
                        "error": str(e),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds()
                    }
    
                    # Check if step is required
                    if step.is_required:
>                       raise MappingExecutionError(
                            f"Required step '{step.step_id}' failed: {str(e)}"
                        )
E                       biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Required step 'S1_REQUIRED' failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/strategy_orchestrator.py:233: MappingExecutionError
------------------------------ Captured log setup ------------------------------
WARNING  langfuse:client.py:259 Langfuse client is disabled since no public_key was provided as a parameter or environment variable 'LANGFUSE_PUBLIC_KEY'. See our docs: https://langfuse.com/docs/sdk/python/low-level-sdk#initialize-client
------------------------------ Captured log call -------------------------------
ERROR    biomapper.core.engine_components.initialization_service:strategy_orchestrator.py:220 Step S1_REQUIRED failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.
__________ TestUKBBToHPAYAMLStrategy.test_execute_yaml_strategy_basic __________

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c2034127cd0>
step = <MappingStrategyStep id=1 strategy=1 step=S1_CONVERT_TO_GENE order=1 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['TEST1', 'TEST2'], current_ontology_type = 'UNKNOWN'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c207e10>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c204c50>
use_cache = False, max_cache_age_days = None, batch_size = 100
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 100, 'cache_settings': {'max_cache_age_days': None, 'use_cache': False}, 'current_identifiers': ['TEST1', 'TEST2'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c202c7df390>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
>           action = self.action_loader.instantiate_action(action_type, db_session)

biomapper/core/engine_components/action_executor.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/engine_components/action_loader.py:137: in instantiate_action
    action_class = self.load_action_class(action_type)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_loader.ActionLoader object at 0x7c2034127bd0>
action_type = 'CONVERT_IDENTIFIERS_LOCAL'

    def load_action_class(self, action_type: str) -> Type[StrategyAction]:
        """
        Load an action class by type or class path.
    
        Args:
            action_type: Either a registered action type (e.g., "CONVERT_IDENTIFIERS_LOCAL")
                        or a full class path (e.g., "biomapper.core.strategy_actions.load_endpoint_identifiers.LoadEndpointIdentifiersAction")
    
        Returns:
            The action class ready for instantiation
    
        Raises:
            ConfigurationError: If the action cannot be loaded
        """
        # First check if it's a registered action type
        if action_type in self.action_registry:
            logger.debug(f"Found action '{action_type}' in registry")
            return self.action_registry[action_type]
    
        # If not in registry, try to load it as a class path
        if '.' in action_type:
            logger.debug(f"Attempting to load action from class path: {action_type}")
            return self._load_from_class_path(action_type)
    
        # Neither registry nor class path
>       raise ConfigurationError(
            f"Unknown action type: '{action_type}'. "
            f"Action must be either registered in ACTION_REGISTRY or specified as a full class path."
        )
E       biomapper.core.exceptions.ConfigurationError: [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_loader.py:61: ConfigurationError

During handling of the above exception, another exception occurred:

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c20341263d0>
strategy_name = 'basic_linear_strategy', input_identifiers = ['TEST1', 'TEST2']
initial_context = None, source_endpoint_name = 'test_source'
target_endpoint_name = 'test_target', mapping_session_id = None
source_ontology_type = None, target_ontology_type = None, use_cache = False
max_cache_age_days = None, progress_callback = None, batch_size = 100
min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
>                   result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )

biomapper/core/engine_components/strategy_orchestrator.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c2034127cd0>
step = <MappingStrategyStep id=1 strategy=1 step=S1_CONVERT_TO_GENE order=1 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['TEST1', 'TEST2'], current_ontology_type = 'UNKNOWN'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c207e10>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c204c50>
use_cache = False, max_cache_age_days = None, batch_size = 100
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 100, 'cache_settings': {'max_cache_age_days': None, 'use_cache': False}, 'current_identifiers': ['TEST1', 'TEST2'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c202c7df390>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
            action = self.action_loader.instantiate_action(action_type, db_session)
        except Exception as e:
>           raise MappingExecutionError(
                f"Failed to load action '{action_type}': {str(e)}"
            )
E           biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_executor.py:99: MappingExecutionError

During handling of the above exception, another exception occurred:

self = <tests.integration.test_yaml_strategy_ukbb_hpa.TestUKBBToHPAYAMLStrategy object at 0x7c203fb5cb10>
mapping_executor = <biomapper.core.mapping_executor.MappingExecutor object at 0x7c20341272d0>

    @pytest.mark.asyncio
    async def test_execute_yaml_strategy_basic(self, mapping_executor):
        """Test basic execution of the YAML strategy."""
        # Sample test identifiers - using gene symbols that exist in test data
        test_identifiers = ["TEST1", "TEST2"]
    
        # Execute the strategy
>       result = await mapping_executor.execute_yaml_strategy(
            strategy_name="basic_linear_strategy",
            source_endpoint_name="test_source",
            target_endpoint_name="test_target",
            input_identifiers=test_identifiers,
            use_cache=False,
            batch_size=100
        )

tests/integration/test_yaml_strategy_ukbb_hpa.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/mapping_executor.py:261: in execute_yaml_strategy
    return await self.strategy_coordinator.execute_yaml_strategy(
biomapper/core/engine_components/strategy_coordinator_service.py:148: in execute_yaml_strategy
    return await self.yaml_strategy_execution_service.execute(
biomapper/core/services/execution_services.py:625: in execute
    return await self.strategy_orchestrator.execute_strategy(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c20341263d0>
strategy_name = 'basic_linear_strategy', input_identifiers = ['TEST1', 'TEST2']
initial_context = None, source_endpoint_name = 'test_source'
target_endpoint_name = 'test_target', mapping_session_id = None
source_ontology_type = None, target_ontology_type = None, use_cache = False
max_cache_age_days = None, progress_callback = None, batch_size = 100
min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
                    result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )
    
                    # Track step result
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "success",
                        "input_count": len(current_identifiers),
                        "output_count": len(result.get('output_identifiers', [])),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds(),
                        "details": result.get('details', {})
                    }
    
                    # Update current state
                    current_identifiers = result.get('output_identifiers', [])
                    current_ontology_type = result.get('output_ontology_type', current_ontology_type)
    
                    # Update context with current state
                    strategy_context['current_identifiers'] = current_identifiers
                    strategy_context['current_ontology_type'] = current_ontology_type
    
                    # Accumulate provenance if present
                    if 'provenance' in result:
                        strategy_context['all_provenance'].extend(result['provenance'])
    
                except Exception as e:
                    self.logger.error(f"Step {step.step_id} failed: {str(e)}")
    
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "failed",
                        "error": str(e),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds()
                    }
    
                    # Check if step is required
                    if step.is_required:
>                       raise MappingExecutionError(
                            f"Required step '{step.step_id}' failed: {str(e)}"
                        )
E                       biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Required step 'S1_CONVERT_TO_GENE' failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/strategy_orchestrator.py:233: MappingExecutionError
---------------------------- Captured stdout setup -----------------------------
Loading test config from: /home/trentleslie/github/biomapper/tests/integration/data/test_protein_strategy_config.yaml
------------------------------ Captured log setup ------------------------------
WARNING  langfuse:client.py:259 Langfuse client is disabled since no public_key was provided as a parameter or environment variable 'LANGFUSE_PUBLIC_KEY'. See our docs: https://langfuse.com/docs/sdk/python/low-level-sdk#initialize-client
WARNING  langfuse:client.py:259 Langfuse client is disabled since no public_key was provided as a parameter or environment variable 'LANGFUSE_PUBLIC_KEY'. See our docs: https://langfuse.com/docs/sdk/python/low-level-sdk#initialize-client
------------------------------ Captured log call -------------------------------
ERROR    biomapper.core.engine_components.initialization_service:strategy_orchestrator.py:220 Step S1_CONVERT_TO_GENE failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.
_ TestUKBBToHPAYAMLStrategy.test_execute_yaml_strategy_with_progress_callback __

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c202c1f7fd0>
step = <MappingStrategyStep id=1 strategy=1 step=S1_CONVERT_TO_GENE order=1 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['TEST1', 'TEST2'], current_ontology_type = 'UNKNOWN'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c19df50>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c19fed0>
use_cache = False, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': False}, 'current_identifiers': ['TEST1', 'TEST2'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c202c165350>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
>           action = self.action_loader.instantiate_action(action_type, db_session)

biomapper/core/engine_components/action_executor.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/engine_components/action_loader.py:137: in instantiate_action
    action_class = self.load_action_class(action_type)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_loader.ActionLoader object at 0x7c202c1f7f10>
action_type = 'CONVERT_IDENTIFIERS_LOCAL'

    def load_action_class(self, action_type: str) -> Type[StrategyAction]:
        """
        Load an action class by type or class path.
    
        Args:
            action_type: Either a registered action type (e.g., "CONVERT_IDENTIFIERS_LOCAL")
                        or a full class path (e.g., "biomapper.core.strategy_actions.load_endpoint_identifiers.LoadEndpointIdentifiersAction")
    
        Returns:
            The action class ready for instantiation
    
        Raises:
            ConfigurationError: If the action cannot be loaded
        """
        # First check if it's a registered action type
        if action_type in self.action_registry:
            logger.debug(f"Found action '{action_type}' in registry")
            return self.action_registry[action_type]
    
        # If not in registry, try to load it as a class path
        if '.' in action_type:
            logger.debug(f"Attempting to load action from class path: {action_type}")
            return self._load_from_class_path(action_type)
    
        # Neither registry nor class path
>       raise ConfigurationError(
            f"Unknown action type: '{action_type}'. "
            f"Action must be either registered in ACTION_REGISTRY or specified as a full class path."
        )
E       biomapper.core.exceptions.ConfigurationError: [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_loader.py:61: ConfigurationError

During handling of the above exception, another exception occurred:

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c202c1f7f50>
strategy_name = 'basic_linear_strategy', input_identifiers = ['TEST1', 'TEST2']
initial_context = None, source_endpoint_name = 'test_source'
target_endpoint_name = 'test_target', mapping_session_id = None
source_ontology_type = None, target_ontology_type = None, use_cache = False
max_cache_age_days = None
progress_callback = <function TestUKBBToHPAYAMLStrategy.test_execute_yaml_strategy_with_progress_callback.<locals>.progress_callback at 0x7c202c136e80>
batch_size = 250, min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
>                   result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )

biomapper/core/engine_components/strategy_orchestrator.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c202c1f7fd0>
step = <MappingStrategyStep id=1 strategy=1 step=S1_CONVERT_TO_GENE order=1 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['TEST1', 'TEST2'], current_ontology_type = 'UNKNOWN'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c19df50>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c19fed0>
use_cache = False, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': False}, 'current_identifiers': ['TEST1', 'TEST2'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c202c165350>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
            action = self.action_loader.instantiate_action(action_type, db_session)
        except Exception as e:
>           raise MappingExecutionError(
                f"Failed to load action '{action_type}': {str(e)}"
            )
E           biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_executor.py:99: MappingExecutionError

During handling of the above exception, another exception occurred:

self = <tests.integration.test_yaml_strategy_ukbb_hpa.TestUKBBToHPAYAMLStrategy object at 0x7c203fb5e450>
mapping_executor = <biomapper.core.mapping_executor.MappingExecutor object at 0x7c202c19c610>

    @pytest.mark.asyncio
    async def test_execute_yaml_strategy_with_progress_callback(self, mapping_executor):
        """Test execution with progress callback."""
        progress_updates = []
    
        def progress_callback(current: int, total: int, status: str):
            progress_updates.append({
                "current": current,
                "total": total,
                "status": status
            })
    
        test_identifiers = ["TEST1", "TEST2"]
    
>       result = await mapping_executor.execute_yaml_strategy(
            strategy_name="basic_linear_strategy",
            source_endpoint_name="test_source",
            target_endpoint_name="test_target",
            input_identifiers=test_identifiers,
            progress_callback=progress_callback,
            use_cache=False
        )

tests/integration/test_yaml_strategy_ukbb_hpa.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/mapping_executor.py:261: in execute_yaml_strategy
    return await self.strategy_coordinator.execute_yaml_strategy(
biomapper/core/engine_components/strategy_coordinator_service.py:148: in execute_yaml_strategy
    return await self.yaml_strategy_execution_service.execute(
biomapper/core/services/execution_services.py:625: in execute
    return await self.strategy_orchestrator.execute_strategy(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c202c1f7f50>
strategy_name = 'basic_linear_strategy', input_identifiers = ['TEST1', 'TEST2']
initial_context = None, source_endpoint_name = 'test_source'
target_endpoint_name = 'test_target', mapping_session_id = None
source_ontology_type = None, target_ontology_type = None, use_cache = False
max_cache_age_days = None
progress_callback = <function TestUKBBToHPAYAMLStrategy.test_execute_yaml_strategy_with_progress_callback.<locals>.progress_callback at 0x7c202c136e80>
batch_size = 250, min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
                    result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )
    
                    # Track step result
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "success",
                        "input_count": len(current_identifiers),
                        "output_count": len(result.get('output_identifiers', [])),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds(),
                        "details": result.get('details', {})
                    }
    
                    # Update current state
                    current_identifiers = result.get('output_identifiers', [])
                    current_ontology_type = result.get('output_ontology_type', current_ontology_type)
    
                    # Update context with current state
                    strategy_context['current_identifiers'] = current_identifiers
                    strategy_context['current_ontology_type'] = current_ontology_type
    
                    # Accumulate provenance if present
                    if 'provenance' in result:
                        strategy_context['all_provenance'].extend(result['provenance'])
    
                except Exception as e:
                    self.logger.error(f"Step {step.step_id} failed: {str(e)}")
    
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "failed",
                        "error": str(e),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds()
                    }
    
                    # Check if step is required
                    if step.is_required:
>                       raise MappingExecutionError(
                            f"Required step '{step.step_id}' failed: {str(e)}"
                        )
E                       biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Required step 'S1_CONVERT_TO_GENE' failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/strategy_orchestrator.py:233: MappingExecutionError
---------------------------- Captured stdout setup -----------------------------
Loading test config from: /home/trentleslie/github/biomapper/tests/integration/data/test_protein_strategy_config.yaml
------------------------------ Captured log setup ------------------------------
WARNING  langfuse:client.py:259 Langfuse client is disabled since no public_key was provided as a parameter or environment variable 'LANGFUSE_PUBLIC_KEY'. See our docs: https://langfuse.com/docs/sdk/python/low-level-sdk#initialize-client
WARNING  langfuse:client.py:259 Langfuse client is disabled since no public_key was provided as a parameter or environment variable 'LANGFUSE_PUBLIC_KEY'. See our docs: https://langfuse.com/docs/sdk/python/low-level-sdk#initialize-client
------------------------------ Captured log call -------------------------------
ERROR    biomapper.core.engine_components.initialization_service:strategy_orchestrator.py:220 Step S1_CONVERT_TO_GENE failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.
_____ TestUKBBToHPAYAMLStrategy.test_action_handlers_placeholder_behavior ______

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c202c14a0d0>
step = <MappingStrategyStep id=1 strategy=1 step=S1_CONVERT_TO_GENE order=1 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['TEST1', 'TEST2'], current_ontology_type = 'UNKNOWN'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c29fa50>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c258410>
use_cache = False, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': False}, 'current_identifiers': ['TEST1', 'TEST2'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c202c4ebf10>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
>           action = self.action_loader.instantiate_action(action_type, db_session)

biomapper/core/engine_components/action_executor.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/engine_components/action_loader.py:137: in instantiate_action
    action_class = self.load_action_class(action_type)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_loader.ActionLoader object at 0x7c202c14abd0>
action_type = 'CONVERT_IDENTIFIERS_LOCAL'

    def load_action_class(self, action_type: str) -> Type[StrategyAction]:
        """
        Load an action class by type or class path.
    
        Args:
            action_type: Either a registered action type (e.g., "CONVERT_IDENTIFIERS_LOCAL")
                        or a full class path (e.g., "biomapper.core.strategy_actions.load_endpoint_identifiers.LoadEndpointIdentifiersAction")
    
        Returns:
            The action class ready for instantiation
    
        Raises:
            ConfigurationError: If the action cannot be loaded
        """
        # First check if it's a registered action type
        if action_type in self.action_registry:
            logger.debug(f"Found action '{action_type}' in registry")
            return self.action_registry[action_type]
    
        # If not in registry, try to load it as a class path
        if '.' in action_type:
            logger.debug(f"Attempting to load action from class path: {action_type}")
            return self._load_from_class_path(action_type)
    
        # Neither registry nor class path
>       raise ConfigurationError(
            f"Unknown action type: '{action_type}'. "
            f"Action must be either registered in ACTION_REGISTRY or specified as a full class path."
        )
E       biomapper.core.exceptions.ConfigurationError: [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_loader.py:61: ConfigurationError

During handling of the above exception, another exception occurred:

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c202c14a010>
strategy_name = 'basic_linear_strategy', input_identifiers = ['TEST1', 'TEST2']
initial_context = None, source_endpoint_name = 'test_source'
target_endpoint_name = 'test_target', mapping_session_id = None
source_ontology_type = None, target_ontology_type = None, use_cache = False
max_cache_age_days = None, progress_callback = None, batch_size = 250
min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
>                   result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )

biomapper/core/engine_components/strategy_orchestrator.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.action_executor.ActionExecutor object at 0x7c202c14a0d0>
step = <MappingStrategyStep id=1 strategy=1 step=S1_CONVERT_TO_GENE order=1 action=CONVERT_IDENTIFIERS_LOCAL>
current_identifiers = ['TEST1', 'TEST2'], current_ontology_type = 'UNKNOWN'
source_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c29fa50>
target_endpoint = <biomapper.db.models.Endpoint object at 0x7c202c258410>
use_cache = False, max_cache_age_days = None, batch_size = 250
min_confidence = 0.0
strategy_context = {'all_provenance': [], 'batch_size': 250, 'cache_settings': {'max_cache_age_days': None, 'use_cache': False}, 'current_identifiers': ['TEST1', 'TEST2'], ...}
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x7c202c4ebf10>

    async def execute_action(
        self,
        step: MappingStrategyStep,
        current_identifiers: List[str],
        current_ontology_type: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        use_cache: bool,
        max_cache_age_days: Optional[int],
        batch_size: int,
        min_confidence: float,
        strategy_context: Dict[str, Any],
        db_session: AsyncSession,
    ) -> Dict[str, Any]:
        """
        Execute a single strategy action step.
    
        Args:
            step: The MappingStrategyStep containing action type and parameters
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            source_endpoint: Source endpoint configuration
            target_endpoint: Target endpoint configuration
            use_cache: Whether to use caching for this action
            max_cache_age_days: Maximum age for cached results
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold for results
            strategy_context: Shared context dictionary that persists across steps
            db_session: Active database session
    
        Returns:
            Dict[str, Any]: Action result containing:
                - output_identifiers: List of identifiers after processing
                - output_ontology_type: Ontology type after processing
                - Additional action-specific metadata and statistics
    
        Raises:
            MappingExecutionError: If the action execution fails
        """
        action_type = step.action_type
        action_params = step.action_parameters or {}
    
        # Process action parameters to handle context references
        processed_params = self._process_action_parameters(action_params, strategy_context)
    
        self.logger.info(f"Executing action type: {action_type} with params: {processed_params}")
    
        # Update strategy context with execution parameters
        self._update_context_for_execution(
            strategy_context,
            db_session,
            use_cache,
            max_cache_age_days,
            batch_size,
            min_confidence
        )
    
        self.logger.debug(f"Context before action: {list(strategy_context.keys())}")
    
        # Load and instantiate the action
        try:
            action = self.action_loader.instantiate_action(action_type, db_session)
        except Exception as e:
>           raise MappingExecutionError(
                f"Failed to load action '{action_type}': {str(e)}"
            )
E           biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/action_executor.py:99: MappingExecutionError

During handling of the above exception, another exception occurred:

self = <tests.integration.test_yaml_strategy_ukbb_hpa.TestUKBBToHPAYAMLStrategy object at 0x7c203fb5f0d0>
mapping_executor = <biomapper.core.mapping_executor.MappingExecutor object at 0x7c202c14a450>

    @pytest.mark.asyncio
    async def test_action_handlers_placeholder_behavior(self, mapping_executor):
        """Test that action handlers return expected placeholder results."""
        test_identifiers = ["TEST1", "TEST2"]
    
>       result = await mapping_executor.execute_yaml_strategy(
            strategy_name="basic_linear_strategy",
            source_endpoint_name="test_source",
            target_endpoint_name="test_target",
            input_identifiers=test_identifiers,
            use_cache=False
        )

tests/integration/test_yaml_strategy_ukbb_hpa.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
biomapper/core/mapping_executor.py:261: in execute_yaml_strategy
    return await self.strategy_coordinator.execute_yaml_strategy(
biomapper/core/engine_components/strategy_coordinator_service.py:148: in execute_yaml_strategy
    return await self.yaml_strategy_execution_service.execute(
biomapper/core/services/execution_services.py:625: in execute
    return await self.strategy_orchestrator.execute_strategy(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <biomapper.core.engine_components.strategy_orchestrator.StrategyOrchestrator object at 0x7c202c14a010>
strategy_name = 'basic_linear_strategy', input_identifiers = ['TEST1', 'TEST2']
initial_context = None, source_endpoint_name = 'test_source'
target_endpoint_name = 'test_target', mapping_session_id = None
source_ontology_type = None, target_ontology_type = None, use_cache = False
max_cache_age_days = None, progress_callback = None, batch_size = 250
min_confidence = 0.0

    async def execute_strategy(
        self,
        strategy_name: str,
        input_identifiers: List[str],
        initial_context: Optional[Dict[str, Any]] = None,
        source_endpoint_name: Optional[str] = None,
        target_endpoint_name: Optional[str] = None,
        mapping_session_id: Optional[int] = None,
        source_ontology_type: Optional[str] = None,
        target_ontology_type: Optional[str] = None,
        use_cache: bool = True,
        max_cache_age_days: Optional[int] = None,
        progress_callback: Optional[Callable] = None,
        batch_size: int = 250,
        min_confidence: float = 0.0,
    ) -> Dict[str, Any]:
        """
        Execute a YAML-defined mapping strategy.
    
        This method orchestrates the execution of a multi-step mapping strategy,
        delegating the actual execution of steps to the StrategyHandler while
        managing the overall flow and result collection.
    
        Args:
            strategy_name: Name of the strategy to execute
            input_identifiers: List of identifiers to map
            initial_context: Optional initial context values
            source_endpoint_name: Name of the source endpoint
            target_endpoint_name: Name of the target endpoint
            mapping_session_id: Optional session ID for tracking
            source_ontology_type: Optional override for source ontology type
            target_ontology_type: Optional override for target ontology type
            use_cache: Whether to use caching
            max_cache_age_days: Maximum cache age in days
            progress_callback: Optional callback function(current_step, total_steps, status)
            batch_size: Size of batches for processing
            min_confidence: Minimum confidence threshold
    
        Returns:
            Dict[str, Any]: A MappingResultBundle-structured dictionary containing:
                - 'results': Dict[str, Dict] mapping source IDs to their mapped values
                - 'metadata': Dict with execution metadata
                - 'step_results': List[Dict] with detailed results from each step
                - 'statistics': Dict with mapping statistics
                - 'final_identifiers': List of identifiers after all steps
                - 'final_ontology_type': Final ontology type after all conversions
                - 'summary': Dict with consolidated summary including strategy_name, total_mapped, and step_results
        """
        start_time = get_current_utc_time()
    
        async with self.metamapper_session_factory() as session:
            # Load the strategy
            strategy = await self.strategy_handler.load_strategy(session, strategy_name)
    
            # Load endpoints if names provided
            source_endpoint = None
            target_endpoint = None
    
            if source_endpoint_name:
                source_endpoint = await self.strategy_handler.get_endpoint_by_name(session, source_endpoint_name)
                if not source_endpoint:
                    raise ConfigurationError(f"Source endpoint '{source_endpoint_name}' not found")
    
            if target_endpoint_name:
                target_endpoint = await self.strategy_handler.get_endpoint_by_name(session, target_endpoint_name)
                if not target_endpoint:
                    raise ConfigurationError(f"Target endpoint '{target_endpoint_name}' not found")
    
            # Initialize tracking variables
            current_identifiers = input_identifiers.copy()
            current_ontology_type = source_ontology_type or strategy.default_source_ontology_type or "UNKNOWN"
            step_results = []
    
            # Initialize strategy context
            strategy_context = initial_context or {}
            strategy_context.update({
                'initial_identifiers': input_identifiers.copy(),
                'current_identifiers': current_identifiers.copy(),
                'current_ontology_type': current_ontology_type,
                'step_results': [],
                'all_provenance': [],
                'mapping_results': {},
                'progress_callback': progress_callback,
                'mapping_session_id': mapping_session_id,
                'strategy_name': strategy.name,
                'source_endpoint': source_endpoint.name if source_endpoint else None,
                'target_endpoint': target_endpoint.name if target_endpoint else None,
                'initial_count': len(input_identifiers),
                'mapping_executor': self.mapping_executor  # Add mapping executor to context
            })
    
            # Sort steps by order
            sorted_steps = sorted(strategy.steps, key=lambda s: s.step_order)
    
            # Execute each step
            for step_idx, step in enumerate(sorted_steps):
                if not step.is_active:
                    self.logger.info(f"Skipping inactive step: {step.step_id}")
                    continue
    
                # Call progress callback if provided
                if progress_callback:
                    progress_callback(step_idx, len(sorted_steps), f"Executing {step.step_id}")
    
                step_start_time = get_current_utc_time()
    
                try:
                    # Execute the action
                    result = await self.action_executor.execute_action(
                        step=step,
                        current_identifiers=current_identifiers,
                        current_ontology_type=current_ontology_type,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        use_cache=use_cache,
                        max_cache_age_days=max_cache_age_days,
                        batch_size=batch_size,
                        min_confidence=min_confidence,
                        strategy_context=strategy_context,
                        db_session=session
                    )
    
                    # Track step result
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "success",
                        "input_count": len(current_identifiers),
                        "output_count": len(result.get('output_identifiers', [])),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds(),
                        "details": result.get('details', {})
                    }
    
                    # Update current state
                    current_identifiers = result.get('output_identifiers', [])
                    current_ontology_type = result.get('output_ontology_type', current_ontology_type)
    
                    # Update context with current state
                    strategy_context['current_identifiers'] = current_identifiers
                    strategy_context['current_ontology_type'] = current_ontology_type
    
                    # Accumulate provenance if present
                    if 'provenance' in result:
                        strategy_context['all_provenance'].extend(result['provenance'])
    
                except Exception as e:
                    self.logger.error(f"Step {step.step_id} failed: {str(e)}")
    
                    step_result = {
                        "step_id": step.step_id,
                        "description": step.description,
                        "action_type": step.action_type,
                        "status": "failed",
                        "error": str(e),
                        "duration_seconds": (get_current_utc_time() - step_start_time).total_seconds()
                    }
    
                    # Check if step is required
                    if step.is_required:
>                       raise MappingExecutionError(
                            f"Required step '{step.step_id}' failed: {str(e)}"
                        )
E                       biomapper.core.exceptions.MappingExecutionError: [MAPPING_EXECUTION_ERROR] Required step 'S1_CONVERT_TO_GENE' failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.

biomapper/core/engine_components/strategy_orchestrator.py:233: MappingExecutionError
---------------------------- Captured stdout setup -----------------------------
Loading test config from: /home/trentleslie/github/biomapper/tests/integration/data/test_protein_strategy_config.yaml
------------------------------ Captured log setup ------------------------------
WARNING  langfuse:client.py:259 Langfuse client is disabled since no public_key was provided as a parameter or environment variable 'LANGFUSE_PUBLIC_KEY'. See our docs: https://langfuse.com/docs/sdk/python/low-level-sdk#initialize-client
WARNING  langfuse:client.py:259 Langfuse client is disabled since no public_key was provided as a parameter or environment variable 'LANGFUSE_PUBLIC_KEY'. See our docs: https://langfuse.com/docs/sdk/python/low-level-sdk#initialize-client
------------------------------ Captured log call -------------------------------
ERROR    biomapper.core.engine_components.initialization_service:strategy_orchestrator.py:220 Step S1_CONVERT_TO_GENE failed: [MAPPING_EXECUTION_ERROR] Failed to load action 'CONVERT_IDENTIFIERS_LOCAL': [CONFIGURATION_ERROR] Unknown action type: 'CONVERT_IDENTIFIERS_LOCAL'. Action must be either registered in ACTION_REGISTRY or specified as a full class path.
______________ TestApiResolver.test_execute_with_retry_on_errors _______________

self = <test_api_resolver.TestApiResolver object at 0x7c203d371bd0>
api_resolver = <biomapper.core.strategy_actions.api_resolver.ApiResolver object at 0x7c1e564d5f50>
mock_endpoints = (<MagicMock spec='Endpoint' id='136469738774544'>, <MagicMock spec='Endpoint' id='136469738772624'>)

    @pytest.mark.asyncio
    async def test_execute_with_retry_on_errors(self, api_resolver, mock_endpoints):
        """Test retry logic on transient errors."""
        source, target = mock_endpoints
    
        action_params = {
            'input_context_key': 'ids',
            'output_context_key': 'resolved',
            'api_base_url': 'https://api.example.com',
            'endpoint_path': '/resolve/{id}',
            'max_retries': 3,
            'timeout': 1
        }
    
        context = {'ids': ['RETRY1']}
    
        mock_session = AsyncMock(spec=aiohttp.ClientSession)
    
        # Track get calls
        call_count = 0
    
        async def side_effect(*args, **kwargs):
            nonlocal call_count
            call_count += 1
            if call_count < 3:
                return create_mock_response(500)
            return create_mock_response(200, {'id': 'SUCCESS1'})
    
        mock_session.get.side_effect = side_effect
    
        with patch.object(api_resolver, '_get_session', return_value=mock_session):
            result = await api_resolver.execute(
                current_identifiers=['RETRY1'],
                current_ontology_type='UNIPROT',
                action_params=action_params,
                source_endpoint=source,
                target_endpoint=target,
                context=context
            )
    
>       assert result['output_identifiers'] == ['SUCCESS1']
E       AssertionError: assert [] == ['SUCCESS1']
E         Right contains one more item: 'SUCCESS1'
E         Full diff:
E         - ['SUCCESS1']
E         + []

tests/unit/strategy_actions/test_api_resolver.py:242: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    biomapper.core.strategy_actions.api_resolver:api_resolver.py:297 Exception resolving RETRY1: 'coroutine' object does not support the asynchronous context manager protocol
=============================== warnings summary ===============================
tests/cache/test_manager.py::CacheManagerTest::test_add_mapping
tests/cache/test_manager.py::CacheManagerTest::test_add_mapping_with_metadata
tests/cache/test_manager.py::CacheManagerTest::test_bidirectional_lookup
tests/cache/test_manager.py::CacheManagerTest::test_cache_stats
tests/cache/test_manager.py::CacheManagerTest::test_delete_expired_mappings
tests/cache/test_manager.py::CacheManagerTest::test_lookup
  /home/trentleslie/github/biomapper/biomapper/db/session.py:144: RuntimeWarning: coroutine 'AsyncEngine.dispose' was never awaited
    self.async_engine.dispose()
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/core/services/test_metadata_query_service.py::TestMetadataQueryService::test_sql_query_construction
  /home/trentleslie/github/biomapper/tests/core/services/test_metadata_query_service.py:302: RuntimeWarning: coroutine 'AsyncMockMixin._execute_mock_call' was never awaited
    await service.get_ontology_type(mock_session, "test_endpoint", "test_property")
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/strategy_actions/test_api_resolver.py::TestApiResolver::test_execute_with_retry_on_errors
  /home/trentleslie/github/biomapper/biomapper/core/strategy_actions/api_resolver.py:224: RuntimeWarning: coroutine 'TestApiResolver.test_execute_with_retry_on_errors.<locals>.side_effect' was never awaited
    async with session.get(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/core/test_mapping_executor_handlers.py::test_handle_convert_identifiers_local_success
FAILED tests/integration/test_strategy_execution.py::test_ukbb_hpa_overlap_strategy
FAILED tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_basic_linear_strategy
FAILED tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_mixed_action_strategy
FAILED tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_empty_initial_identifiers
FAILED tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_ontology_type_tracking
FAILED tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_all_optional_strategy
FAILED tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_mixed_required_optional_strategy
FAILED tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_optional_fail_first_strategy
FAILED tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_optional_fail_last_strategy
FAILED tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_multiple_optional_failures_strategy
FAILED tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_required_fail_after_optional_strategy
FAILED tests/integration/test_yaml_strategy_execution.py::TestYAMLStrategyExecution::test_mapping_result_bundle_tracking
FAILED tests/integration/test_yaml_strategy_ukbb_hpa.py::TestUKBBToHPAYAMLStrategy::test_execute_yaml_strategy_basic
FAILED tests/integration/test_yaml_strategy_ukbb_hpa.py::TestUKBBToHPAYAMLStrategy::test_execute_yaml_strategy_with_progress_callback
FAILED tests/integration/test_yaml_strategy_ukbb_hpa.py::TestUKBBToHPAYAMLStrategy::test_action_handlers_placeholder_behavior
FAILED tests/unit/strategy_actions/test_api_resolver.py::TestApiResolver::test_execute_with_retry_on_errors
===== 17 failed, 1093 passed, 26 skipped, 8 warnings in 196.01s (0:03:16) ======

Running cache tests separately...
Running test_cached_mapper.py...
============================= test session starts ==============================
platform linux -- Python 3.11.7, pytest-7.4.4, pluggy-1.5.0 -- /home/trentleslie/.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/bin/python
rootdir: /home/trentleslie/github/biomapper
configfile: pytest.ini
plugins: mock-3.14.0, anyio-4.8.0, asyncio-0.21.2, requests-mock-1.12.1, cov-4.1.0
asyncio: mode=Mode.AUTO
collecting ... collected 4 items

tests/cache/test_cached_mapper.py::CachedMapperTest::test_batch_map_mixed_hits PASSED [ 25%]
tests/cache/test_cached_mapper.py::CachedMapperTest::test_map_entity_cache_hit PASSED [ 50%]
tests/cache/test_cached_mapper.py::CachedMapperTest::test_map_entity_cache_miss PASSED [ 75%]
tests/cache/test_cached_mapper.py::CachedMapperTest::test_skip_cache PASSED [100%]

=============================== warnings summary ===============================
tests/cache/test_cached_mapper.py::CachedMapperTest::test_batch_map_mixed_hits
tests/cache/test_cached_mapper.py::CachedMapperTest::test_map_entity_cache_hit
tests/cache/test_cached_mapper.py::CachedMapperTest::test_map_entity_cache_miss
tests/cache/test_cached_mapper.py::CachedMapperTest::test_skip_cache
  /home/trentleslie/github/biomapper/biomapper/db/session.py:144: RuntimeWarning: coroutine 'AsyncEngine.dispose' was never awaited
    self.async_engine.dispose()
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
======================== 4 passed, 4 warnings in 3.63s =========================
Running test_cache_results_implementation.py...
============================= test session starts ==============================
platform linux -- Python 3.11.7, pytest-7.4.4, pluggy-1.5.0 -- /home/trentleslie/.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/bin/python
rootdir: /home/trentleslie/github/biomapper
configfile: pytest.ini
plugins: mock-3.14.0, anyio-4.8.0, asyncio-0.21.2, requests-mock-1.12.1, cov-4.1.0
asyncio: mode=Mode.AUTO
collecting ... collected 1 item

tests/core/test_cache_results_implementation.py::test_cache_results PASSED [100%]

============================== 1 passed in 0.03s ===============================
Running test_cache_manager.py...
============================= test session starts ==============================
platform linux -- Python 3.11.7, pytest-7.4.4, pluggy-1.5.0 -- /home/trentleslie/.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/bin/python
rootdir: /home/trentleslie/github/biomapper
configfile: pytest.ini
plugins: mock-3.14.0, anyio-4.8.0, asyncio-0.21.2, requests-mock-1.12.1, cov-4.1.0
asyncio: mode=Mode.AUTO
collecting ... collected 29 items

tests/unit/core/engine_components/test_cache_manager.py::test_store_mapping_results_with_metadata FAILED [  3%]
tests/unit/core/engine_components/test_cache_manager.py::test_calculate_confidence_score PASSED [  6%]
tests/unit/core/engine_components/test_cache_manager.py::test_determine_mapping_source PASSED [ 10%]
tests/unit/core/engine_components/test_cache_manager.py::test_check_cache_with_results FAILED [ 13%]
tests/unit/core/engine_components/test_cache_manager.py::test_check_cache_with_path_id_filter FAILED [ 17%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerCheckCache::test_check_cache_empty_identifiers PASSED [ 20%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerCheckCache::test_check_cache_no_results PASSED [ 24%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerCheckCache::test_check_cache_with_cached_results PASSED [ 27%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerCheckCache::test_check_cache_with_path_id_filter PASSED [ 31%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerCheckCache::test_check_cache_with_expiry_time PASSED [ 34%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerCheckCache::test_check_cache_database_error PASSED [ 37%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerCheckCache::test_check_cache_single_target_identifier PASSED [ 41%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerStoreResults::test_store_mapping_results_empty PASSED [ 44%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerStoreResults::test_store_mapping_results_success PASSED [ 48%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerStoreResults::test_store_mapping_results_with_reverse_path PASSED [ 51%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerStoreResults::test_store_mapping_results_no_valid_targets PASSED [ 55%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerStoreResults::test_store_mapping_results_integrity_error PASSED [ 58%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerStoreResults::test_store_mapping_results_database_error PASSED [ 62%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerHelperMethods::test_create_path_execution_log_success PASSED [ 65%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerHelperMethods::test_create_path_execution_log_error PASSED [ 68%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerHelperMethods::test_calculate_confidence_score_with_existing_score PASSED [ 72%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerHelperMethods::test_calculate_confidence_score_by_hop_count PASSED [ 75%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerHelperMethods::test_calculate_confidence_score_with_reverse_penalty PASSED [ 79%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerHelperMethods::test_calculate_confidence_score_with_resource_penalties PASSED [ 82%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerHelperMethods::test_determine_mapping_source PASSED [ 86%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerHelperMethods::test_create_mapping_path_details PASSED [ 89%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerEdgeCases::test_check_cache_empty_results PASSED [ 93%]
tests/unit/core/engine_components/test_cache_manager.py::TestCacheManagerEdgeCases::test_store_mapping_results_non_list_targets test_cache_manager.py failed or timed out
Running test_mapping_executor_cache.py.skip...
============================= test session starts ==============================
platform linux -- Python 3.11.7, pytest-7.4.4, pluggy-1.5.0 -- /home/trentleslie/.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/bin/python
rootdir: /home/trentleslie/github/biomapper
configfile: pytest.ini
plugins: mock-3.14.0, anyio-4.8.0, asyncio-0.21.2, requests-mock-1.12.1, cov-4.1.0
asyncio: mode=Mode.AUTO
collecting ... ERROR: found no collectors for /home/trentleslie/github/biomapper/tests/core/test_mapping_executor_cache.py.skip

collected 0 items

============================ no tests ran in 0.00s =============================
test_mapping_executor_cache.py failed or timed out

Running test_mapping_executor.py separately with resource limits...
============================= test session starts ==============================
platform linux -- Python 3.11.7, pytest-7.4.4, pluggy-1.5.0 -- /home/trentleslie/.cache/pypoetry/virtualenvs/biomapper-2G1u2EyD-py3.11/bin/python
rootdir: /home/trentleslie/github/biomapper
configfile: pytest.ini
plugins: mock-3.14.0, anyio-4.8.0, asyncio-0.21.2, requests-mock-1.12.1, cov-4.1.0
asyncio: mode=Mode.AUTO
collecting ... collected 31 items

tests/core/test_mapping_executor.py::test_path_finder_find_mapping_paths SKIPPED [  3%]
tests/core/test_mapping_executor.py::test_execute_mapping_success SKIPPED [  6%]
tests/core/test_mapping_executor.py::test_execute_mapping_no_path_found SKIPPED [  9%]
tests/core/test_mapping_executor.py::test_execute_mapping_client_error SKIPPED [ 12%]
tests/core/test_mapping_executor.py::test_execute_mapping_partial_results SKIPPED [ 16%]
tests/core/test_mapping_executor.py::test_execute_mapping_empty_input SKIPPED [ 19%]
tests/core/test_mapping_executor.py::test_load_client_import_error SKIPPED [ 22%]
tests/core/test_mapping_executor.py::test_load_client_json_decode_error SKIPPED [ 25%]
tests/core/test_mapping_executor.py::test_load_client_initialization_exception SKIPPED [ 29%]
tests/core/test_mapping_executor.py::test_check_cache_sqlalchemy_error SKIPPED [ 32%]
tests/core/test_mapping_executor.py::test_check_cache_unexpected_error SKIPPED [ 35%]
tests/core/test_mapping_executor.py::test_cache_results_db_error_during_commit SKIPPED [ 38%]
tests/core/test_mapping_executor.py::test_cache_results_general_exception SKIPPED [ 41%]
tests/core/test_mapping_executor.py::test_execute_mapping_caches_metadata SKIPPED [ 45%]
tests/core/test_mapping_executor.py::test_calculate_confidence_score SKIPPED [ 48%]
tests/core/test_mapping_executor.py::test_create_mapping_path_details SKIPPED [ 51%]
tests/core/test_mapping_executor.py::test_determine_mapping_source SKIPPED [ 54%]
tests/core/test_mapping_executor.py::test_run_path_steps_basic SKIPPED   [ 58%]
tests/core/test_mapping_executor.py::test_run_path_steps_multi_step SKIPPED [ 61%]
tests/core/test_mapping_executor.py::test_run_path_steps_one_to_many SKIPPED [ 64%]
tests/core/test_mapping_executor.py::test_run_path_steps_error_handling SKIPPED [ 67%]
tests/core/test_mapping_executor.py::test_execute_path_integration SKIPPED [ 70%]
tests/core/test_mapping_executor.py::test_execute_path_error_handling SKIPPED [ 74%]
tests/core/test_mapping_executor.py::test_handle_convert_identifiers_local_success SKIPPED [ 77%]
tests/core/test_mapping_executor.py::test_handle_convert_identifiers_local_fallback SKIPPED [ 80%]
tests/core/test_mapping_executor.py::test_handle_convert_identifiers_local_missing_output_type SKIPPED [ 83%]
tests/core/test_mapping_executor.py::test_handle_execute_mapping_path_success SKIPPED [ 87%]
tests/core/test_mapping_executor.py::test_handle_execute_mapping_path_fallback SKIPPED [ 90%]
tests/core/test_mapping_executor.py::test_handle_execute_mapping_path_missing_path SKIPPED [ 93%]
tests/core/test_mapping_executor.py::test_handle_filter_identifiers_by_target_presence_success SKIPPED [ 96%]
tests/core/test_mapping_executor.py::test_handle_filter_identifiers_by_target_presence_fallback SKIPPED [100%]

============================= 31 skipped in 1.54s ==============================

Test run complete!
