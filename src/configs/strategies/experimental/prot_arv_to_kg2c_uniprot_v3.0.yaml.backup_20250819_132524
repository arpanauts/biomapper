name: prot_arv_to_kg2c_uniprot_v3.0
description: 'Progressive protein mapping from Arivale to KG2C with comprehensive analysis.
  Features staged waterfall mapping (direct → composite → historical), standardized
  output format, LLM-powered analysis, and advanced visualizations with TSV statistics export.
  
  Key Improvements:
  - Progressive mapping with stage-by-stage tracking
  - Composite identifier preservation with match_type tracking
  - Standardized mapping results for universal compatibility
  - LLM analysis with mermaid flowchart generation
  - Waterfall visualizations showing cumulative improvement
  - Direct SVG/PNG export with TSV statistics
  '
parameters:
  # Input/Output paths
  source_file: /procedure/data/local_data/ARIVALE_SNAPSHOTS/proteomics_metadata.tsv
  target_file: /procedure/data/local_data/MAPPING_ONTOLOGIES/kg2.10.2c_ontologies/kg2c_proteins.csv
  output_dir: /tmp/biomapper/protein_mapping_v3.0_progressive
  
  # Progressive mapping configuration
  enable_progressive_tracking: true
  track_match_types: true  # Track direct, composite, historical
  
  # Column specifications
  arivale_id_column: uniprot
  kg2c_id_column: id
  kg2c_name_column: name
  kg2c_category_column: category
  
  # Visualization and analysis
  enable_visualizations: true
  enable_llm_analysis: true
  llm_provider: anthropic  # Using Claude for analysis
  llm_model: claude-3-opus-20240229  # or claude-3-sonnet-20240229 for faster/cheaper
  enable_google_drive_sync: true
  drive_folder_id: 1oQ7CczccH2a6oYYFMo_sf8fXtxF8au_D

steps:
  # ============================================
  # STAGE 0: Data Loading
  # ============================================
  - name: load_arivale_proteins
    action:
      type: LOAD_DATASET_IDENTIFIERS
      params:
        file_path: ${parameters.source_file}
        identifier_column: ${parameters.arivale_id_column}
        output_key: arivale_raw
        
  - name: load_kg2c_entities
    action:
      type: LOAD_DATASET_IDENTIFIERS
      params:
        file_path: ${parameters.target_file}
        identifier_column: ${parameters.kg2c_id_column}
        output_key: kg2c_raw
        delimiter: ','
        
  # ============================================
  # STAGE 1: Direct Matching (65% expected)
  # ============================================
  - name: initialize_progressive_stats
    action:
      type: CUSTOM_TRANSFORM
      params:
        input_key: arivale_raw
        output_key: arivale_proteins  # Keep original and create new dataset
        transformations:
          - column: uniprot
            expression: 'value'  # Just copy the column as-is
          
  - name: extract_uniprot_from_kg2c
    action:
      type: PROTEIN_EXTRACT_UNIPROT_FROM_XREFS
      params:
        input_key: kg2c_raw
        xrefs_column: xrefs
        output_key: kg2c_with_uniprot
        output_column: extracted_uniprot
        handle_multiple: expand_rows
        keep_isoforms: false
        drop_na: true
        
  # Skip early composite parsing - we want to match single IDs first
  - name: normalize_arivale_accessions
    action:
      type: PROTEIN_NORMALIZE_ACCESSIONS
      params:
        input_key: arivale_proteins  # Use raw proteins, not parsed
        id_columns:
          - ${parameters.arivale_id_column}
        output_key: arivale_normalized
        
  - name: normalize_kg2c_accessions
    action:
      type: PROTEIN_NORMALIZE_ACCESSIONS
      params:
        input_key: kg2c_with_uniprot
        id_columns:
          - extracted_uniprot
        output_key: kg2c_normalized
        
  - name: direct_uniprot_match
    action:
      type: MERGE_DATASETS
      params:
        input_key: arivale_normalized
        dataset2_key: kg2c_normalized
        join_columns:
          arivale_normalized: uniprot
          kg2c_normalized: extracted_uniprot_normalized
        join_type: inner
        output_key: direct_match
        
  - name: tag_direct_matches
    action:
      type: CUSTOM_TRANSFORM
      params:
        input_key: direct_match
        output_key: direct_match_tagged
        transformations:
          - column: confidence_score
            expression: 'float(1.0)'
          - column: match_type
            expression: '"direct"'
          - column: mapping_stage
            expression: 'int(1)'
          
  - name: track_stage1_stats
    action:
      type: TRACK_PROGRESSIVE_STATS
      params:
        input_key: direct_match_tagged
        stage_id: 1
        stage_name: 'Direct UniProt Matching'
        method: 'Exact UniProt accession match'
        track_unique_entities: true
        entity_id_column: uniprot
        entity_type: protein
        track_confidence: true
          
  # ============================================
  # STAGE 2: Composite Identifier Parsing
  # ============================================
  - name: identify_unmatched_after_direct
    action:
      type: FILTER_UNMATCHED
      params:
        all_entities_key: arivale_normalized
        matched_entities_key: direct_match_tagged
        entity_id_column: uniprot
        output_key: unmatched_after_direct
        
  - name: parse_composite_identifiers
    action:
      type: PARSE_COMPOSITE_IDENTIFIERS
      params:
        input_key: unmatched_after_direct  # CRITICAL: Use filtered dataset, not all proteins!
        id_field: ${parameters.arivale_id_column}
        patterns:
          - separator: ','
          - separator: ';'
          - separator: '|'
        output_key: composite_parsed
        output_format: flat
        preserve_original: true  # Keep original composite values
        
  - name: normalize_composite_parsed
    action:
      type: PROTEIN_NORMALIZE_ACCESSIONS
      params:
        input_key: composite_parsed
        id_columns:
          - ${parameters.arivale_id_column}
        output_key: composite_parsed_normalized
        
  - name: debug_composite_values
    action:
      type: CUSTOM_TRANSFORM
      params:
        input_key: composite_parsed_normalized
        output_key: composite_parsed_debug
        transformations:
          - column: debug_info
            expression: 'f"Parsed {len(df)} rows with {df[\"uniprot\"].nunique()} unique IDs"'
          - column: sample_parsed_ids
            expression: 'df["uniprot"].unique()[:10].tolist() if len(df) > 0 else []'
          - column: has_composites
            expression: 'any("," in str(x) for x in df["uniprot"].unique())'
          - column: individual_components
            expression: '[x for x in df["uniprot"].unique() if "," not in str(x)][:20]'
        
  - name: match_composite_identifiers
    action:
      type: MERGE_DATASETS
      params:
        input_key: composite_parsed_normalized
        dataset2_key: kg2c_normalized
        join_columns:
          composite_parsed_normalized: uniprot  # Column keeps same name after parsing
          kg2c_normalized: extracted_uniprot_normalized  # Use normalized column name
        join_type: inner  # Use INNER join to only keep matches
        output_key: composite_match
        
  - name: analyze_unmatched_composites
    action:
      type: CUSTOM_TRANSFORM
      params:
        input_key: composite_match
        output_key: composite_match_analysis
        transformations:
          - column: is_matched
            expression: 'df["extracted_uniprot_normalized"].notna()'
          - column: unmatched_count
            expression: 'len(df[df["extracted_uniprot_normalized"].isna()])'
          - column: unmatched_ids
            expression: 'df[df["extracted_uniprot_normalized"].isna()]["uniprot"].unique().tolist() if any(df["extracted_uniprot_normalized"].isna()) else []'
          - column: matched_count
            expression: 'len(df[df["extracted_uniprot_normalized"].notna()])'
          - column: sample_matched
            expression: 'df[df["extracted_uniprot_normalized"].notna()]["uniprot"].head(5).tolist() if any(df["extracted_uniprot_normalized"].notna()) else []'
        
  # Skip filter_matched_composites since we're using INNER join
  # The composite_match dataset already contains only matched records
        
  - name: restore_and_tag_composite_matches
    action:
      type: CUSTOM_TRANSFORM
      params:
        input_key: composite_match  # Use composite_match directly since it's already filtered
        output_key: composite_match_tagged
        transformations:
          # Restore original composite ID if it exists
          - column: uniprot
            expression: 'df["_original_uniprot"] if "_original_uniprot" in df.columns else df["uniprot"]'
          - column: confidence_score
            expression: 'float(0.95)'
          - column: match_type
            expression: '"composite"'
          - column: mapping_stage
            expression: 'int(2)'
          
  - name: track_stage2_stats
    action:
      type: TRACK_PROGRESSIVE_STATS
      params:
        input_key: composite_match_tagged
        stage_id: 2
        stage_name: 'Composite Identifier Parsing'
        method: 'Parse comma/semicolon separated IDs'
        previous_stages_key: direct_match_tagged
        track_unique_entities: true
        entity_id_column: uniprot
        entity_type: protein
        track_confidence: true
          
  # ============================================
  # STAGE 3: Historical Resolution (Resolves 3 proteins)
  # ============================================
  - name: identify_unmatched_after_composite
    action:
      type: FILTER_UNMATCHED
      params:
        all_entities_key: arivale_normalized
        matched_entities_key: composite_match_tagged
        entity_id_column: uniprot
        output_key: unmatched_after_composite
        
  - name: resolve_historical_uniprot
    action:
      type: PROTEIN_HISTORICAL_RESOLUTION
      params:
        input_key: unmatched_after_composite
        output_key: historical_resolved
        id_column: uniprot
        confidence_scores:
          primary: 1.0
          secondary: 0.90
          demerged: 0.85
          obsolete: 0.0
        debug_mode: true  # Enable for development
        add_resolution_log: true
        
  - name: filter_successful_historical
    action:
      type: CUSTOM_TRANSFORM
      params:
        input_key: historical_resolved
        output_key: historical_matches
        transformations:
          - column: is_resolved
            expression: 'df["match_type"] == "historical" if "match_type" in df.columns else False'
          
  - name: track_stage3_stats
    action:
      type: TRACK_PROGRESSIVE_STATS
      params:
        input_key: historical_matches
        stage_id: 3
        stage_name: 'Historical UniProt Resolution'
        method: 'UniProt API historical/secondary/demerged resolution'
        previous_stages_key: composite_match_tagged
        track_unique_entities: true
        entity_id_column: uniprot
        entity_type: protein
        track_confidence: true
          
  # ============================================
  # Result Consolidation
  # ============================================
  - name: merge_all_matches
    action:
      type: MERGE_DATASETS
      params:
        dataset_keys:
          - direct_match_tagged
          - composite_match_tagged
          - historical_matches
        merge_type: concat
        deduplicate: true
        output_key: all_matches
        
  - name: identify_final_unmapped
    action:
      type: FILTER_UNMATCHED
      params:
        all_entities_key: arivale_normalized
        matched_entities_key: all_matches
        entity_id_column: uniprot
        output_key: unmapped_proteins
        
  - name: tag_unmapped
    action:
      type: CUSTOM_TRANSFORM
      params:
        input_key: unmapped_proteins
        output_key: unmapped_tagged
        transformations:
          - column: confidence_score
            expression: 'float(0.0)'
          - column: match_type
            expression: '"unmapped"'
          - column: mapping_stage
            expression: 'int(99)'
          - column: kg2c_match
            expression: 'None'
            
  - name: merge_final_results
    action:
      type: MERGE_DATASETS
      params:
        dataset_keys:
          - all_matches  # Use the merged direct+composite matches
          - unmapped_tagged
        merge_type: concat
        deduplicate: true  # Remove duplicates - critical fix!
        output_key: final_merged
        
  - name: track_final_stats
    action:
      type: TRACK_PROGRESSIVE_STATS
      params:
        input_key: final_merged
        stage_id: 4
        stage_name: 'Final Consolidated Results'
        method: 'All stages combined'
        previous_stages_key: historical_matches
        track_unique_entities: true
        entity_id_column: uniprot
        entity_type: protein
        track_confidence: true
        
  - name: finalize_progressive_stats
    action:
      type: CUSTOM_TRANSFORM
      params:
        input_key: final_merged
        output_key: final_with_stats
        transformations:
          - column: final_status
            expression: '"complete"'
          - column: unique_protein_id
            expression: 'df["uniprot"].apply(lambda x: x.split("_")[0] if "_" in str(x) else x)'  # Extract base protein ID
          
  # ============================================
  # Analysis and Visualization
  # ============================================
  - name: generate_visualizations_and_stats
    action:
      type: GENERATE_MAPPING_VISUALIZATIONS
      params:
        input_key: final_merged
        output_dir: ${parameters.output_dir}
        generate_statistics: true
        generate_summary: true
        generate_json_report: true
        prefix: ""
        
  - name: generate_llm_analysis
    action:
      type: GENERATE_LLM_ANALYSIS
      params:
        provider: ${parameters.llm_provider}
        model: ${parameters.llm_model}
        output_directory: ${parameters.output_dir}
        progressive_stats_key: progressive_stats
        mapping_results_key: final_merged
        strategy_name: ${name}
        entity_type: protein
        output_format:
          - summary
          - flowchart
          - recommendations
        include_recommendations: true
        analysis_focus:
          - coverage_analysis
          - confidence_distribution
          - unmapped_patterns
          - progressive_improvement
        
  # ============================================
  # Export and Sync
  # ============================================
  - name: export_all_results
    action:
      type: EXPORT_DATASET
      params:
        input_key: final_merged
        output_path: ${parameters.output_dir}/all_mappings_v3.0.tsv
        format: tsv
        
  - name: sync_to_google_drive
    action:
      type: SYNC_TO_GOOGLE_DRIVE_V2
      params:
        drive_folder_id: 1oQ7CczccH2a6oYYFMo_sf8fXtxF8au_D
        credentials_path: /home/ubuntu/biomapper/google-credentials.json
        auto_organize: true
        strategy_name: prot_arv_to_kg2c_uniprot_v3.0
        strategy_version: '3.0'
        create_subfolder: true
        subfolder_name: v3.0_production_full
        sync_context_outputs: true
        local_directory: ${parameters.output_dir}  # Also scan local directory
        include_patterns:  # Include all generated files
          - '*.tsv'
          - '*.json'
          - '*.txt'
          - '*.csv'
          - '*.md'
          - '*.png'
          - '*.svg'
  #         - '*.html'
  #       description: 'Production run with full statistics and visualizations'
          
metadata:
  version: '3.0'
  created_date: '2025-01-15'
  architecture: 'Progressive Waterfall Mapping'
  features:
    - 'Staged progressive mapping (direct → composite → historical)'
    - 'Standardized output format with match_type tracking'
    - 'Composite identifier preservation'
    - 'LLM-powered analysis and flowchart generation'
    - 'Progressive waterfall visualizations'
    - 'Direct SVG/PNG export with TSV statistics'
    - 'Google Drive integration'
  expected_performance:
    stage_1_direct: '99.31% (1154/1162 proteins)'
    stage_2_composite: '0.34% additional (99.65% cumulative, 4 composite IDs)'
    stage_3_historical: '0.26% additional (99.91% cumulative, 3 proteins resolved)'
    final_unmapped: '0.09% (1 invalid ID: NT-PROBNP)'
  authors:
    - 'biomapper-team'
    - 'progressive-mapping-framework'
    - 'parallel-development-integration'