"""
Template for new action type implementation.

Copy this file and replace:
- TemplateAction → YourActionName
- TEMPLATE_ACTION → YOUR_ACTION_TYPE
- Update docstrings and implementation
"""

import logging
from typing import Dict, Any, List, Optional
from collections import defaultdict
from datetime import datetime

from .base import BaseStrategyAction
from biomapper.db.models import Endpoint

logger = logging.getLogger(__name__)


class TemplateAction(BaseStrategyAction):
    """
    Brief description of what this action does.
    
    This action:
    - Key capability 1
    - Key capability 2  
    - Handles composite identifiers by default
    - Supports many-to-many mappings
    
    Parameters:
        required_param (str): Description of required parameter
        optional_param (str): Description of optional parameter (default: 'default_value')
        composite_handling (str): How to handle composite IDs (default: 'split_and_match')
        match_mode (str): Matching mode - 'many_to_many' or 'one_to_one' (default: 'many_to_many')
    """
    
    def __init__(self, session):
        """Initialize with database session."""
        self.session = session
        
    async def execute(
        self,
        current_identifiers: List[str],
        current_ontology_type: str,
        action_params: Dict[str, Any],
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Execute the action.
        
        Args:
            current_identifiers: List of identifiers to process
            current_ontology_type: Current ontology type of the identifiers
            action_params: Parameters specific to this action
            source_endpoint: Source endpoint object
            target_endpoint: Target endpoint object
            context: Shared execution context
            
        Returns:
            Dictionary containing:
                - input_identifiers: List of input identifiers
                - output_identifiers: List of output identifiers
                - output_ontology_type: Ontology type of output
                - provenance: List of provenance records
                - details: Additional execution details
                
        Raises:
            ValueError: If required parameters are missing
            RuntimeError: If action execution fails
        """
        # Early exit for empty input
        if not current_identifiers:
            return self._empty_result()
            
        # Validate required parameters
        required_param = action_params.get('required_param')
        if not required_param:
            raise ValueError("required_param is required")
            
        # Extract optional parameters with defaults
        optional_param = action_params.get('optional_param', 'default_value')
        composite_handling = action_params.get('composite_handling', 'split_and_match')
        match_mode = action_params.get('match_mode', 'many_to_many')
        
        # Log action start
        logger.info(
            f"Executing TEMPLATE_ACTION with {len(current_identifiers)} identifiers, "
            f"mode: {match_mode}, composite handling: {composite_handling}"
        )
        logger.debug(f"Action parameters: {action_params}")
        logger.debug(f"First 5 identifiers: {current_identifiers[:5]}")
        
        # Initialize tracking
        output_identifiers = []
        provenance_records = []
        processed_count = 0
        failed_count = 0
        
        try:
            # Step 1: Handle composite identifiers if needed
            working_identifiers = current_identifiers
            if composite_handling != 'none':
                working_identifiers = self._handle_composites(
                    current_identifiers, 
                    composite_handling
                )
                logger.debug(
                    f"Expanded {len(current_identifiers)} identifiers to "
                    f"{len(working_identifiers)} after composite handling"
                )
            
            # Step 2: Main processing logic
            # TODO: Implement your main logic here
            # This is where you'd do the actual work of the action
            
            # Example: Simple pass-through (replace with real logic)
            for identifier in working_identifiers:
                try:
                    # Process individual identifier
                    result = await self._process_identifier(
                        identifier=identifier,
                        source_endpoint=source_endpoint,
                        target_endpoint=target_endpoint,
                        params=action_params
                    )
                    
                    if result:
                        output_identifiers.extend(result['outputs'])
                        provenance_records.extend(result['provenance'])
                        processed_count += 1
                    else:
                        failed_count += 1
                        
                except Exception as e:
                    logger.warning(f"Failed to process identifier {identifier}: {e}")
                    failed_count += 1
                    
            # Step 3: Update context if requested
            if save_to := action_params.get('save_results_to'):
                context[save_to] = output_identifiers
                logger.debug(f"Saved {len(output_identifiers)} results to context['{save_to}']")
                
            # Step 4: Build final result
            logger.info(
                f"TEMPLATE_ACTION completed: processed {processed_count}, "
                f"failed {failed_count}, output {len(output_identifiers)} identifiers"
            )
            
            return {
                'input_identifiers': current_identifiers,
                'output_identifiers': output_identifiers,
                'output_ontology_type': current_ontology_type,  # Change if ontology changes
                'provenance': provenance_records,
                'details': {
                    'action': 'TEMPLATE_ACTION',
                    'total_input': len(current_identifiers),
                    'total_processed': processed_count,
                    'total_failed': failed_count,
                    'total_output': len(output_identifiers),
                    'parameters': action_params,
                    'composite_handling': composite_handling,
                    'match_mode': match_mode
                }
            }
            
        except Exception as e:
            logger.error(f"TEMPLATE_ACTION failed: {e}", exc_info=True)
            raise RuntimeError(f"Action execution failed: {e}") from e
            
    def _empty_result(self) -> Dict[str, Any]:
        """Return empty result for early exit."""
        return {
            'input_identifiers': [],
            'output_identifiers': [],
            'output_ontology_type': None,
            'provenance': [],
            'details': {
                'action': 'TEMPLATE_ACTION',
                'skipped': 'empty_input'
            }
        }
        
    def _handle_composites(
        self, 
        identifiers: List[str], 
        strategy: str = 'split_and_match'
    ) -> List[str]:
        """
        Handle composite identifiers according to strategy.
        
        Args:
            identifiers: List of potentially composite identifiers
            strategy: How to handle composites
                - 'split_and_match': Split and include components
                - 'match_whole': Keep composites as-is
                - 'both': Include both composite and components
                
        Returns:
            Expanded list of identifiers
        """
        if strategy == 'match_whole':
            return identifiers
            
        expanded = []
        delimiter = '_'  # Standard composite delimiter
        
        for identifier in identifiers:
            # Always include original
            if strategy == 'both' or delimiter not in identifier:
                expanded.append(identifier)
                
            # Add components if composite
            if delimiter in identifier and strategy in ('split_and_match', 'both'):
                components = identifier.split(delimiter)
                expanded.extend(components)
                
        # Remove duplicates while preserving order
        seen = set()
        result = []
        for item in expanded:
            if item not in seen:
                seen.add(item)
                result.append(item)
                
        return result
        
    async def _process_identifier(
        self,
        identifier: str,
        source_endpoint: Endpoint,
        target_endpoint: Endpoint,
        params: Dict[str, Any]
    ) -> Optional[Dict[str, Any]]:
        """
        Process a single identifier.
        
        TODO: Implement your identifier processing logic here.
        
        Args:
            identifier: The identifier to process
            source_endpoint: Source endpoint
            target_endpoint: Target endpoint  
            params: Action parameters
            
        Returns:
            Dictionary with 'outputs' and 'provenance' or None if failed
        """
        # Example implementation (replace with real logic)
        return {
            'outputs': [identifier],  # Transformed identifier(s)
            'provenance': [{
                'action': 'TEMPLATE_ACTION',
                'timestamp': datetime.utcnow().isoformat(),
                'input': identifier,
                'output': identifier,
                'confidence': 1.0,
                'method': 'template_method',
                'details': {}
            }]
        }